"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(action-browser)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(action-browser)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(action-browser)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(action-browser)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class PlatformLoggerServiceImpl {\n    constructor(container){\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers.map((provider)=>{\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            } else {\n                return null;\n            }\n        }).filter((logString)=>logString).join(\" \");\n    }\n}\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */ function isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */ ;\n}\nconst name$p = \"@firebase/app\";\nconst version$1 = \"0.10.6\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(\"@firebase/app\");\nconst name$o = \"@firebase/app-compat\";\nconst name$n = \"@firebase/analytics-compat\";\nconst name$m = \"@firebase/analytics\";\nconst name$l = \"@firebase/app-check-compat\";\nconst name$k = \"@firebase/app-check\";\nconst name$j = \"@firebase/auth\";\nconst name$i = \"@firebase/auth-compat\";\nconst name$h = \"@firebase/database\";\nconst name$g = \"@firebase/database-compat\";\nconst name$f = \"@firebase/functions\";\nconst name$e = \"@firebase/functions-compat\";\nconst name$d = \"@firebase/installations\";\nconst name$c = \"@firebase/installations-compat\";\nconst name$b = \"@firebase/messaging\";\nconst name$a = \"@firebase/messaging-compat\";\nconst name$9 = \"@firebase/performance\";\nconst name$8 = \"@firebase/performance-compat\";\nconst name$7 = \"@firebase/remote-config\";\nconst name$6 = \"@firebase/remote-config-compat\";\nconst name$5 = \"@firebase/storage\";\nconst name$4 = \"@firebase/storage-compat\";\nconst name$3 = \"@firebase/firestore\";\nconst name$2 = \"@firebase/vertexai-preview\";\nconst name$1 = \"@firebase/firestore-compat\";\nconst name = \"firebase\";\nconst version = \"10.12.3\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The default app name\r\n *\r\n * @internal\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\nconst PLATFORM_LOG_STRING = {\n    [name$p]: \"fire-core\",\n    [name$o]: \"fire-core-compat\",\n    [name$m]: \"fire-analytics\",\n    [name$n]: \"fire-analytics-compat\",\n    [name$k]: \"fire-app-check\",\n    [name$l]: \"fire-app-check-compat\",\n    [name$j]: \"fire-auth\",\n    [name$i]: \"fire-auth-compat\",\n    [name$h]: \"fire-rtdb\",\n    [name$g]: \"fire-rtdb-compat\",\n    [name$f]: \"fire-fn\",\n    [name$e]: \"fire-fn-compat\",\n    [name$d]: \"fire-iid\",\n    [name$c]: \"fire-iid-compat\",\n    [name$b]: \"fire-fcm\",\n    [name$a]: \"fire-fcm-compat\",\n    [name$9]: \"fire-perf\",\n    [name$8]: \"fire-perf-compat\",\n    [name$7]: \"fire-rc\",\n    [name$6]: \"fire-rc-compat\",\n    [name$5]: \"fire-gcs\",\n    [name$4]: \"fire-gcs-compat\",\n    [name$3]: \"fire-fst\",\n    [name$1]: \"fire-fst-compat\",\n    [name$2]: \"fire-vertex\",\n    \"fire-js\": \"fire-js\",\n    [name]: \"fire-js-all\"\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ const _apps = new Map();\n/**\r\n * @internal\r\n */ const _serverApps = new Map();\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */ function _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    } catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\r\n *\r\n * @internal\r\n */ function _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */ function _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()){\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()){\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */ function _getProvider(app, name) {\n    const heartbeatController = app.container.getProvider(\"heartbeat\").getImmediate({\n        optional: true\n    });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */ function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\r\n *\r\n * @returns true if the provide object is of type FirebaseApp.\r\n *\r\n * @internal\r\n */ function _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp.\r\n *\r\n * @returns true if the provided object is of type FirebaseServerAppImpl.\r\n *\r\n * @internal\r\n */ function _isFirebaseServerApp(obj) {\n    return obj.settings !== undefined;\n}\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */ function _clearComponents() {\n    _components.clear();\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */ ]: \"No Firebase App '{$appName}' has been created - \" + \"call initializeApp() first\",\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */ ]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */ ]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */ ]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */ ]: \"Firebase Server App has been deleted\",\n    [\"no-options\" /* AppError.NO_OPTIONS */ ]: \"Need to provide options, when not being deployed to hosting via source.\",\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */ ]: \"firebase.{$appName}() takes either no argument or a \" + \"Firebase App instance.\",\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ ]: \"First argument to `onLog` must be null or a function.\",\n    [\"idb-open\" /* AppError.IDB_OPEN */ ]: \"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-get\" /* AppError.IDB_GET */ ]: \"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-set\" /* AppError.IDB_WRITE */ ]: \"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-delete\" /* AppError.IDB_DELETE */ ]: \"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */ ]: \"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.\",\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */ ]: \"FirebaseServerApp is not for use in browser environments.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(\"app\", \"Firebase\", ERRORS);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FirebaseAppImpl {\n    constructor(options, config, container){\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"app\", ()=>this, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */ checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */ , {\n                appName: this._name\n            });\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container){\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined ? serverConfig.automaticDataCollectionEnabled : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        } else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({\n            automaticDataCollectionEnabled\n        }, serverConfig);\n        this._finalizationRegistry = null;\n        if (typeof FinalizationRegistry !== \"undefined\") {\n            this._finalizationRegistry = new FinalizationRegistry(()=>{\n                this.automaticCleanup();\n            });\n        }\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegisry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$p, version$1, \"serverapp\");\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined && this._finalizationRegistry !== null) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */ checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */ );\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */ const SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== \"object\") {\n        const name = rawConfig;\n        rawConfig = {\n            name\n        };\n    }\n    const config = Object.assign({\n        name: DEFAULT_ENTRY_NAME,\n        automaticDataCollectionEnabled: false\n    }, rawConfig);\n    const name = config.name;\n    if (typeof name !== \"string\" || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */ , {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */ );\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        } else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */ , {\n                appName: name\n            });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()){\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isWebWorker)()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */ );\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    } else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s)=>{\n        return [\n            ...s\n        ].reduce((hash, c)=>Math.imul(31, hash) + c.charCodeAt(0) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === \"undefined\") {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */ , {});\n        }\n    }\n    const nameString = \"\" + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\n    for (const component of _components.values()){\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */ function getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */ , {\n            appName: name\n        });\n    }\n    return app;\n}\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */ function getApps() {\n    return Array.from(_apps.values());\n}\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */ async function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    } else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container.getProviders().map((provider)=>provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */ function registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push(\"and\");\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(\" \"));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, ()=>({\n            library,\n            version\n        }), \"VERSION\" /* ComponentType.VERSION */ ));\n}\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */ function onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== \"function\") {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ );\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */ function setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DB_NAME = \"firebase-heartbeat-database\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"firebase-heartbeat-store\";\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion)=>{\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch(oldVersion){\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        } catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch((e)=>{\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */ , {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, \"readwrite\");\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container){\n        this.container = container;\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */ this._heartbeatsCache = null;\n        const app = this.container.getProvider(\"app\").getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then((result)=>{\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */ async triggerHeartbeat() {\n        var _a, _b;\n        const platformLogger = this.container.getProvider(\"platform-logger\").getImmediate();\n        // This is the \"Firebase user agent\" string from the platform logger\n        // service, not the browser user agent.\n        const agent = platformLogger.getPlatformInfoString();\n        const date = getUTCDateString();\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n            this._heartbeatsCache = await this._heartbeatsCachePromise;\n            // If we failed to construct a heartbeats cache, then return immediately.\n            if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                return;\n            }\n        }\n        // Do not store a heartbeat if one is already stored for this day\n        // or if a header has already been sent today.\n        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat)=>singleDateHeartbeat.date === date)) {\n            return;\n        } else {\n            // There is no entry for this date. Create one.\n            this._heartbeatsCache.heartbeats.push({\n                date,\n                agent\n            });\n        }\n        // Remove entries older than 30 days.\n        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat)=>{\n            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n            const now = Date.now();\n            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n        });\n        return this._storage.overwrite(this._heartbeatsCache);\n    }\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */ async getHeartbeatsHeader() {\n        var _a;\n        if (this._heartbeatsCache === null) {\n            await this._heartbeatsCachePromise;\n        }\n        // If it's still null or the array is empty, there is no data to send.\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {\n            return \"\";\n        }\n        const date = getUTCDateString();\n        // Extract as many heartbeats from the cache as will fit under the size limit.\n        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({\n            version: 2,\n            heartbeats: heartbeatsToSend\n        }));\n        // Store last sent date to prevent another being logged/sent for the same day.\n        this._heartbeatsCache.lastSentHeartbeatDate = date;\n        if (unsentEntries.length > 0) {\n            // Store any unsent entries if they exist.\n            this._heartbeatsCache.heartbeats = unsentEntries;\n            // This seems more likely than emptying the array (below) to lead to some odd state\n            // since the cache isn't empty and this will be called again on the next request,\n            // and is probably safest if we await it.\n            await this._storage.overwrite(this._heartbeatsCache);\n        } else {\n            this._heartbeatsCache.heartbeats = [];\n            // Do not wait for this, to reduce latency.\n            void this._storage.overwrite(this._heartbeatsCache);\n        }\n        return headerString;\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache){\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find((hb)=>hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [\n                    singleDateHeartbeat.date\n                ]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        } else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app){\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        } else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)().then(()=>true).catch(()=>false);\n        }\n    }\n    /**\r\n     * Read all heartbeats.\r\n     */ async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return {\n                heartbeats: []\n            };\n        } else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            } else {\n                return {\n                    heartbeats: []\n                };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */ function countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(// heartbeatsCache wrapper properties\n    JSON.stringify({\n        version: 2,\n        heartbeats: heartbeatsCache\n    })).length;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"platform-logger\", (container)=>new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"heartbeat\", (container)=>new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    // Register `app` package.\n    registerVersion(name$p, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    registerVersion(name$p, version$1, \"esm2017\");\n    // Register platform SDK identifier (no version).\n    registerVersion(\"fire-js\", \"\");\n}\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */ registerCoreComponents(\"\");\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDdUI7QUFDMEc7QUFDdEo7QUFDbEI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTWdCO0lBQ0ZDLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDckI7SUFDQSxxRUFBcUU7SUFDckUsK0RBQStEO0lBQy9EQyx3QkFBd0I7UUFDcEIsTUFBTUMsWUFBWSxJQUFJLENBQUNGLFNBQVMsQ0FBQ0csWUFBWTtRQUM3Qyx5RUFBeUU7UUFDekUsc0JBQXNCO1FBQ3RCLE9BQU9ELFVBQ0ZFLEdBQUcsQ0FBQ0MsQ0FBQUE7WUFDTCxJQUFJQyx5QkFBeUJELFdBQVc7Z0JBQ3BDLE1BQU1FLFVBQVVGLFNBQVNHLFlBQVk7Z0JBQ3JDLE9BQU8sQ0FBQyxFQUFFRCxRQUFRRSxPQUFPLENBQUMsQ0FBQyxFQUFFRixRQUFRRyxPQUFPLENBQUMsQ0FBQztZQUNsRCxPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKLEdBQ0tDLE1BQU0sQ0FBQ0MsQ0FBQUEsWUFBYUEsV0FDcEJDLElBQUksQ0FBQztJQUNkO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1AseUJBQXlCRCxRQUFRO0lBQ3RDLE1BQU1TLFlBQVlULFNBQVNVLFlBQVk7SUFDdkMsT0FBTyxDQUFDRCxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUUsSUFBSSxNQUFNLFVBQVUseUJBQXlCO0FBQ3pIO0FBRUEsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFlBQVk7QUFFbEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUMsU0FBUyxJQUFJbkMsb0RBQU1BLENBQUM7QUFFMUIsTUFBTW9DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FB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MERBQVNBLENBQUMsYUFBYWtCLENBQUFBLFlBQWEsSUFBSXlMLHFCQUFxQnpMLFlBQVksVUFBVSx5QkFBeUI7SUFDbkksMEJBQTBCO0lBQzFCNkcsZ0JBQWdCNUYsUUFBUUMsV0FBV2lJO0lBQ25DLCtGQUErRjtJQUMvRnRDLGdCQUFnQjVGLFFBQVFDLFdBQVc7SUFDbkMsaURBQWlEO0lBQ2pEMkYsZ0JBQWdCLFdBQVc7QUFDL0I7QUFFQTs7Ozs7Q0FLQyxHQUNEMEgsdUJBQXVCO0FBRTRVLENBQ25XLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3NoZWtoYXItZW50ZXJwcmlzZXMvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzcyYzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgc2V0VXNlckxvZ0hhbmRsZXIsIHNldExvZ0xldmVsIGFzIHNldExvZ0xldmVsJDEgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgZ2V0RGVmYXVsdEFwcENvbmZpZywgZGVlcEVxdWFsLCBpc0Jyb3dzZXIsIGlzV2ViV29ya2VyLCBGaXJlYmFzZUVycm9yLCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZywgaXNJbmRleGVkREJBdmFpbGFibGUsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5leHBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgb3BlbkRCIH0gZnJvbSAnaWRiJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIC8vIEluIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgaW5zdGFsbGF0aW9ucyBvblxyXG4gICAgLy8gYXV0aCB0b2tlbiByZWZyZXNoLCBhbmQgaW5zdGFsbGF0aW9ucyB3aWxsIHNlbmQgdGhpcyBzdHJpbmcuXHJcbiAgICBnZXRQbGF0Zm9ybUluZm9TdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gdGhpcy5jb250YWluZXIuZ2V0UHJvdmlkZXJzKCk7XHJcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHByb3ZpZGVycyBhbmQgZ2V0IGxpYnJhcnkvdmVyc2lvbiBwYWlycyBmcm9tIGFueSB0aGF0IGFyZVxyXG4gICAgICAgIC8vIHZlcnNpb24gY29tcG9uZW50cy5cclxuICAgICAgICByZXR1cm4gcHJvdmlkZXJzXHJcbiAgICAgICAgICAgIC5tYXAocHJvdmlkZXIgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IHByb3ZpZGVyLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NlcnZpY2UubGlicmFyeX0vJHtzZXJ2aWNlLnZlcnNpb259YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihsb2dTdHJpbmcgPT4gbG9nU3RyaW5nKVxyXG4gICAgICAgICAgICAuam9pbignICcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvdmlkZXIgY2hlY2sgaWYgdGhpcyBwcm92aWRlciBwcm92aWRlcyBhIFZlcnNpb25TZXJ2aWNlXHJcbiAqXHJcbiAqIE5PVEU6IFVzaW5nIFByb3ZpZGVyPCdhcHAtdmVyc2lvbic+IGlzIGEgaGFjayB0byBpbmRpY2F0ZSB0aGF0IHRoZSBwcm92aWRlclxyXG4gKiBwcm92aWRlcyBWZXJzaW9uU2VydmljZS4gVGhlIHByb3ZpZGVyIGlzIG5vdCBuZWNlc3NhcmlseSBhICdhcHAtdmVyc2lvbidcclxuICogcHJvdmlkZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIocHJvdmlkZXIpIHtcclxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHByb3ZpZGVyLmdldENvbXBvbmVudCgpO1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQgPT09IG51bGwgfHwgY29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnQudHlwZSkgPT09IFwiVkVSU0lPTlwiIC8qIENvbXBvbmVudFR5cGUuVkVSU0lPTiAqLztcclxufVxuXG5jb25zdCBuYW1lJHAgPSBcIkBmaXJlYmFzZS9hcHBcIjtcbmNvbnN0IHZlcnNpb24kMSA9IFwiMC4xMC42XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hcHAnKTtcblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYXBwLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG4gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3MtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbSA9IFwiQGZpcmViYXNlL2FuYWx5dGljc1wiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2stY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkayA9IFwiQGZpcmViYXNlL2FwcC1jaGVja1wiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hdXRoXCI7XG5cbmNvbnN0IG5hbWUkaSA9IFwiQGZpcmViYXNlL2F1dGgtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkaCA9IFwiQGZpcmViYXNlL2RhdGFiYXNlXCI7XG5cbmNvbnN0IG5hbWUkZyA9IFwiQGZpcmViYXNlL2RhdGFiYXNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGYgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnNcIjtcblxuY29uc3QgbmFtZSRlID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGQgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zXCI7XG5cbmNvbnN0IG5hbWUkYyA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkYiA9IFwiQGZpcmViYXNlL21lc3NhZ2luZ1wiO1xuXG5jb25zdCBuYW1lJGEgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkOSA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlXCI7XG5cbmNvbnN0IG5hbWUkOCA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDcgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnXCI7XG5cbmNvbnN0IG5hbWUkNiA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNSA9IFwiQGZpcmViYXNlL3N0b3JhZ2VcIjtcblxuY29uc3QgbmFtZSQ0ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQzID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5cbmNvbnN0IG5hbWUkMiA9IFwiQGZpcmViYXNlL3ZlcnRleGFpLXByZXZpZXdcIjtcblxuY29uc3QgbmFtZSQxID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lID0gXCJmaXJlYmFzZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMTAuMTIuM1wiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgYXBwIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcclxuY29uc3QgUExBVEZPUk1fTE9HX1NUUklORyA9IHtcclxuICAgIFtuYW1lJHBdOiAnZmlyZS1jb3JlJyxcclxuICAgIFtuYW1lJG9dOiAnZmlyZS1jb3JlLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRtXTogJ2ZpcmUtYW5hbHl0aWNzJyxcclxuICAgIFtuYW1lJG5dOiAnZmlyZS1hbmFseXRpY3MtY29tcGF0JyxcclxuICAgIFtuYW1lJGtdOiAnZmlyZS1hcHAtY2hlY2snLFxyXG4gICAgW25hbWUkbF06ICdmaXJlLWFwcC1jaGVjay1jb21wYXQnLFxyXG4gICAgW25hbWUkal06ICdmaXJlLWF1dGgnLFxyXG4gICAgW25hbWUkaV06ICdmaXJlLWF1dGgtY29tcGF0JyxcclxuICAgIFtuYW1lJGhdOiAnZmlyZS1ydGRiJyxcclxuICAgIFtuYW1lJGddOiAnZmlyZS1ydGRiLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRmXTogJ2ZpcmUtZm4nLFxyXG4gICAgW25hbWUkZV06ICdmaXJlLWZuLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRkXTogJ2ZpcmUtaWlkJyxcclxuICAgIFtuYW1lJGNdOiAnZmlyZS1paWQtY29tcGF0JyxcclxuICAgIFtuYW1lJGJdOiAnZmlyZS1mY20nLFxyXG4gICAgW25hbWUkYV06ICdmaXJlLWZjbS1jb21wYXQnLFxyXG4gICAgW25hbWUkOV06ICdmaXJlLXBlcmYnLFxyXG4gICAgW25hbWUkOF06ICdmaXJlLXBlcmYtY29tcGF0JyxcclxuICAgIFtuYW1lJDddOiAnZmlyZS1yYycsXHJcbiAgICBbbmFtZSQ2XTogJ2ZpcmUtcmMtY29tcGF0JyxcclxuICAgIFtuYW1lJDVdOiAnZmlyZS1nY3MnLFxyXG4gICAgW25hbWUkNF06ICdmaXJlLWdjcy1jb21wYXQnLFxyXG4gICAgW25hbWUkM106ICdmaXJlLWZzdCcsXHJcbiAgICBbbmFtZSQxXTogJ2ZpcmUtZnN0LWNvbXBhdCcsXHJcbiAgICBbbmFtZSQyXTogJ2ZpcmUtdmVydGV4JyxcclxuICAgICdmaXJlLWpzJzogJ2ZpcmUtanMnLFxyXG4gICAgW25hbWVdOiAnZmlyZS1qcy1hbGwnXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IF9hcHBzID0gbmV3IE1hcCgpO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBfc2VydmVyQXBwcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVyZWQgY29tcG9uZW50cy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhcHAuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsIGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgYXBwLmNvbnRhaW5lci5hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xyXG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xyXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlcmUgd2VyZSBtdWx0aXBsZSBhdHRlbXB0cyB0byByZWdpc3RlciBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcclxuICAgIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcclxuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlcnZlckFwcCBvZiBfc2VydmVyQXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoc2VydmVyQXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XHJcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxyXG4gICAgICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcclxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xyXG4gICAgICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXHJcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGFwcCwgbmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcCBvciBGaXJlYmFzZU9wdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGUgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VBcHAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLm9wdGlvbnMgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvZiB0eXBlIEZpcmViYXNlQXBwLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2lzRmlyZWJhc2VTZXJ2ZXJBcHAob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLnNldHRpbmdzICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgb25seVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9jbGVhckNvbXBvbmVudHMoKSB7XHJcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVSUk9SUyA9IHtcclxuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xyXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXHJcbiAgICBbXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi9dOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9J1wiLFxyXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcclxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXHJcbiAgICBbXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi9dOiAnRmlyZWJhc2UgU2VydmVyIEFwcCBoYXMgYmVlbiBkZWxldGVkJyxcclxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcclxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xyXG4gICAgICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcclxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxyXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqL106ICdFcnJvciB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiZmluYWxpemF0aW9uLXJlZ2lzdHJ5LW5vdC1zdXBwb3J0ZWRcIiAvKiBBcHBFcnJvci5GSU5BTElaQVRJT05fUkVHSVNUUllfTk9UX1NVUFBPUlRFRCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBkZWxldGVPbkRlcmVmIGZpZWxkIGRlZmluZWQgYnV0IHRoZSBKUyBydW50aW1lIGRvZXMgbm90IHN1cHBvcnQgRmluYWxpemF0aW9uUmVnaXN0cnkuJyxcclxuICAgIFtcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBpcyBub3QgZm9yIHVzZSBpbiBicm93c2VyIGVudmlyb25tZW50cy4nXHJcbn07XHJcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cclxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgIH1cclxuICAgIGdldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWxldGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXHJcbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZVNlcnZlckFwcEltcGwgZXh0ZW5kcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgc2VydmVyQ29uZmlnLCBuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICAvLyBCdWlsZCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBGaXJlYmFzZUFwcEltcGwgYmFzZSBjbGFzcy5cclxuICAgICAgICBjb25zdCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBGaXJlYmFzZUFwcFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIEZpcmViYXNlQXBwSW1wIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHBhcmVudCBGaXJlYmFzZUFwcEltcCBvYmplY3QuXHJcbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcEltcGwgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBzdXBlcihhcHBJbXBsLm9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGNvbnN0cnVjdCB0aGUgZGF0YSBmb3IgdGhlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIH0sIHNlcnZlckNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXV0b21hdGljQ2xlYW51cCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5jUmVmQ291bnQodGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcclxuICAgICAgICAvLyBEbyBub3QgcmV0YWluIGEgaGFyZCByZWZlcmVuY2UgdG8gdGhlIGRyZWYgb2JqZWN0LCBvdGhlcndpc2UgdGhlIEZpbmFsaXphdGlvblJlZ2lzcnlcclxuICAgICAgICAvLyB3aWxsIG5ldmVyIHRyaWdnZXIuXHJcbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHNlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZiA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZWdpc3RlclZlcnNpb24obmFtZSRwLCB2ZXJzaW9uJDEsICdzZXJ2ZXJhcHAnKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJlZkNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZDb3VudDtcclxuICAgIH1cclxuICAgIC8vIEluY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgc2VydmVyIGFwcC4gSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkLCByZWdpc3RlciBpdFxyXG4gICAgLy8gd2l0aCB0aGUgZmluYWxpemF0aW9uIHJlZ2lzdHJ5LlxyXG4gICAgaW5jUmVmQ291bnQob2JqKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQrKztcclxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIob2JqLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEZWNyZW1lbnQgdGhlIHJlZmVyZW5jZSBjb3VudC5cclxuICAgIGRlY1JlZkNvdW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0tdGhpcy5fcmVmQ291bnQ7XHJcbiAgICB9XHJcbiAgICAvLyBJbnZva2VkIGJ5IHRoZSBGaW5hbGl6YXRpb25SZWdpc3RyeSBjYWxsYmFjayB0byBub3RlIHRoYXQgdGhpcyBhcHAgc2hvdWxkIGdvIHRocm91Z2ggaXRzXHJcbiAgICAvLyByZWZlcmVuY2UgY291bnRzIGFuZCBkZWxldGUgaXRzZWxmIGlmIG5vIHJlZmVyZW5jZSBjb3VudCByZW1haW4uIFRoZSBjb29yZGluYXRpbmcgbG9naWMgdGhhdFxyXG4gICAgLy8gaGFuZGxlcyB0aGlzIGlzIGluIGRlbGV0ZUFwcCguLi4pLlxyXG4gICAgYXV0b21hdGljQ2xlYW51cCgpIHtcclxuICAgICAgICB2b2lkIGRlbGV0ZUFwcCh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldCBzZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckNvbmZpZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cclxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxyXG4gICAgICovXHJcbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGN1cnJlbnQgU0RLIHZlcnNpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxuZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChfb3B0aW9ucywgcmF3Q29uZmlnID0ge30pIHtcclxuICAgIGxldCBvcHRpb25zID0gX29wdGlvbnM7XHJcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xyXG4gICAgICAgIHJhd0NvbmZpZyA9IHsgbmFtZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSwgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBmYWxzZSB9LCByYXdDb25maWcpO1xyXG4gICAgY29uc3QgbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovLCB7XHJcbiAgICAgICAgICAgIGFwcE5hbWU6IFN0cmluZyhuYW1lKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IGdldERlZmF1bHRBcHBDb25maWcoKSk7XHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKGV4aXN0aW5nQXBwKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cclxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXHJcbiAgICAgICAgICAgIGRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQXBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xyXG4gICAgX2FwcHMuc2V0KG5hbWUsIG5ld0FwcCk7XHJcbiAgICByZXR1cm4gbmV3QXBwO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRpYWxpemVTZXJ2ZXJBcHAoX29wdGlvbnMsIF9zZXJ2ZXJBcHBDb25maWcpIHtcclxuICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhaXNXZWJXb3JrZXIoKSkge1xyXG4gICAgICAgIC8vIEZpcmViYXNlU2VydmVyQXBwIGlzbid0IGRlc2lnbmVkIHRvIGJlIHJ1biBpbiBicm93c2Vycy5cclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIF9zZXJ2ZXJBcHBDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgYXBwT3B0aW9ucztcclxuICAgIGlmIChfaXNGaXJlYmFzZUFwcChfb3B0aW9ucykpIHtcclxuICAgICAgICBhcHBPcHRpb25zID0gX29wdGlvbnMub3B0aW9ucztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgIH1cclxuICAgIC8vIEJ1aWxkIGFuIGFwcCBuYW1lIGJhc2VkIG9uIGEgaGFzaCBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgY29uc3QgbmFtZU9iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3NlcnZlckFwcENvbmZpZyksIGFwcE9wdGlvbnMpO1xyXG4gICAgLy8gSG93ZXZlciwgRG8gbm90IG1hbmdsZSB0aGUgbmFtZSBiYXNlZCBvbiByZWxlYXNlT25EZXJlZiwgc2luY2UgaXQgd2lsbCB2YXJ5IGJldHdlZW4gdGhlXHJcbiAgICAvLyBjb25zdHJ1Y3Rpb24gb2YgRmlyZWJhc2VTZXJ2ZXJBcHAgaW5zdGFuY2VzLiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9iamVjdCBpcyB0aGUgcmVxdWVzdCBoZWFkZXJzLlxyXG4gICAgaWYgKG5hbWVPYmoucmVsZWFzZU9uRGVyZWYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGRlbGV0ZSBuYW1lT2JqLnJlbGVhc2VPbkRlcmVmO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzaENvZGUgPSAocykgPT4ge1xyXG4gICAgICAgIHJldHVybiBbLi4uc10ucmVkdWNlKChoYXNoLCBjKSA9PiAoTWF0aC5pbXVsKDMxLCBoYXNoKSArIGMuY2hhckNvZGVBdCgwKSkgfCAwLCAwKTtcclxuICAgIH07XHJcbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJmaW5hbGl6YXRpb24tcmVnaXN0cnktbm90LXN1cHBvcnRlZFwiIC8qIEFwcEVycm9yLkZJTkFMSVpBVElPTl9SRUdJU1RSWV9OT1RfU1VQUE9SVEVEICovLCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbmFtZVN0cmluZyA9ICcnICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkobmFtZU9iaikpO1xyXG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfc2VydmVyQXBwcy5nZXQobmFtZVN0cmluZyk7XHJcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcclxuICAgICAgICBleGlzdGluZ0FwcC5pbmNSZWZDb3VudChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29tcG9uZW50Q29udGFpbmVyKG5hbWVTdHJpbmcpO1xyXG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgX2NvbXBvbmVudHMudmFsdWVzKCkpIHtcclxuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdBcHAgPSBuZXcgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsKGFwcE9wdGlvbnMsIF9zZXJ2ZXJBcHBDb25maWcsIG5hbWVTdHJpbmcsIGNvbnRhaW5lcik7XHJcbiAgICBfc2VydmVyQXBwcy5zZXQobmFtZVN0cmluZywgbmV3QXBwKTtcclxuICAgIHJldHVybiBuZXdBcHA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cclxuICpcclxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxyXG4gKiBpcyBwcm92aWRlZCwgdGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cclxuICpcclxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXHJcbiAqIGluaXRpYWxpemVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFJldHVybiB0aGUgZGVmYXVsdCBhcHBcclxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFJldHVybiBhIG5hbWVkIGFwcFxyXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXHJcbiAqICAgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGlzIGBcIltERUZBVUxUXVwiYC5cclxuICpcclxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cclxuICogICBJZiBubyBhcHAgbmFtZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcHAobmFtZSA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgY29uc3QgYXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKCFhcHAgJiYgbmFtZSA9PT0gREVGQVVMVF9FTlRSWV9OQU1FICYmIGdldERlZmF1bHRBcHBDb25maWcoKSkge1xyXG4gICAgICAgIHJldHVybiBpbml0aWFsaXplQXBwKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFwcCkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwO1xyXG59XHJcbi8qKlxyXG4gKiBBIChyZWFkLW9ubHkpIGFycmF5IG9mIGFsbCBpbml0aWFsaXplZCBhcHBzLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcHBzKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oX2FwcHMudmFsdWVzKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoaXMgYXBwIHVudXNhYmxlIGFuZCBmcmVlcyB0aGUgcmVzb3VyY2VzIG9mIGFsbCBhc3NvY2lhdGVkXHJcbiAqIHNlcnZpY2VzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGRlbGV0ZUFwcChhcHApXHJcbiAqICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkFwcCBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICogICB9KVxyXG4gKiAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZWxldGluZyBhcHA6XCIsIGVycm9yKTtcclxuICogICB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFwcChhcHApIHtcclxuICAgIGxldCBjbGVhbnVwUHJvdmlkZXJzID0gZmFsc2U7XHJcbiAgICBjb25zdCBuYW1lID0gYXBwLm5hbWU7XHJcbiAgICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XHJcbiAgICAgICAgX2FwcHMuZGVsZXRlKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoX3NlcnZlckFwcHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTZXJ2ZXJBcHAgPSBhcHA7XHJcbiAgICAgICAgaWYgKGZpcmViYXNlU2VydmVyQXBwLmRlY1JlZkNvdW50KCkgPD0gMCkge1xyXG4gICAgICAgICAgICBfc2VydmVyQXBwcy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgIGNsZWFudXBQcm92aWRlcnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjbGVhbnVwUHJvdmlkZXJzKSB7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXBwLmNvbnRhaW5lclxyXG4gICAgICAgICAgICAuZ2V0UHJvdmlkZXJzKClcclxuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiBwcm92aWRlci5kZWxldGUoKSkpO1xyXG4gICAgICAgIGFwcC5pc0RlbGV0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBsaWJyYXJ5J3MgbmFtZSBhbmQgdmVyc2lvbiBmb3IgcGxhdGZvcm0gbG9nZ2luZyBwdXJwb3Nlcy5cclxuICogQHBhcmFtIGxpYnJhcnkgLSBOYW1lIG9mIDFwIG9yIDNwIGxpYnJhcnkgKGUuZy4gZmlyZXN0b3JlLCBhbmd1bGFyZmlyZSlcclxuICogQHBhcmFtIHZlcnNpb24gLSBDdXJyZW50IHZlcnNpb24gb2YgdGhhdCBsaWJyYXJ5LlxyXG4gKiBAcGFyYW0gdmFyaWFudCAtIEJ1bmRsZSB2YXJpYW50LCBlLmcuLCBub2RlLCBybiwgZXRjLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclZlcnNpb24obGlicmFyeUtleU9yTmFtZSwgdmVyc2lvbiwgdmFyaWFudCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgLy8gVE9ETzogV2UgY2FuIHVzZSB0aGlzIGNoZWNrIHRvIHdoaXRlbGlzdCBzdHJpbmdzIHdoZW4vaWYgd2Ugc2V0IHVwXHJcbiAgICAvLyBhIGdvb2Qgd2hpdGVsaXN0IHN5c3RlbS5cclxuICAgIGxldCBsaWJyYXJ5ID0gKF9hID0gUExBVEZPUk1fTE9HX1NUUklOR1tsaWJyYXJ5S2V5T3JOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGlicmFyeUtleU9yTmFtZTtcclxuICAgIGlmICh2YXJpYW50KSB7XHJcbiAgICAgICAgbGlicmFyeSArPSBgLSR7dmFyaWFudH1gO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGlicmFyeU1pc21hdGNoID0gbGlicmFyeS5tYXRjaCgvXFxzfFxcLy8pO1xyXG4gICAgY29uc3QgdmVyc2lvbk1pc21hdGNoID0gdmVyc2lvbi5tYXRjaCgvXFxzfFxcLy8pO1xyXG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCB8fCB2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB3YXJuaW5nID0gW1xyXG4gICAgICAgICAgICBgVW5hYmxlIHRvIHJlZ2lzdGVyIGxpYnJhcnkgXCIke2xpYnJhcnl9XCIgd2l0aCB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiOmBcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGBsaWJyYXJ5IG5hbWUgXCIke2xpYnJhcnl9XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoICYmIHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goJ2FuZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgdmVyc2lvbiBuYW1lIFwiJHt2ZXJzaW9ufVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZy5qb2luKCcgJykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KGAke2xpYnJhcnl9LXZlcnNpb25gLCAoKSA9PiAoeyBsaWJyYXJ5LCB2ZXJzaW9uIH0pLCBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi8pKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgaGFuZGxlciBmb3IgYWxsIEZpcmViYXNlIFNES3MuXHJcbiAqIEBwYXJhbSBsb2dDYWxsYmFjayAtIEFuIG9wdGlvbmFsIGN1c3RvbSBsb2cgaGFuZGxlciB0aGF0IGV4ZWN1dGVzIHVzZXIgY29kZSB3aGVuZXZlclxyXG4gKiB0aGUgRmlyZWJhc2UgU0RLIG1ha2VzIGEgbG9nZ2luZyBjYWxsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBvbkxvZyhsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgaWYgKGxvZ0NhbGxiYWNrICE9PSBudWxsICYmIHR5cGVvZiBsb2dDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgbG9nIGxldmVsIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICpcclxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGFyZSBjYXB0dXJlZCAoaS5lLiBpZlxyXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYGluZm9gLCBlcnJvcnMgYXJlIGxvZ2dlZCwgYnV0IGBkZWJ1Z2AgYW5kXHJcbiAqIGB2ZXJib3NlYCBsb2dzIGFyZSBub3QpLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xyXG4gICAgc2V0TG9nTGV2ZWwkMShsb2dMZXZlbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREJfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtZGF0YWJhc2UnO1xyXG5jb25zdCBEQl9WRVJTSU9OID0gMTtcclxuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xyXG5sZXQgZGJQcm9taXNlID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCkge1xyXG4gICAgaWYgKCFkYlByb21pc2UpIHtcclxuICAgICAgICBkYlByb21pc2UgPSBvcGVuREIoREJfTkFNRSwgREJfVkVSU0lPTiwge1xyXG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgaXMgd2hhdCB3ZSB3YW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpL2lPUyBicm93c2VycyB0aHJvdyBvY2Nhc2lvbmFsIGV4Y2VwdGlvbnMgb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCkgdGhhdCBtYXkgYmUgYSBidWcuIEF2b2lkIGJsb2NraW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVzdCBvZiB0aGUgYXBwIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGJQcm9taXNlO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQihhcHApIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcclxuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpLmdldChjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGUgdmFsdWUgYnV0IHR4LmRvbmUgY2FuIHRocm93LFxyXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gYXdhaXQgaXQgaGVyZSB0byBjYXRjaCBlcnJvcnNcclxuICAgICAgICBhd2FpdCB0eC5kb25lO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1nZXRcIiAvKiBBcHBFcnJvci5JREJfR0VUICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQihhcHAsIGhlYXJ0YmVhdE9iamVjdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgYXdhaXQgb2JqZWN0U3RvcmUucHV0KGhlYXJ0YmVhdE9iamVjdCwgY29tcHV0ZUtleShhcHApKTtcclxuICAgICAgICBhd2FpdCB0eC5kb25lO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlS2V5KGFwcCkge1xyXG4gICAgcmV0dXJuIGAke2FwcC5uYW1lfSEke2FwcC5vcHRpb25zLmFwcElkfWA7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTUFYX0hFQURFUl9CWVRFUyA9IDEwMjQ7XHJcbi8vIDMwIGRheXNcclxuY29uc3QgU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyA9IDMwICogMjQgKiA2MCAqIDYwICogMTAwMDtcclxuY2xhc3MgSGVhcnRiZWF0U2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW4tbWVtb3J5IGNhY2hlIGZvciBoZWFydGJlYXRzLCB1c2VkIGJ5IGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB0byBnZW5lcmF0ZVxyXG4gICAgICAgICAqIHRoZSBoZWFkZXIgc3RyaW5nLlxyXG4gICAgICAgICAqIFN0b3JlcyBvbmUgcmVjb3JkIHBlciBkYXRlLiBUaGlzIHdpbGwgYmUgY29uc29saWRhdGVkIGludG8gdGhlIHN0YW5kYXJkXHJcbiAgICAgICAgICogZm9ybWF0IG9mIG9uZSByZWNvcmQgcGVyIHVzZXIgYWdlbnQgc3RyaW5nIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgaGVhZGVyLlxyXG4gICAgICAgICAqIFBvcHVsYXRlZCBmcm9tIGluZGV4ZWREQiB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBhbmQgc2hvdWxkXHJcbiAgICAgICAgICogYmUga2VwdCBpbiBzeW5jIHdpdGggaW5kZXhlZERCLlxyXG4gICAgICAgICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gbnVsbDtcclxuICAgICAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2UgPSB0aGlzLl9zdG9yYWdlLnJlYWQoKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHRvIHJlcG9ydCBhIGhlYXJ0YmVhdC4gVGhlIGZ1bmN0aW9uIHdpbGwgZ2VuZXJhdGVcclxuICAgICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcclxuICAgICAqIHRvIEluZGV4ZWREQi5cclxuICAgICAqIE5vdGUgdGhhdCB3ZSBvbmx5IHN0b3JlIG9uZSBoZWFydGJlYXQgcGVyIGRheS4gU28gaWYgYSBoZWFydGJlYXQgZm9yIHRvZGF5IGlzXHJcbiAgICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHRyaWdnZXJIZWFydGJlYXQoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBwbGF0Zm9ybUxvZ2dlciA9IHRoaXMuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIFwiRmlyZWJhc2UgdXNlciBhZ2VudFwiIHN0cmluZyBmcm9tIHRoZSBwbGF0Zm9ybSBsb2dnZXJcclxuICAgICAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBjb25zdHJ1Y3QgYSBoZWFydGJlYXRzIGNhY2hlLCB0aGVuIHJldHVybiBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgaWYgKCgoX2IgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWFydGJlYXRzKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcclxuICAgICAgICAvLyBvciBpZiBhIGhlYWRlciBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdG9kYXkuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPT09IGRhdGUgfHxcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSA9PT0gZGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgZGF0ZS4gQ3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMucHVzaCh7IGRhdGUsIGFnZW50IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgZW50cmllcyBvbGRlciB0aGFuIDMwIGRheXMuXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5maWx0ZXIoc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhiVGltZXN0YW1wID0gbmV3IERhdGUoc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBub3cgLSBoYlRpbWVzdGFtcCA8PSBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHdoaWNoIGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgaGVhcnRiZWF0LXNwZWNpZmljIGhlYWRlciBkaXJlY3RseS5cclxuICAgICAqIEl0IGFsc28gY2xlYXJzIGFsbCBoZWFydGJlYXRzIGZyb20gbWVtb3J5IGFzIHdlbGwgYXMgaW4gSW5kZXhlZERCLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IENvbnN1bWluZyBwcm9kdWN0IFNES3Mgc2hvdWxkIG5vdCBzZW5kIHRoZSBoZWFkZXIgaWYgdGhpcyBtZXRob2RcclxuICAgICAqIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRIZWFydGJlYXRzSGVhZGVyKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGl0J3Mgc3RpbGwgbnVsbCBvciB0aGUgYXJyYXkgaXMgZW1wdHksIHRoZXJlIGlzIG5vIGRhdGEgdG8gc2VuZC5cclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwgfHxcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcclxuICAgICAgICAvLyBFeHRyYWN0IGFzIG1hbnkgaGVhcnRiZWF0cyBmcm9tIHRoZSBjYWNoZSBhcyB3aWxsIGZpdCB1bmRlciB0aGUgc2l6ZSBsaW1pdC5cclxuICAgICAgICBjb25zdCB7IGhlYXJ0YmVhdHNUb1NlbmQsIHVuc2VudEVudHJpZXMgfSA9IGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJTdHJpbmcgPSBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSkpO1xyXG4gICAgICAgIC8vIFN0b3JlIGxhc3Qgc2VudCBkYXRlIHRvIHByZXZlbnQgYW5vdGhlciBiZWluZyBsb2dnZWQvc2VudCBmb3IgdGhlIHNhbWUgZGF5LlxyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPSBkYXRlO1xyXG4gICAgICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gU3RvcmUgYW55IHVuc2VudCBlbnRyaWVzIGlmIHRoZXkgZXhpc3QuXHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdW5zZW50RW50cmllcztcclxuICAgICAgICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNhY2hlIGlzbid0IGVtcHR5IGFuZCB0aGlzIHdpbGwgYmUgY2FsbGVkIGFnYWluIG9uIHRoZSBuZXh0IHJlcXVlc3QsXHJcbiAgICAgICAgICAgIC8vIGFuZCBpcyBwcm9iYWJseSBzYWZlc3QgaWYgd2UgYXdhaXQgaXQuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcywgdG8gcmVkdWNlIGxhdGVuY3kuXHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlclN0cmluZztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRVVENEYXRlU3RyaW5nKCkge1xyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgLy8gUmV0dXJucyBkYXRlIGZvcm1hdCAnWVlZWS1NTS1ERCdcclxuICAgIHJldHVybiB0b2RheS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoaGVhcnRiZWF0c0NhY2hlLCBtYXhTaXplID0gTUFYX0hFQURFUl9CWVRFUykge1xyXG4gICAgLy8gSGVhcnRiZWF0cyBncm91cGVkIGJ5IHVzZXIgYWdlbnQgaW4gdGhlIHN0YW5kYXJkIGZvcm1hdCB0byBiZSBzZW50IGluXHJcbiAgICAvLyB0aGUgaGVhZGVyLlxyXG4gICAgY29uc3QgaGVhcnRiZWF0c1RvU2VuZCA9IFtdO1xyXG4gICAgLy8gU2luZ2xlIGRhdGUgZm9ybWF0IGhlYXJ0YmVhdHMgdGhhdCBhcmUgbm90IHNlbnQuXHJcbiAgICBsZXQgdW5zZW50RW50cmllcyA9IGhlYXJ0YmVhdHNDYWNoZS5zbGljZSgpO1xyXG4gICAgZm9yIChjb25zdCBzaW5nbGVEYXRlSGVhcnRiZWF0IG9mIGhlYXJ0YmVhdHNDYWNoZSkge1xyXG4gICAgICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCBoZWFydGJlYXRFbnRyeSA9IGhlYXJ0YmVhdHNUb1NlbmQuZmluZChoYiA9PiBoYi5hZ2VudCA9PT0gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCk7XHJcbiAgICAgICAgaWYgKCFoZWFydGJlYXRFbnRyeSkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBlbnRyeSBmb3IgdGhpcyB1c2VyIGFnZW50IGV4aXN0cywgY3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGFnZW50OiBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50LFxyXG4gICAgICAgICAgICAgICAgZGF0ZXM6IFtzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGVdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGhlYXJ0YmVhdFxyXG4gICAgICAgICAgICAgICAgLy8gZW50cnkgYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnB1c2goc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgZGF0ZVxyXG4gICAgICAgICAgICAvLyBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvcCB1bnNlbnQgZW50cnkgZnJvbSBxdWV1ZS4gKFNraXBwZWQgaWYgYWRkaW5nIHRoZSBlbnRyeSBleGNlZWRlZFxyXG4gICAgICAgIC8vIHF1b3RhIGFuZCB0aGUgbG9vcCBicmVha3MgZWFybHkuKVxyXG4gICAgICAgIHVuc2VudEVudHJpZXMgPSB1bnNlbnRFbnRyaWVzLnNsaWNlKDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFydGJlYXRzVG9TZW5kLFxyXG4gICAgICAgIHVuc2VudEVudHJpZXNcclxuICAgIH07XHJcbn1cclxuY2xhc3MgSGVhcnRiZWF0U3RvcmFnZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoYXBwKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZSA9IHRoaXMucnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpIHtcclxuICAgICAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGFsbCBoZWFydGJlYXRzLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWFkKCkge1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkhlYXJ0YmVhdE9iamVjdCA9IGF3YWl0IHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQih0aGlzLmFwcCk7XHJcbiAgICAgICAgICAgIGlmIChpZGJIZWFydGJlYXRPYmplY3QgPT09IG51bGwgfHwgaWRiSGVhcnRiZWF0T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZGJIZWFydGJlYXRPYmplY3QuaGVhcnRiZWF0cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvdmVyd3JpdGUgdGhlIHN0b3JhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgaGVhcnRiZWF0c1xyXG4gICAgYXN5bmMgb3ZlcndyaXRlKGhlYXJ0YmVhdHNPYmplY3QpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XHJcbiAgICAgICAgICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6IChfYSA9IGhlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxyXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGFkZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBhZGQoaGVhcnRiZWF0c09iamVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcclxuICogaW4gYSBwbGF0Zm9ybSBsb2dnaW5nIGhlYWRlciBKU09OIG9iamVjdCwgc3RyaW5naWZpZWQsIGFuZCBjb252ZXJ0ZWRcclxuICogdG8gYmFzZSA2NC5cclxuICovXHJcbmZ1bmN0aW9uIGNvdW50Qnl0ZXMoaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAvLyBiYXNlNjQgaGFzIGEgcmVzdHJpY3RlZCBzZXQgb2YgY2hhcmFjdGVycywgYWxsIG9mIHdoaWNoIHNob3VsZCBiZSAxIGJ5dGUuXHJcbiAgICByZXR1cm4gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXHJcbiAgICAvLyBoZWFydGJlYXRzQ2FjaGUgd3JhcHBlciBwcm9wZXJ0aWVzXHJcbiAgICBKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNDYWNoZSB9KSkubGVuZ3RoO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ29yZUNvbXBvbmVudHModmFyaWFudCkge1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ3BsYXRmb3JtLWxvZ2dlcicsIGNvbnRhaW5lciA9PiBuZXcgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdoZWFydGJlYXQnLCBjb250YWluZXIgPT4gbmV3IEhlYXJ0YmVhdFNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgLy8gUmVnaXN0ZXIgYGFwcGAgcGFja2FnZS5cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHAsIHZlcnNpb24kMSwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkcCwgdmVyc2lvbiQxLCAnZXNtMjAxNycpO1xyXG4gICAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKCdmaXJlLWpzJywgJycpO1xyXG59XG5cbi8qKlxyXG4gKiBGaXJlYmFzZSBBcHBcclxuICpcclxuICogQHJlbWFya3MgVGhpcyBwYWNrYWdlIGNvb3JkaW5hdGVzIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGRpZmZlcmVudCBGaXJlYmFzZSBjb21wb25lbnRzXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxucmVnaXN0ZXJDb3JlQ29tcG9uZW50cygnJyk7XG5cbmV4cG9ydCB7IFNES19WRVJTSU9OLCBERUZBVUxUX0VOVFJZX05BTUUgYXMgX0RFRkFVTFRfRU5UUllfTkFNRSwgX2FkZENvbXBvbmVudCwgX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50LCBfYXBwcywgX2NsZWFyQ29tcG9uZW50cywgX2NvbXBvbmVudHMsIF9nZXRQcm92aWRlciwgX2lzRmlyZWJhc2VBcHAsIF9pc0ZpcmViYXNlU2VydmVyQXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UsIF9zZXJ2ZXJBcHBzLCBkZWxldGVBcHAsIGdldEFwcCwgZ2V0QXBwcywgaW5pdGlhbGl6ZUFwcCwgaW5pdGlhbGl6ZVNlcnZlckFwcCwgb25Mb2csIHJlZ2lzdGVyVmVyc2lvbiwgc2V0TG9nTGV2ZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiQ29tcG9uZW50Q29udGFpbmVyIiwiTG9nZ2VyIiwic2V0VXNlckxvZ0hhbmRsZXIiLCJzZXRMb2dMZXZlbCIsInNldExvZ0xldmVsJDEiLCJFcnJvckZhY3RvcnkiLCJnZXREZWZhdWx0QXBwQ29uZmlnIiwiZGVlcEVxdWFsIiwiaXNCcm93c2VyIiwiaXNXZWJXb3JrZXIiLCJGaXJlYmFzZUVycm9yIiwiYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmciLCJpc0luZGV4ZWREQkF2YWlsYWJsZSIsInZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUiLCJvcGVuREIiLCJQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsIiwiY29uc3RydWN0b3IiLCJjb250YWluZXIiLCJnZXRQbGF0Zm9ybUluZm9TdHJpbmciLCJwcm92aWRlcnMiLCJnZXRQcm92aWRlcnMiLCJtYXAiLCJwcm92aWRlciIsImlzVmVyc2lvblNlcnZpY2VQcm92aWRlciIsInNlcnZpY2UiLCJnZXRJbW1lZGlhdGUiLCJsaWJyYXJ5IiwidmVyc2lvbiIsImZpbHRlciIsImxvZ1N0cmluZyIsImpvaW4iLCJjb21wb25lbnQiLCJnZXRDb21wb25lbnQiLCJ0eXBlIiwibmFtZSRwIiwidmVyc2lvbiQxIiwibG9nZ2VyIiwibmFtZSRvIiwibmFtZSRuIiwibmFtZSRtIiwibmFtZSRsIiwibmFtZSRrIiwibmFtZSRqIiwibmFtZSRpIiwibmFtZSRoIiwibmFtZSRnIiwibmFtZSRmIiwibmFtZSRlIiwibmFtZSRkIiwibmFtZSRjIiwibmFtZSRiIiwibmFtZSRhIiwibmFtZSQ5IiwibmFtZSQ4IiwibmFtZSQ3IiwibmFtZSQ2IiwibmFtZSQ1IiwibmFtZSQ0IiwibmFtZSQzIiwibmFtZSQyIiwibmFtZSQxIiwibmFtZSIsIkRFRkFVTFRfRU5UUllfTkFNRSIsIlBMQVRGT1JNX0xPR19TVFJJTkciLCJfYXBwcyIsIk1hcCIsIl9zZXJ2ZXJBcHBzIiwiX2NvbXBvbmVudHMiLCJfYWRkQ29tcG9uZW50IiwiYXBwIiwiYWRkQ29tcG9uZW50IiwiZSIsImRlYnVnIiwiX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50IiwiYWRkT3JPdmVyd3JpdGVDb21wb25lbnQiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJjb21wb25lbnROYW1lIiwiaGFzIiwic2V0IiwidmFsdWVzIiwic2VydmVyQXBwIiwiX2dldFByb3ZpZGVyIiwiaGVhcnRiZWF0Q29udHJvbGxlciIsImdldFByb3ZpZGVyIiwib3B0aW9uYWwiLCJ0cmlnZ2VySGVhcnRiZWF0IiwiX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSIsImluc3RhbmNlSWRlbnRpZmllciIsImNsZWFySW5zdGFuY2UiLCJfaXNGaXJlYmFzZUFwcCIsIm9iaiIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJfaXNGaXJlYmFzZVNlcnZlckFwcCIsInNldHRpbmdzIiwiX2NsZWFyQ29tcG9uZW50cyIsImNsZWFyIiwiRVJST1JTIiwiRVJST1JfRkFDVE9SWSIsIkZpcmViYXNlQXBwSW1wbCIsImNvbmZpZyIsIl9pc0RlbGV0ZWQiLCJfb3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIl9jb25maWciLCJfbmFtZSIsIl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJfY29udGFpbmVyIiwiY2hlY2tEZXN0cm95ZWQiLCJ2YWwiLCJpc0RlbGV0ZWQiLCJjcmVhdGUiLCJhcHBOYW1lIiwiRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsIiwic2VydmVyQ29uZmlnIiwiYXBpS2V5IiwiYXBwSW1wbCIsIl9zZXJ2ZXJDb25maWciLCJfZmluYWxpemF0aW9uUmVnaXN0cnkiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsImF1dG9tYXRpY0NsZWFudXAiLCJfcmVmQ291bnQiLCJpbmNSZWZDb3VudCIsInJlbGVhc2VPbkRlcmVmIiwicmVnaXN0ZXJWZXJzaW9uIiwidG9KU09OIiwicmVmQ291bnQiLCJyZWdpc3RlciIsImRlY1JlZkNvdW50IiwiZGVsZXRlQXBwIiwiU0RLX1ZFUlNJT04iLCJpbml0aWFsaXplQXBwIiwicmF3Q29uZmlnIiwiU3RyaW5nIiwiZXhpc3RpbmdBcHAiLCJnZXQiLCJuZXdBcHAiLCJpbml0aWFsaXplU2VydmVyQXBwIiwiX3NlcnZlckFwcENvbmZpZyIsImFwcE9wdGlvbnMiLCJuYW1lT2JqIiwiaGFzaENvZGUiLCJzIiwicmVkdWNlIiwiaGFzaCIsImMiLCJNYXRoIiwiaW11bCIsImNoYXJDb2RlQXQiLCJuYW1lU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEFwcCIsImdldEFwcHMiLCJBcnJheSIsImZyb20iLCJjbGVhbnVwUHJvdmlkZXJzIiwiZGVsZXRlIiwiZmlyZWJhc2VTZXJ2ZXJBcHAiLCJQcm9taXNlIiwiYWxsIiwibGlicmFyeUtleU9yTmFtZSIsInZhcmlhbnQiLCJfYSIsImxpYnJhcnlNaXNtYXRjaCIsIm1hdGNoIiwidmVyc2lvbk1pc21hdGNoIiwid2FybmluZyIsInB1c2giLCJ3YXJuIiwib25Mb2ciLCJsb2dDYWxsYmFjayIsImxvZ0xldmVsIiwiREJfTkFNRSIsIkRCX1ZFUlNJT04iLCJTVE9SRV9OQU1FIiwiZGJQcm9taXNlIiwiZ2V0RGJQcm9taXNlIiwidXBncmFkZSIsImRiIiwib2xkVmVyc2lvbiIsImNyZWF0ZU9iamVjdFN0b3JlIiwiY29uc29sZSIsImNhdGNoIiwib3JpZ2luYWxFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwicmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCIiwidHgiLCJ0cmFuc2FjdGlvbiIsInJlc3VsdCIsIm9iamVjdFN0b3JlIiwiY29tcHV0ZUtleSIsImRvbmUiLCJpZGJHZXRFcnJvciIsIndyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCIiwiaGVhcnRiZWF0T2JqZWN0IiwicHV0IiwiYXBwSWQiLCJNQVhfSEVBREVSX0JZVEVTIiwiU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyIsIkhlYXJ0YmVhdFNlcnZpY2VJbXBsIiwiX2hlYXJ0YmVhdHNDYWNoZSIsIl9zdG9yYWdlIiwiSGVhcnRiZWF0U3RvcmFnZUltcGwiLCJfaGVhcnRiZWF0c0NhY2hlUHJvbWlzZSIsInJlYWQiLCJ0aGVuIiwiX2IiLCJwbGF0Zm9ybUxvZ2dlciIsImFnZW50IiwiZGF0ZSIsImdldFVUQ0RhdGVTdHJpbmciLCJoZWFydGJlYXRzIiwibGFzdFNlbnRIZWFydGJlYXREYXRlIiwic29tZSIsInNpbmdsZURhdGVIZWFydGJlYXQiLCJoYlRpbWVzdGFtcCIsIkRhdGUiLCJ2YWx1ZU9mIiwibm93Iiwib3ZlcndyaXRlIiwiZ2V0SGVhcnRiZWF0c0hlYWRlciIsImxlbmd0aCIsImhlYXJ0YmVhdHNUb1NlbmQiLCJ1bnNlbnRFbnRyaWVzIiwiZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIiLCJoZWFkZXJTdHJpbmciLCJ0b2RheSIsInRvSVNPU3RyaW5nIiwic3Vic3RyaW5nIiwiaGVhcnRiZWF0c0NhY2hlIiwibWF4U2l6ZSIsInNsaWNlIiwiaGVhcnRiZWF0RW50cnkiLCJmaW5kIiwiaGIiLCJkYXRlcyIsImNvdW50Qnl0ZXMiLCJwb3AiLCJfY2FuVXNlSW5kZXhlZERCUHJvbWlzZSIsInJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2siLCJjYW5Vc2VJbmRleGVkREIiLCJpZGJIZWFydGJlYXRPYmplY3QiLCJoZWFydGJlYXRzT2JqZWN0IiwiZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0IiwiYWRkIiwicmVnaXN0ZXJDb3JlQ29tcG9uZW50cyIsIl9ERUZBVUxUX0VOVFJZX05BTUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(action-browser)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */ class Component {\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */ constructor(name, instanceFactory, type){\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\r\n         * Properties to be added to the service namespace\r\n         */ this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */ ;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */ class Provider {\n    constructor(name, container){\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */ get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                } catch (e) {\n                // when the instance factory throws an exception during get(), it should not cause\n                // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            } catch (e) {\n                if (optional) {\n                    return null;\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            } else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({\n                    instanceIdentifier: DEFAULT_ENTRY_NAME\n                });\n            } catch (e) {\n            // when the instance factory for an eager Component throws an exception during the eager\n            // initialization, it should not cause a fatal error.\n            // TODO: Investigate if we need to make it configurable, because some component may want to cause\n            // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            } catch (e) {\n            // when the instance factory throws an exception, it should not cause\n            // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services.filter((service)=>\"INTERNAL\" in service) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service.INTERNAL.delete()),\n            ...services.filter((service)=>\"_delete\" in service) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */ onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return ()=>{\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */ invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks){\n            try {\n                callback(instance, identifier);\n            } catch (_a) {\n            // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */ this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */ if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                } catch (_a) {\n                // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        } else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return !!this.component && this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */ ;\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */ ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */ class ComponentContainer {\n    constructor(name){\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */ addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */ getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwQztBQUUxQzs7Q0FFQyxHQUNELE1BQU1DO0lBQ0Y7Ozs7O0tBS0MsR0FDREMsWUFBWUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLElBQUksQ0FBRTtRQUNyQyxJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLGVBQWUsR0FBR0E7UUFDdkIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6Qjs7U0FFQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLENBQUM7UUFDckIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxPQUFPLDBCQUEwQjtRQUMxRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0FDLHFCQUFxQkMsSUFBSSxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0gsaUJBQWlCLEdBQUdHO1FBQ3pCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLHFCQUFxQk4saUJBQWlCLEVBQUU7UUFDcEMsSUFBSSxDQUFDQSxpQkFBaUIsR0FBR0E7UUFDekIsT0FBTyxJQUFJO0lBQ2Y7SUFDQU8sZ0JBQWdCQyxLQUFLLEVBQUU7UUFDbkIsSUFBSSxDQUFDUCxZQUFZLEdBQUdPO1FBQ3BCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLDJCQUEyQkMsUUFBUSxFQUFFO1FBQ2pDLElBQUksQ0FBQ1AsaUJBQWlCLEdBQUdPO1FBQ3pCLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNQyxxQkFBcUI7QUFFM0I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0Q7OztDQUdDLEdBQ0QsTUFBTUM7SUFDRmhCLFlBQVlDLElBQUksRUFBRWdCLFNBQVMsQ0FBRTtRQUN6QixJQUFJLENBQUNoQixJQUFJLEdBQUdBO1FBQ1os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QU04RTtRQUN6QixPQUFPQTtJQUNYO0lBQ0FHLGVBQWU7UUFDWCxPQUFPOUIsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ3dCLFNBQVMsQ0FBQ3ZCLE1BQU07SUFDM0M7QUFDSjtBQUVtRCxDQUNuRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaGVraGFyLWVudGVycHJpc2VzLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9jb21wb25lbnQvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz8yNDNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlZmVycmVkIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcclxuICogQ29tcG9uZW50IGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50IHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBwdWJsaWMgc2VydmljZSBuYW1lLCBlLmcuIGFwcCwgYXV0aCwgZmlyZXN0b3JlLCBkYXRhYmFzZVxyXG4gICAgICogQHBhcmFtIGluc3RhbmNlRmFjdG9yeSBTZXJ2aWNlIGZhY3RvcnkgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBwdWJsaWMgaW50ZXJmYWNlXHJcbiAgICAgKiBAcGFyYW0gdHlwZSB3aGV0aGVyIHRoZSBzZXJ2aWNlIHByb3ZpZGVkIGJ5IHRoZSBjb21wb25lbnQgaXMgcHVibGljIG9yIHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgaW5zdGFuY2VGYWN0b3J5LCB0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlRmFjdG9yeSA9IGluc3RhbmNlRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIHRoZSBzZXJ2aWNlIG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0ge307XHJcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IFwiTEFaWVwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkxBWlkgKi87XHJcbiAgICAgICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXRJbnN0YW50aWF0aW9uTW9kZShtb2RlKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IG1vZGU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRNdWx0aXBsZUluc3RhbmNlcyhtdWx0aXBsZUluc3RhbmNlcykge1xyXG4gICAgICAgIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgPSBtdWx0aXBsZUluc3RhbmNlcztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldFNlcnZpY2VQcm9wcyhwcm9wcykge1xyXG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBjYWxsYmFjaztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBpbnN0YW5jZSBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gJ2F1dGgnLCAnYXV0aC1pbnRlcm5hbCdcclxuICogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIGlzIGFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2VcclxuICovXHJcbmNsYXNzIFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBIHByb3ZpZGVyIGNhbiBwcm92aWRlIG11bGl0cGxlIGluc3RhbmNlcyBvZiBhIHNlcnZpY2VcclxuICAgICAqIGlmIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldChpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGVJbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZCwgdXNlIHRoZSBkZWZhdWx0IG5hbWVcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5oYXMobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBkZWZlcnJlZCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNlcnZpY2UgaWYgaXQgY2FuIGJlIGF1dG8taW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyBnZXQoKSwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgcmV0dXJuIHRoZSB1bnJlc29sdmVkIHByb21pc2UgaW4gdGhpcyBjYXNlLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmdldChub3JtYWxpemVkSWRlbnRpZmllcikucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWRlbnRpZmllcik7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3B0aW9uYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSW4gY2FzZSBhIGNvbXBvbmVudCBpcyBub3QgaW5pdGlhbGl6ZWQgYW5kIHNob3VsZC9jYW4gbm90IGJlIGF1dG8taW5pdGlhbGl6ZWQgYXQgdGhlIG1vbWVudCwgcmV0dXJuIG51bGwgaWYgdGhlIG9wdGlvbmFsIGZsYWcgaXMgc2V0LCBvciB0aHJvd1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFNlcnZpY2UgJHt0aGlzLm5hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENvbXBvbmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgICBzZXRDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC5uYW1lICE9PSB0aGlzLm5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1pc21hdGNoaW5nIENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmb3IgUHJvdmlkZXIgJHt0aGlzLm5hbWV9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCBmb3IgJHt0aGlzLm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcHJvdmlkZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IHdpdGhvdXQgYXR0ZW1wdGluZyB0byBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgaWYgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBleHBsaWNpdCBpbml0aWFsaXphdGlvbiAoY2FsbGluZyBgUHJvdmlkZXIuaW5pdGlhbGl6ZSgpYClcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBzZXJ2aWNlIGlzIGVhZ2VyLCBpbml0aWFsaXplIHRoZSBkZWZhdWx0IGluc3RhbmNlXHJcbiAgICAgICAgaWYgKGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyOiBERUZBVUxUX0VOVFJZX05BTUUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgZm9yIGFuIGVhZ2VyIENvbXBvbmVudCB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyB0aGUgZWFnZXJcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemF0aW9uLCBpdCBzaG91bGQgbm90IGNhdXNlIGEgZmF0YWwgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB3ZSBuZWVkIHRvIG1ha2UgaXQgY29uZmlndXJhYmxlLCBiZWNhdXNlIHNvbWUgY29tcG9uZW50IG1heSB3YW50IHRvIGNhdXNlXHJcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yIGluIHRoaXMgY2FzZT9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgc2VydmljZSBpbnN0YW5jZXMgZm9yIHRoZSBwZW5kaW5nIHByb21pc2VzIGFuZCByZXNvbHZlIHRoZW1cclxuICAgICAgICAvLyBOT1RFOiBpZiB0aGlzLm11bHRpcGxlSW5zdGFuY2VzIGlzIGZhbHNlLCBvbmx5IHRoZSBkZWZhdWx0IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxyXG4gICAgICAgIC8vIGFuZCBhbGwgcHJvbWlzZXMgd2l0aCByZXNvbHZlIHdpdGggaXQgcmVnYXJkbGVzcyBvZiB0aGUgaWRlbnRpZmllci5cclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIGBnZXRPckluaXRpYWxpemVTZXJ2aWNlKClgIHNob3VsZCBhbHdheXMgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2Ugc2luY2UgYSBjb21wb25lbnQgaXMgZ3VhcmFudGVlZC4gdXNlICEgdG8gbWFrZSB0eXBlc2NyaXB0IGhhcHB5LlxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uLCBpdCBzaG91bGQgbm90IGNhdXNlXHJcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IGxlYXZlIHRoZSBwcm9taXNlIHVucmVzb2x2ZWQuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbGVhckluc3RhbmNlKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuZGVsZXRlKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIC8vIGFwcC5kZWxldGUoKSB3aWxsIGNhbGwgdGhpcyBtZXRob2Qgb24gZXZlcnkgcHJvdmlkZXIgdG8gZGVsZXRlIHRoZSBzZXJ2aWNlc1xyXG4gICAgLy8gVE9ETzogc2hvdWxkIHdlIG1hcmsgdGhlIHByb3ZpZGVyIGFzIGRlbGV0ZWQ/XHJcbiAgICBhc3luYyBkZWxldGUoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFuY2VzLnZhbHVlcygpKTtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ0lOVEVSTkFMJyBpbiBzZXJ2aWNlKSAvLyBsZWdhY3kgc2VydmljZXNcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAubWFwKHNlcnZpY2UgPT4gc2VydmljZS5JTlRFUk5BTC5kZWxldGUoKSksXHJcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ19kZWxldGUnIGluIHNlcnZpY2UpIC8vIG1vZHVsYXJpemVkIHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuX2RlbGV0ZSgpKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgaXNDb21wb25lbnRTZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50ICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpc0luaXRpYWxpemVkKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXMuaGFzKGlkZW50aWZpZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3B0aW9ucyhpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5nZXQoaWRlbnRpZmllcikgfHwge307XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKG9wdHMgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyA9IHt9IH0gPSBvcHRzO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0cy5pbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGAke3RoaXMubmFtZX0oJHtub3JtYWxpemVkSWRlbnRpZmllcn0pIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCAke3RoaXMubmFtZX0gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgeWV0YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllcixcclxuICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHJlc29sdmUgYW55IHBlbmRpbmcgcHJvbWlzZSB3YWl0aW5nIGZvciB0aGUgc2VydmljZSBpbnN0YW5jZVxyXG4gICAgICAgIGZvciAoY29uc3QgW2luc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2VEZWZlcnJlZF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkSWRlbnRpZmllciA9PT0gbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkICBhZnRlciB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYnkgY2FsbGluZyBwcm92aWRlci5pbml0aWFsaXplKCkuXHJcbiAgICAgKiBUaGUgZnVuY3Rpb24gaXMgaW52b2tlZCBTWU5DSFJPTk9VU0xZLCBzbyBpdCBzaG91bGQgbm90IGV4ZWN1dGUgYW55IGxvbmdydW5uaW5nIHRhc2tzIGluIG9yZGVyIHRvIG5vdCBibG9jayB0aGUgcHJvZ3JhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBbiBvcHRpb25hbCBpbnN0YW5jZSBpZGVudGlmaWVyXHJcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVucmVnaXN0ZXIgdGhlIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIG9uSW5pdChjYWxsYmFjaywgaWRlbnRpZmllcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FsbGJhY2tzID0gKF9hID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFNldCgpO1xyXG4gICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XHJcbiAgICAgICAgdGhpcy5vbkluaXRDYWxsYmFja3Muc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBleGlzdGluZ0NhbGxiYWNrcyk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChub3JtYWxpemVkSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXhpc3RpbmdJbnN0YW5jZSwgbm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZSBvbkluaXQgY2FsbGJhY2tzIHN5bmNocm9ub3VzbHlcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZSB0aGUgc2VydmljZSBpbnN0YW5jZWBcclxuICAgICAqL1xyXG4gICAgaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluc3RhbmNlLCBpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5pdCBjYWxsYmFja1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyA9IHt9IH0pIHtcclxuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQoaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWluc3RhbmNlICYmIHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gdGhpcy5jb21wb25lbnQuaW5zdGFuY2VGYWN0b3J5KHRoaXMuY29udGFpbmVyLCB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGluc3RhbmNlSWRlbnRpZmllciksXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludm9rZSBvbkluaXQgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkIGlzIGRpZmZlcmVudCwgd2hpY2ggaXMgdXNlZCBieSB0aGUgY29tcG9uZW50IGNyZWF0b3IsXHJcbiAgICAgICAgICAgICAqIHdoaWxlIG9uSW5pdCBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgYnkgY29uc3VtZXJzIG9mIHRoZSBwcm92aWRlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT3JkZXIgaXMgaW1wb3J0YW50XHJcbiAgICAgICAgICAgICAqIG9uSW5zdGFuY2VDcmVhdGVkKCkgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7IHdoaWNoXHJcbiAgICAgICAgICAgICAqIG1ha2VzIGBpc0luaXRpYWxpemVkKClgIHJldHVybiB0cnVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKHRoaXMuY29udGFpbmVyLCBpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5zdGFuY2UgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIG5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyA/IGlkZW50aWZpZXIgOiBERUZBVUxUX0VOVFJZX05BTUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjsgLy8gYXNzdW1lIG11bHRpcGxlIGluc3RhbmNlcyBhcmUgc3VwcG9ydGVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNob3VsZEF1dG9Jbml0aWFsaXplKCkge1xyXG4gICAgICAgIHJldHVybiAoISF0aGlzLmNvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSAhPT0gXCJFWFBMSUNJVFwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVYUExJQ0lUICovKTtcclxuICAgIH1cclxufVxyXG4vLyB1bmRlZmluZWQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgc2VydmljZSBmYWN0b3J5IGZvciB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG5mdW5jdGlvbiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpZGVudGlmaWVyKSB7XHJcbiAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gREVGQVVMVF9FTlRSWV9OQU1FID8gdW5kZWZpbmVkIDogaWRlbnRpZmllcjtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSA9PT0gXCJFQUdFUlwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVBR0VSICovO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb21wb25lbnRDb250YWluZXIgdGhhdCBwcm92aWRlcyBQcm92aWRlcnMgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXHJcbiAqL1xyXG5jbGFzcyBDb21wb25lbnRDb250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBiZWluZyBhZGRlZFxyXG4gICAgICogQHBhcmFtIG92ZXJ3cml0ZSBXaGVuIGEgY29tcG9uZW50IHdpdGggdGhlIHNhbWUgbmFtZSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQsXHJcbiAgICAgKiBpZiBvdmVyd3JpdGUgaXMgdHJ1ZTogb3ZlcndyaXRlIHRoZSBleGlzdGluZyBjb21wb25lbnQgd2l0aCB0aGUgbmV3IGNvbXBvbmVudCBhbmQgY3JlYXRlIGEgbmV3XHJcbiAgICAgKiBwcm92aWRlciB3aXRoIHRoZSBuZXcgY29tcG9uZW50LiBJdCBjYW4gYmUgdXNlZnVsIGluIHRlc3RzIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgbW9ja3NcclxuICAgICAqIGZvciBkaWZmZXJlbnQgdGVzdHMuXHJcbiAgICAgKiBpZiBvdmVyd3JpdGUgaXMgZmFsc2U6IHRocm93IGFuIGV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBhZGRDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgd2l0aCAke3RoaXMubmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdmlkZXIuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBhZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xyXG4gICAgICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgZXhpc3RpbmcgcHJvdmlkZXIgZnJvbSB0aGUgY29udGFpbmVyLCBzbyB3ZSBjYW4gcmVnaXN0ZXIgdGhlIG5ldyBjb21wb25lbnRcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuZGVsZXRlKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZ2V0UHJvdmlkZXIgcHJvdmlkZXMgYSB0eXBlIHNhZmUgaW50ZXJmYWNlIHdoZXJlIGl0IGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgZmllbGQgbmFtZVxyXG4gICAgICogcHJlc2VudCBpbiBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEZpcmViYXNlIFNES3MgcHJvdmlkaW5nIHNlcnZpY2VzIHNob3VsZCBleHRlbmQgTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZSB0byByZWdpc3RlclxyXG4gICAgICogdGhlbXNlbHZlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJvdmlkZXIobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVycy5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJzLmdldChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3JlYXRlIGEgUHJvdmlkZXIgZm9yIGEgc2VydmljZSB0aGF0IGhhc24ndCByZWdpc3RlcmVkIHdpdGggRmlyZWJhc2VcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBQcm92aWRlcihuYW1lLCB0aGlzKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmFtZSwgcHJvdmlkZXIpO1xyXG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcclxuICAgIH1cclxuICAgIGdldFByb3ZpZGVycygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIsIFByb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRlZmVycmVkIiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaW5zdGFuY2VGYWN0b3J5IiwidHlwZSIsIm11bHRpcGxlSW5zdGFuY2VzIiwic2VydmljZVByb3BzIiwiaW5zdGFudGlhdGlvbk1vZGUiLCJvbkluc3RhbmNlQ3JlYXRlZCIsInNldEluc3RhbnRpYXRpb25Nb2RlIiwibW9kZSIsInNldE11bHRpcGxlSW5zdGFuY2VzIiwic2V0U2VydmljZVByb3BzIiwicHJvcHMiLCJzZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayIsImNhbGxiYWNrIiwiREVGQVVMVF9FTlRSWV9OQU1FIiwiUHJvdmlkZXIiLCJjb250YWluZXIiLCJjb21wb25lbnQiLCJpbnN0YW5jZXMiLCJNYXAiLCJpbnN0YW5jZXNEZWZlcnJlZCIsImluc3RhbmNlc09wdGlvbnMiLCJvbkluaXRDYWxsYmFja3MiLCJnZXQiLCJpZGVudGlmaWVyIiwibm9ybWFsaXplZElkZW50aWZpZXIiLCJub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIiLCJoYXMiLCJkZWZlcnJlZCIsInNldCIsImlzSW5pdGlhbGl6ZWQiLCJzaG91bGRBdXRvSW5pdGlhbGl6ZSIsImluc3RhbmNlIiwiZ2V0T3JJbml0aWFsaXplU2VydmljZSIsImluc3RhbmNlSWRlbnRpZmllciIsInJlc29sdmUiLCJlIiwicHJvbWlzZSIsImdldEltbWVkaWF0ZSIsIm9wdGlvbnMiLCJfYSIsIm9wdGlvbmFsIiwiRXJyb3IiLCJnZXRDb21wb25lbnQiLCJzZXRDb21wb25lbnQiLCJpc0NvbXBvbmVudEVhZ2VyIiwiaW5zdGFuY2VEZWZlcnJlZCIsImVudHJpZXMiLCJjbGVhckluc3RhbmNlIiwiZGVsZXRlIiwic2VydmljZXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJQcm9taXNlIiwiYWxsIiwiZmlsdGVyIiwic2VydmljZSIsIm1hcCIsIklOVEVSTkFMIiwiX2RlbGV0ZSIsImlzQ29tcG9uZW50U2V0IiwiZ2V0T3B0aW9ucyIsImluaXRpYWxpemUiLCJvcHRzIiwibm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciIsIm9uSW5pdCIsImV4aXN0aW5nQ2FsbGJhY2tzIiwiU2V0IiwiYWRkIiwiZXhpc3RpbmdJbnN0YW5jZSIsImludm9rZU9uSW5pdENhbGxiYWNrcyIsImNhbGxiYWNrcyIsIm5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5IiwidW5kZWZpbmVkIiwiQ29tcG9uZW50Q29udGFpbmVyIiwicHJvdmlkZXJzIiwiYWRkQ29tcG9uZW50IiwicHJvdmlkZXIiLCJnZXRQcm92aWRlciIsImFkZE9yT3ZlcndyaXRlQ29tcG9uZW50IiwiZ2V0UHJvdmlkZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A container for all of the Logger instances\r\n */ const instances = [];\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    \"debug\": LogLevel.DEBUG,\n    \"verbose\": LogLevel.VERBOSE,\n    \"info\": LogLevel.INFO,\n    \"warn\": LogLevel.WARN,\n    \"error\": LogLevel.ERROR,\n    \"silent\": LogLevel.SILENT\n};\n/**\r\n * The default log level\r\n */ const defaultLogLevel = LogLevel.INFO;\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */ const ConsoleMethod = {\n    [LogLevel.DEBUG]: \"log\",\n    [LogLevel.VERBOSE]: \"log\",\n    [LogLevel.INFO]: \"info\",\n    [LogLevel.WARN]: \"warn\",\n    [LogLevel.ERROR]: \"error\"\n};\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */ const defaultLogHandler = (instance, logType, ...args)=>{\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    } else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */ constructor(name){\n        this.name = name;\n        /**\r\n         * The log level of the given Logger instance.\r\n         */ this._logLevel = defaultLogLevel;\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */ this._logHandler = defaultLogHandler;\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */ this._userLogHandler = null;\n        /**\r\n         * Capture the current instance for later use\r\n         */ instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === \"string\" ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== \"function\") {\n            throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */ debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach((inst)=>{\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances){\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        } else {\n            instance.userLogHandler = (instance, level, ...args)=>{\n                const message = args.map((arg)=>{\n                    if (arg == null) {\n                        return null;\n                    } else if (typeof arg === \"string\") {\n                        return arg;\n                    } else if (typeof arg === \"number\" || typeof arg === \"boolean\") {\n                        return arg.toString();\n                    } else if (arg instanceof Error) {\n                        return arg.message;\n                    } else {\n                        try {\n                            return JSON.stringify(arg);\n                        } catch (ignored) {\n                            return null;\n                        }\n                    }\n                }).filter((arg)=>arg).join(\" \");\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbG9nZ2VyL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOztDQUVDLEdBQ0QsTUFBTUEsWUFBWSxFQUFFO0FBQ3BCOzs7Ozs7Ozs7O0NBVUMsR0FDRCxJQUFJQztBQUNILFVBQVVBLFFBQVE7SUFDZkEsUUFBUSxDQUFDQSxRQUFRLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNwQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNqQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNqQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUN2QyxHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDNUIsTUFBTUMsb0JBQW9CO0lBQ3RCLFNBQVNELFNBQVNFLEtBQUs7SUFDdkIsV0FBV0YsU0FBU0csT0FBTztJQUMzQixRQUFRSCxTQUFTSSxJQUFJO0lBQ3JCLFFBQVFKLFNBQVNLLElBQUk7SUFDckIsU0FBU0wsU0FBU00sS0FBSztJQUN2QixVQUFVTixTQUFTTyxNQUFNO0FBQzdCO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyxrQkFBa0JSLFNBQVNJLElBQUk7QUFDckM7Ozs7O0NBS0MsR0FDRCxNQUFNSyxnQkFBZ0I7SUFDbEIsQ0FBQ1QsU0FBU0UsS0FBSyxDQUFDLEVBQUU7SUFDbEIsQ0FBQ0YsU0FBU0csT0FBTyxDQUFDLEVBQUU7SUFDcEIsQ0FBQ0gsU0FBU0ksSUFBSSxDQUFDLEVBQUU7SUFDakIsQ0FBQ0osU0FBU0ssSUFBSSxDQUFDLEVBQUU7SUFDakIsQ0FBQ0wsU0FBU00sS0FBSyxDQUFDLEVBQUU7QUFDdEI7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTUksb0JBQW9CLENBQUNDLFVBQVVDLFNBQVMsR0FBR0M7SUFDN0MsSUFBSUQsVUFBVUQsU0FBU0csUUFBUSxFQUFFO1FBQzdCO0lBQ0o7SUFDQSxNQUFNQyxNQUFNLElBQUlDLE9BQU9DLFdBQVc7SUFDbEMsTUFBTUMsU0FBU1QsYUFBYSxDQUFDRyxRQUFRO0lBQ3JDLElBQUlNLFFBQVE7UUFDUkMsT0FBTyxDQUFDRCxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUVILElBQUksR0FBRyxFQUFFSixTQUFTUyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUtQO0lBQ3RELE9BQ0s7UUFDRCxNQUFNLElBQUlRLE1BQU0sQ0FBQywyREFBMkQsRUFBRVQsUUFBUSxDQUFDLENBQUM7SUFDNUY7QUFDSjtBQUNBLE1BQU1VO0lBQ0Y7Ozs7O0tBS0MsR0FDREMsWUFBWUgsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1o7O1NBRUMsR0FDRCxJQUFJLENBQUNJLFNBQVMsR0FBR2hCO1FBQ2pCOzs7U0FHQyxHQUNELElBQUksQ0FBQ2lCLFdBQVcsR0FBR2Y7UUFDbkI7O1NBRUMsR0FDRCxJQUFJLENBQUNnQixlQUFlLEdBQUc7UUFDdkI7O1NBRUMsR0FDRDNCLFVBQVU0QixJQUFJLENBQUMsSUFBSTtJQUN2QjtJQUNBLElBQUliLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQ1UsU0FBUztJQUN6QjtJQUNBLElBQUlWLFNBQVNjLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBRUEsQ0FBQUEsT0FBTzVCLFFBQU8sR0FBSTtZQUNwQixNQUFNLElBQUk2QixVQUFVLENBQUMsZUFBZSxFQUFFRCxJQUFJLDBCQUEwQixDQUFDO1FBQ3pFO1FBQ0EsSUFBSSxDQUFDSixTQUFTLEdBQUdJO0lBQ3JCO0lBQ0EsMkRBQTJEO0lBQzNERSxZQUFZRixHQUFHLEVBQUU7UUFDYixJQUFJLENBQUNKLFNBQVMsR0FBRyxPQUFPSSxRQUFRLFdBQVczQixpQkFBaUIsQ0FBQzJCLElBQUksR0FBR0E7SUFDeEU7SUFDQSxJQUFJRyxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNOLFdBQVc7SUFDM0I7SUFDQSxJQUFJTSxXQUFXSCxHQUFHLEVBQUU7UUFDaEIsSUFBSSxPQUFPQSxRQUFRLFlBQVk7WUFDM0IsTUFBTSxJQUFJQyxVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDSixXQUFXLEdBQUdHO0lBQ3ZCO0lBQ0EsSUFBSUksaUJBQWlCO1FBQ2pCLE9BQU8sSUFBSSxDQUFDTixlQUFlO0lBQy9CO0lBQ0EsSUFBSU0sZUFBZUosR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0YsZUFBZSxHQUFHRTtJQUMzQjtJQUNBOztLQUVDLEdBQ0RLLE1BQU0sR0FBR3BCLElBQUksRUFBRTtRQUNYLElBQUksQ0FBQ2EsZUFBZSxJQUFJLElBQUksQ0FBQ0EsZUFBZSxDQUFDLElBQUksRUFBRTFCLFNBQVNFLEtBQUssS0FBS1c7UUFDdEUsSUFBSSxDQUFDWSxXQUFXLENBQUMsSUFBSSxFQUFFekIsU0FBU0UsS0FBSyxLQUFLVztJQUM5QztJQUNBcUIsSUFBSSxHQUFHckIsSUFBSSxFQUFFO1FBQ1QsSUFBSSxDQUFDYSxlQUFlLElBQ2hCLElBQUksQ0FBQ0EsZUFBZSxDQUFDLElBQUksRUFBRTFCLFNBQVNHLE9BQU8sS0FBS1U7UUFDcEQsSUFBSSxDQUFDWSxXQUFXLENBQUMsSUFBSSxFQUFFekIsU0FBU0csT0FBTyxLQUFLVTtJQUNoRDtJQUNBc0IsS0FBSyxHQUFHdEIsSUFBSSxFQUFFO1FBQ1YsSUFBSSxDQUFDYSxlQUFlLElBQUksSUFBSSxDQUFDQSxlQUFlLENBQUMsSUFBSSxFQUFFMUIsU0FBU0ksSUFBSSxLQUFLUztRQUNyRSxJQUFJLENBQUNZLFdBQVcsQ0FBQyxJQUFJLEVBQUV6QixTQUFTSSxJQUFJLEtBQUtTO0lBQzdDO0lBQ0F1QixLQUFLLEdBQUd2QixJQUFJLEVBQUU7UUFDVixJQUFJLENBQUNhLGVBQWUsSUFBSSxJQUFJLENBQUNBLGVBQWUsQ0FBQyxJQUFJLEVBQUUxQixTQUFTSyxJQUFJLEtBQUtRO1FBQ3JFLElBQUksQ0FBQ1ksV0FBVyxDQUFDLElBQUksRUFBRXpCLFNBQVNLLElBQUksS0FBS1E7SUFDN0M7SUFDQXdCLE1BQU0sR0FBR3hCLElBQUksRUFBRTtRQUNYLElBQUksQ0FBQ2EsZUFBZSxJQUFJLElBQUksQ0FBQ0EsZUFBZSxDQUFDLElBQUksRUFBRTFCLFNBQVNNLEtBQUssS0FBS087UUFDdEUsSUFBSSxDQUFDWSxXQUFXLENBQUMsSUFBSSxFQUFFekIsU0FBU00sS0FBSyxLQUFLTztJQUM5QztBQUNKO0FBQ0EsU0FBU2lCLFlBQVlRLEtBQUs7SUFDdEJ2QyxVQUFVd0MsT0FBTyxDQUFDQyxDQUFBQTtRQUNkQSxLQUFLVixXQUFXLENBQUNRO0lBQ3JCO0FBQ0o7QUFDQSxTQUFTRyxrQkFBa0JDLFdBQVcsRUFBRUMsT0FBTztJQUMzQyxLQUFLLE1BQU1oQyxZQUFZWixVQUFXO1FBQzlCLElBQUk2QyxpQkFBaUI7UUFDckIsSUFBSUQsV0FBV0EsUUFBUUwsS0FBSyxFQUFFO1lBQzFCTSxpQkFBaUIzQyxpQkFBaUIsQ0FBQzBDLFFBQVFMLEtBQUssQ0FBQztRQUNyRDtRQUNBLElBQUlJLGdCQUFnQixNQUFNO1lBQ3RCL0IsU0FBU3FCLGNBQWMsR0FBRztRQUM5QixPQUNLO1lBQ0RyQixTQUFTcUIsY0FBYyxHQUFHLENBQUNyQixVQUFVMkIsT0FBTyxHQUFHekI7Z0JBQzNDLE1BQU1nQyxVQUFVaEMsS0FDWGlDLEdBQUcsQ0FBQ0MsQ0FBQUE7b0JBQ0wsSUFBSUEsT0FBTyxNQUFNO3dCQUNiLE9BQU87b0JBQ1gsT0FDSyxJQUFJLE9BQU9BLFFBQVEsVUFBVTt3QkFDOUIsT0FBT0E7b0JBQ1gsT0FDSyxJQUFJLE9BQU9BLFFBQVEsWUFBWSxPQUFPQSxRQUFRLFdBQVc7d0JBQzFELE9BQU9BLElBQUlDLFFBQVE7b0JBQ3ZCLE9BQ0ssSUFBSUQsZUFBZTFCLE9BQU87d0JBQzNCLE9BQU8wQixJQUFJRixPQUFPO29CQUN0QixPQUNLO3dCQUNELElBQUk7NEJBQ0EsT0FBT0ksS0FBS0MsU0FBUyxDQUFDSDt3QkFDMUIsRUFDQSxPQUFPSSxTQUFTOzRCQUNaLE9BQU87d0JBQ1g7b0JBQ0o7Z0JBQ0osR0FDS0MsTUFBTSxDQUFDTCxDQUFBQSxNQUFPQSxLQUNkTSxJQUFJLENBQUM7Z0JBQ1YsSUFBSWYsU0FBVU0sQ0FBQUEsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUlBLGlCQUFpQmpDLFNBQVNHLFFBQVEsR0FBRztvQkFDdEc0QixZQUFZO3dCQUNSSixPQUFPdEMsUUFBUSxDQUFDc0MsTUFBTSxDQUFDZ0IsV0FBVzt3QkFDbENUO3dCQUNBaEM7d0JBQ0EwQyxNQUFNNUMsU0FBU1MsSUFBSTtvQkFDdkI7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7QUFDSjtBQUU0RCxDQUM1RCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaGVraGFyLWVudGVycHJpc2VzLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz8zOThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXHJcbiAqL1xyXG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcclxuLyoqXHJcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cclxuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxyXG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXHJcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW0gPSB7XHJcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcclxuICAgICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcclxuICAgICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcclxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcclxuICAgICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxyXG4gICAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xyXG4vKipcclxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxyXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcclxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxyXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcclxuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxyXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXHJcbiAgICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxyXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxyXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpID0+IHtcclxuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXHJcbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cclxuICAgIHNldExvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlckxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGxvZyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xyXG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XHJcbiAgICAgICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcclxuICAgICAgICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsZXZlbCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAoY3VzdG9tTG9nTGV2ZWwgIT09IG51bGwgJiYgY3VzdG9tTG9nTGV2ZWwgIT09IHZvaWQgMCA/IGN1c3RvbUxvZ0xldmVsIDogaW5zdGFuY2UubG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbImluc3RhbmNlcyIsIkxvZ0xldmVsIiwibGV2ZWxTdHJpbmdUb0VudW0iLCJERUJVRyIsIlZFUkJPU0UiLCJJTkZPIiwiV0FSTiIsIkVSUk9SIiwiU0lMRU5UIiwiZGVmYXVsdExvZ0xldmVsIiwiQ29uc29sZU1ldGhvZCIsImRlZmF1bHRMb2dIYW5kbGVyIiwiaW5zdGFuY2UiLCJsb2dUeXBlIiwiYXJncyIsImxvZ0xldmVsIiwibm93IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibWV0aG9kIiwiY29uc29sZSIsIm5hbWUiLCJFcnJvciIsIkxvZ2dlciIsImNvbnN0cnVjdG9yIiwiX2xvZ0xldmVsIiwiX2xvZ0hhbmRsZXIiLCJfdXNlckxvZ0hhbmRsZXIiLCJwdXNoIiwidmFsIiwiVHlwZUVycm9yIiwic2V0TG9nTGV2ZWwiLCJsb2dIYW5kbGVyIiwidXNlckxvZ0hhbmRsZXIiLCJkZWJ1ZyIsImxvZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJsZXZlbCIsImZvckVhY2giLCJpbnN0Iiwic2V0VXNlckxvZ0hhbmRsZXIiLCJsb2dDYWxsYmFjayIsIm9wdGlvbnMiLCJjdXN0b21Mb2dMZXZlbCIsIm1lc3NhZ2UiLCJtYXAiLCJhcmciLCJ0b1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZ25vcmVkIiwiZmlsdGVyIiwiam9pbiIsInRvTG93ZXJDYXNlIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageErrorCode: () => (/* binding */ StorageErrorCode),\n/* harmony export */   StringFormat: () => (/* binding */ StringFormat),\n/* harmony export */   _FbsBlob: () => (/* binding */ FbsBlob),\n/* harmony export */   _Location: () => (/* binding */ Location),\n/* harmony export */   _TaskEvent: () => (/* binding */ TaskEvent),\n/* harmony export */   _TaskState: () => (/* binding */ TaskState),\n/* harmony export */   _UploadTask: () => (/* binding */ UploadTask),\n/* harmony export */   _dataFromString: () => (/* binding */ dataFromString),\n/* harmony export */   _getChild: () => (/* binding */ _getChild),\n/* harmony export */   _invalidArgument: () => (/* binding */ invalidArgument),\n/* harmony export */   _invalidRootOperation: () => (/* binding */ invalidRootOperation),\n/* harmony export */   connectStorageEmulator: () => (/* binding */ connectStorageEmulator),\n/* harmony export */   deleteObject: () => (/* binding */ deleteObject),\n/* harmony export */   getBlob: () => (/* binding */ getBlob),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),\n/* harmony export */   getMetadata: () => (/* binding */ getMetadata),\n/* harmony export */   getStorage: () => (/* binding */ getStorage),\n/* harmony export */   getStream: () => (/* binding */ getStream),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   listAll: () => (/* binding */ listAll),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   updateMetadata: () => (/* binding */ updateMetadata),\n/* harmony export */   uploadBytes: () => (/* binding */ uploadBytes),\n/* harmony export */   uploadBytesResumable: () => (/* binding */ uploadBytesResumable),\n/* harmony export */   uploadString: () => (/* binding */ uploadString)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(action-browser)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(action-browser)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! undici */ \"(action-browser)/./node_modules/undici/index.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/component */ \"(action-browser)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Constants used in the Firebase Storage library.\r\n */ /**\r\n * Domain name for firebase storage.\r\n */ const DEFAULT_HOST = \"firebasestorage.googleapis.com\";\n/**\r\n * The key in Firebase config json for the storage bucket.\r\n */ const CONFIG_STORAGE_BUCKET_KEY = \"storageBucket\";\n/**\r\n * 2 minutes\r\n *\r\n * The timeout for all operations except upload.\r\n */ const DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1000;\n/**\r\n * 10 minutes\r\n *\r\n * The timeout for upload.\r\n */ const DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1000;\n/**\r\n * 1 second\r\n */ const DEFAULT_MIN_SLEEP_TIME_MILLIS = 1000;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An error returned by the Firebase Storage SDK.\r\n * @public\r\n */ class StorageError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    /**\r\n     * @param code - A `StorageErrorCode` string to be prefixed with 'storage/' and\r\n     *  added to the end of the message.\r\n     * @param message  - Error message.\r\n     * @param status_ - Corresponding HTTP Status Code\r\n     */ constructor(code, message, status_ = 0){\n        super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);\n        this.status_ = status_;\n        /**\r\n         * Stores custom error data unique to the `StorageError`.\r\n         */ this.customData = {\n            serverResponse: null\n        };\n        this._baseMessage = this.message;\n        // Without this, `instanceof StorageError`, in tests for example,\n        // returns false.\n        Object.setPrototypeOf(this, StorageError.prototype);\n    }\n    get status() {\n        return this.status_;\n    }\n    set status(status) {\n        this.status_ = status;\n    }\n    /**\r\n     * Compares a `StorageErrorCode` against this error's code, filtering out the prefix.\r\n     */ _codeEquals(code) {\n        return prependCode(code) === this.code;\n    }\n    /**\r\n     * Optional response message that was added by the server.\r\n     */ get serverResponse() {\n        return this.customData.serverResponse;\n    }\n    set serverResponse(serverResponse) {\n        this.customData.serverResponse = serverResponse;\n        if (this.customData.serverResponse) {\n            this.message = `${this._baseMessage}\\n${this.customData.serverResponse}`;\n        } else {\n            this.message = this._baseMessage;\n        }\n    }\n}\n/**\r\n * @public\r\n * Error codes that can be attached to `StorageError` objects.\r\n */ var StorageErrorCode;\n(function(StorageErrorCode) {\n    // Shared between all platforms\n    StorageErrorCode[\"UNKNOWN\"] = \"unknown\";\n    StorageErrorCode[\"OBJECT_NOT_FOUND\"] = \"object-not-found\";\n    StorageErrorCode[\"BUCKET_NOT_FOUND\"] = \"bucket-not-found\";\n    StorageErrorCode[\"PROJECT_NOT_FOUND\"] = \"project-not-found\";\n    StorageErrorCode[\"QUOTA_EXCEEDED\"] = \"quota-exceeded\";\n    StorageErrorCode[\"UNAUTHENTICATED\"] = \"unauthenticated\";\n    StorageErrorCode[\"UNAUTHORIZED\"] = \"unauthorized\";\n    StorageErrorCode[\"UNAUTHORIZED_APP\"] = \"unauthorized-app\";\n    StorageErrorCode[\"RETRY_LIMIT_EXCEEDED\"] = \"retry-limit-exceeded\";\n    StorageErrorCode[\"INVALID_CHECKSUM\"] = \"invalid-checksum\";\n    StorageErrorCode[\"CANCELED\"] = \"canceled\";\n    // JS specific\n    StorageErrorCode[\"INVALID_EVENT_NAME\"] = \"invalid-event-name\";\n    StorageErrorCode[\"INVALID_URL\"] = \"invalid-url\";\n    StorageErrorCode[\"INVALID_DEFAULT_BUCKET\"] = \"invalid-default-bucket\";\n    StorageErrorCode[\"NO_DEFAULT_BUCKET\"] = \"no-default-bucket\";\n    StorageErrorCode[\"CANNOT_SLICE_BLOB\"] = \"cannot-slice-blob\";\n    StorageErrorCode[\"SERVER_FILE_WRONG_SIZE\"] = \"server-file-wrong-size\";\n    StorageErrorCode[\"NO_DOWNLOAD_URL\"] = \"no-download-url\";\n    StorageErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n    StorageErrorCode[\"INVALID_ARGUMENT_COUNT\"] = \"invalid-argument-count\";\n    StorageErrorCode[\"APP_DELETED\"] = \"app-deleted\";\n    StorageErrorCode[\"INVALID_ROOT_OPERATION\"] = \"invalid-root-operation\";\n    StorageErrorCode[\"INVALID_FORMAT\"] = \"invalid-format\";\n    StorageErrorCode[\"INTERNAL_ERROR\"] = \"internal-error\";\n    StorageErrorCode[\"UNSUPPORTED_ENVIRONMENT\"] = \"unsupported-environment\";\n})(StorageErrorCode || (StorageErrorCode = {}));\nfunction prependCode(code) {\n    return \"storage/\" + code;\n}\nfunction unknown() {\n    const message = \"An unknown error occurred, please check the error payload for \" + \"server response.\";\n    return new StorageError(StorageErrorCode.UNKNOWN, message);\n}\nfunction objectNotFound(path) {\n    return new StorageError(StorageErrorCode.OBJECT_NOT_FOUND, \"Object '\" + path + \"' does not exist.\");\n}\nfunction quotaExceeded(bucket) {\n    return new StorageError(StorageErrorCode.QUOTA_EXCEEDED, \"Quota for bucket '\" + bucket + \"' exceeded, please view quota on \" + \"https://firebase.google.com/pricing/.\");\n}\nfunction unauthenticated() {\n    const message = \"User is not authenticated, please authenticate using Firebase \" + \"Authentication and try again.\";\n    return new StorageError(StorageErrorCode.UNAUTHENTICATED, message);\n}\nfunction unauthorizedApp() {\n    return new StorageError(StorageErrorCode.UNAUTHORIZED_APP, \"This app does not have permission to access Firebase Storage on this project.\");\n}\nfunction unauthorized(path) {\n    return new StorageError(StorageErrorCode.UNAUTHORIZED, \"User does not have permission to access '\" + path + \"'.\");\n}\nfunction retryLimitExceeded() {\n    return new StorageError(StorageErrorCode.RETRY_LIMIT_EXCEEDED, \"Max retry time for operation exceeded, please try again.\");\n}\nfunction canceled() {\n    return new StorageError(StorageErrorCode.CANCELED, \"User canceled the upload/download.\");\n}\nfunction invalidUrl(url) {\n    return new StorageError(StorageErrorCode.INVALID_URL, \"Invalid URL '\" + url + \"'.\");\n}\nfunction invalidDefaultBucket(bucket) {\n    return new StorageError(StorageErrorCode.INVALID_DEFAULT_BUCKET, \"Invalid default bucket '\" + bucket + \"'.\");\n}\nfunction noDefaultBucket() {\n    return new StorageError(StorageErrorCode.NO_DEFAULT_BUCKET, \"No default bucket \" + \"found. Did you set the '\" + CONFIG_STORAGE_BUCKET_KEY + \"' property when initializing the app?\");\n}\nfunction cannotSliceBlob() {\n    return new StorageError(StorageErrorCode.CANNOT_SLICE_BLOB, \"Cannot slice blob for upload. Please retry the upload.\");\n}\nfunction serverFileWrongSize() {\n    return new StorageError(StorageErrorCode.SERVER_FILE_WRONG_SIZE, \"Server recorded incorrect upload file size, please retry the upload.\");\n}\nfunction noDownloadURL() {\n    return new StorageError(StorageErrorCode.NO_DOWNLOAD_URL, \"The given file does not have any download URLs.\");\n}\n/**\r\n * @internal\r\n */ function invalidArgument(message) {\n    return new StorageError(StorageErrorCode.INVALID_ARGUMENT, message);\n}\nfunction appDeleted() {\n    return new StorageError(StorageErrorCode.APP_DELETED, \"The Firebase app was deleted.\");\n}\n/**\r\n * @param name - The name of the operation that was invalid.\r\n *\r\n * @internal\r\n */ function invalidRootOperation(name) {\n    return new StorageError(StorageErrorCode.INVALID_ROOT_OPERATION, \"The operation '\" + name + \"' cannot be performed on a root reference, create a non-root \" + \"reference using child, such as .child('file.png').\");\n}\n/**\r\n * @param format - The format that was not valid.\r\n * @param message - A message describing the format violation.\r\n */ function invalidFormat(format, message) {\n    return new StorageError(StorageErrorCode.INVALID_FORMAT, \"String does not match format '\" + format + \"': \" + message);\n}\n/**\r\n * @param message - A message describing the internal error.\r\n */ function internalError(message) {\n    throw new StorageError(StorageErrorCode.INTERNAL_ERROR, \"Internal error: \" + message);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Firebase Storage location data.\r\n *\r\n * @internal\r\n */ class Location {\n    constructor(bucket, path){\n        this.bucket = bucket;\n        this.path_ = path;\n    }\n    get path() {\n        return this.path_;\n    }\n    get isRoot() {\n        return this.path.length === 0;\n    }\n    fullServerUrl() {\n        const encode = encodeURIComponent;\n        return \"/b/\" + encode(this.bucket) + \"/o/\" + encode(this.path);\n    }\n    bucketOnlyServerUrl() {\n        const encode = encodeURIComponent;\n        return \"/b/\" + encode(this.bucket) + \"/o\";\n    }\n    static makeFromBucketSpec(bucketString, host) {\n        let bucketLocation;\n        try {\n            bucketLocation = Location.makeFromUrl(bucketString, host);\n        } catch (e) {\n            // Not valid URL, use as-is. This lets you put bare bucket names in\n            // config.\n            return new Location(bucketString, \"\");\n        }\n        if (bucketLocation.path === \"\") {\n            return bucketLocation;\n        } else {\n            throw invalidDefaultBucket(bucketString);\n        }\n    }\n    static makeFromUrl(url, host) {\n        let location = null;\n        const bucketDomain = \"([A-Za-z0-9.\\\\-_]+)\";\n        function gsModify(loc) {\n            if (loc.path.charAt(loc.path.length - 1) === \"/\") {\n                loc.path_ = loc.path_.slice(0, -1);\n            }\n        }\n        const gsPath = \"(/(.*))?$\";\n        const gsRegex = new RegExp(\"^gs://\" + bucketDomain + gsPath, \"i\");\n        const gsIndices = {\n            bucket: 1,\n            path: 3\n        };\n        function httpModify(loc) {\n            loc.path_ = decodeURIComponent(loc.path);\n        }\n        const version = \"v[A-Za-z0-9_]+\";\n        const firebaseStorageHost = host.replace(/[.]/g, \"\\\\.\");\n        const firebaseStoragePath = \"(/([^?#]*).*)?$\";\n        const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version}/b/${bucketDomain}/o${firebaseStoragePath}`, \"i\");\n        const firebaseStorageIndices = {\n            bucket: 1,\n            path: 3\n        };\n        const cloudStorageHost = host === DEFAULT_HOST ? \"(?:storage.googleapis.com|storage.cloud.google.com)\" : host;\n        const cloudStoragePath = \"([^?#]*)\";\n        const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, \"i\");\n        const cloudStorageIndices = {\n            bucket: 1,\n            path: 2\n        };\n        const groups = [\n            {\n                regex: gsRegex,\n                indices: gsIndices,\n                postModify: gsModify\n            },\n            {\n                regex: firebaseStorageRegExp,\n                indices: firebaseStorageIndices,\n                postModify: httpModify\n            },\n            {\n                regex: cloudStorageRegExp,\n                indices: cloudStorageIndices,\n                postModify: httpModify\n            }\n        ];\n        for(let i = 0; i < groups.length; i++){\n            const group = groups[i];\n            const captures = group.regex.exec(url);\n            if (captures) {\n                const bucketValue = captures[group.indices.bucket];\n                let pathValue = captures[group.indices.path];\n                if (!pathValue) {\n                    pathValue = \"\";\n                }\n                location = new Location(bucketValue, pathValue);\n                group.postModify(location);\n                break;\n            }\n        }\n        if (location == null) {\n            throw invalidUrl(url);\n        }\n        return location;\n    }\n}\n/**\r\n * A request whose promise always fails.\r\n */ class FailRequest {\n    constructor(error){\n        this.promise_ = Promise.reject(error);\n    }\n    /** @inheritDoc */ getPromise() {\n        return this.promise_;\n    }\n    /** @inheritDoc */ cancel(_appDelete = false) {}\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Accepts a callback for an action to perform (`doRequest`),\r\n * and then a callback for when the backoff has completed (`backoffCompleteCb`).\r\n * The callback sent to start requires an argument to call (`onRequestComplete`).\r\n * When `start` calls `doRequest`, it passes a callback for when the request has\r\n * completed, `onRequestComplete`. Based on this, the backoff continues, with\r\n * another call to `doRequest` and the above loop continues until the timeout\r\n * is hit, or a successful response occurs.\r\n * @description\r\n * @param doRequest Callback to perform request\r\n * @param backoffCompleteCb Callback to call when backoff has been completed\r\n */ function start(doRequest, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nbackoffCompleteCb, timeout) {\n    // TODO(andysoto): make this code cleaner (probably refactor into an actual\n    // type instead of a bunch of functions with state shared in the closure)\n    let waitSeconds = 1;\n    // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n    // TODO: find a way to exclude Node type definition for storage because storage only works in browser\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let retryTimeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let globalTimeoutId = null;\n    let hitTimeout = false;\n    let cancelState = 0;\n    function canceled() {\n        return cancelState === 2;\n    }\n    let triggeredCallback = false;\n    function triggerCallback(...args) {\n        if (!triggeredCallback) {\n            triggeredCallback = true;\n            backoffCompleteCb.apply(null, args);\n        }\n    }\n    function callWithDelay(millis) {\n        retryTimeoutId = setTimeout(()=>{\n            retryTimeoutId = null;\n            doRequest(responseHandler, canceled());\n        }, millis);\n    }\n    function clearGlobalTimeout() {\n        if (globalTimeoutId) {\n            clearTimeout(globalTimeoutId);\n        }\n    }\n    function responseHandler(success, ...args) {\n        if (triggeredCallback) {\n            clearGlobalTimeout();\n            return;\n        }\n        if (success) {\n            clearGlobalTimeout();\n            triggerCallback.call(null, success, ...args);\n            return;\n        }\n        const mustStop = canceled() || hitTimeout;\n        if (mustStop) {\n            clearGlobalTimeout();\n            triggerCallback.call(null, success, ...args);\n            return;\n        }\n        if (waitSeconds < 64) {\n            /* TODO(andysoto): don't back off so quickly if we know we're offline. */ waitSeconds *= 2;\n        }\n        let waitMillis;\n        if (cancelState === 1) {\n            cancelState = 2;\n            waitMillis = 0;\n        } else {\n            waitMillis = (waitSeconds + Math.random()) * 1000;\n        }\n        callWithDelay(waitMillis);\n    }\n    let stopped = false;\n    function stop(wasTimeout) {\n        if (stopped) {\n            return;\n        }\n        stopped = true;\n        clearGlobalTimeout();\n        if (triggeredCallback) {\n            return;\n        }\n        if (retryTimeoutId !== null) {\n            if (!wasTimeout) {\n                cancelState = 2;\n            }\n            clearTimeout(retryTimeoutId);\n            callWithDelay(0);\n        } else {\n            if (!wasTimeout) {\n                cancelState = 1;\n            }\n        }\n    }\n    callWithDelay(0);\n    globalTimeoutId = setTimeout(()=>{\n        hitTimeout = true;\n        stop(true);\n    }, timeout);\n    return stop;\n}\n/**\r\n * Stops the retry loop from repeating.\r\n * If the function is currently \"in between\" retries, it is invoked immediately\r\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\r\n * after the current invocation finishes iff the current invocation would have\r\n * triggered another retry.\r\n */ function stop(id) {\n    id(false);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function isJustDef(p) {\n    return p !== void 0;\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isFunction(p) {\n    return typeof p === \"function\";\n}\nfunction isNonArrayObject(p) {\n    return typeof p === \"object\" && !Array.isArray(p);\n}\nfunction isString(p) {\n    return typeof p === \"string\" || p instanceof String;\n}\nfunction isNativeBlob(p) {\n    return isNativeBlobDefined() && p instanceof Blob;\n}\nfunction isNativeBlobDefined() {\n    return typeof Blob !== \"undefined\";\n}\nfunction validateNumber(argument, minValue, maxValue, value) {\n    if (value < minValue) {\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);\n    }\n    if (value > maxValue) {\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function makeUrl(urlPart, host, protocol) {\n    let origin = host;\n    if (protocol == null) {\n        origin = `https://${host}`;\n    }\n    return `${protocol}://${origin}/v0${urlPart}`;\n}\nfunction makeQueryString(params) {\n    const encode = encodeURIComponent;\n    let queryPart = \"?\";\n    for(const key in params){\n        if (params.hasOwnProperty(key)) {\n            const nextPart = encode(key) + \"=\" + encode(params[key]);\n            queryPart = queryPart + nextPart + \"&\";\n        }\n    }\n    // Chop off the extra '&' or '?' on the end\n    queryPart = queryPart.slice(0, -1);\n    return queryPart;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Error codes for requests made by the the XhrIo wrapper.\r\n */ var ErrorCode;\n(function(ErrorCode) {\n    ErrorCode[ErrorCode[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\n    ErrorCode[ErrorCode[\"NETWORK_ERROR\"] = 1] = \"NETWORK_ERROR\";\n    ErrorCode[ErrorCode[\"ABORT\"] = 2] = \"ABORT\";\n})(ErrorCode || (ErrorCode = {}));\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Checks the status code to see if the action should be retried.\r\n *\r\n * @param status Current HTTP status code returned by server.\r\n * @param additionalRetryCodes additional retry codes to check against\r\n */ function isRetryStatusCode(status, additionalRetryCodes) {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    const isFiveHundredCode = status >= 500 && status < 600;\n    const extraRetryCodes = [\n        // Request Timeout: web server didn't receive full request in time.\n        408,\n        // Too Many Requests: you're getting rate-limited, basically.\n        429\n    ];\n    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;\n    const isAdditionalRetryCode = additionalRetryCodes.indexOf(status) !== -1;\n    return isFiveHundredCode || isExtraRetryCode || isAdditionalRetryCode;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Handles network logic for all Storage Requests, including error reporting and\r\n * retries with backoff.\r\n *\r\n * @param I - the type of the backend's network response.\r\n * @param - O the output type used by the rest of the SDK. The conversion\r\n * happens in the specified `callback_`.\r\n */ class NetworkRequest {\n    constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_, retry = true){\n        this.url_ = url_;\n        this.method_ = method_;\n        this.headers_ = headers_;\n        this.body_ = body_;\n        this.successCodes_ = successCodes_;\n        this.additionalRetryCodes_ = additionalRetryCodes_;\n        this.callback_ = callback_;\n        this.errorCallback_ = errorCallback_;\n        this.timeout_ = timeout_;\n        this.progressCallback_ = progressCallback_;\n        this.connectionFactory_ = connectionFactory_;\n        this.retry = retry;\n        this.pendingConnection_ = null;\n        this.backoffId_ = null;\n        this.canceled_ = false;\n        this.appDelete_ = false;\n        this.promise_ = new Promise((resolve, reject)=>{\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n            this.start_();\n        });\n    }\n    /**\r\n     * Actually starts the retry loop.\r\n     */ start_() {\n        const doTheRequest = (backoffCallback, canceled)=>{\n            if (canceled) {\n                backoffCallback(false, new RequestEndStatus(false, null, true));\n                return;\n            }\n            const connection = this.connectionFactory_();\n            this.pendingConnection_ = connection;\n            const progressListener = (progressEvent)=>{\n                const loaded = progressEvent.loaded;\n                const total = progressEvent.lengthComputable ? progressEvent.total : -1;\n                if (this.progressCallback_ !== null) {\n                    this.progressCallback_(loaded, total);\n                }\n            };\n            if (this.progressCallback_ !== null) {\n                connection.addUploadProgressListener(progressListener);\n            }\n            // connection.send() never rejects, so we don't need to have a error handler or use catch on the returned promise.\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            connection.send(this.url_, this.method_, this.body_, this.headers_).then(()=>{\n                if (this.progressCallback_ !== null) {\n                    connection.removeUploadProgressListener(progressListener);\n                }\n                this.pendingConnection_ = null;\n                const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;\n                const status = connection.getStatus();\n                if (!hitServer || isRetryStatusCode(status, this.additionalRetryCodes_) && this.retry) {\n                    const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;\n                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n                    return;\n                }\n                const successCode = this.successCodes_.indexOf(status) !== -1;\n                backoffCallback(true, new RequestEndStatus(successCode, connection));\n            });\n        };\n        /**\r\n         * @param requestWentThrough - True if the request eventually went\r\n         *     through, false if it hit the retry limit or was canceled.\r\n         */ const backoffDone = (requestWentThrough, status)=>{\n            const resolve = this.resolve_;\n            const reject = this.reject_;\n            const connection = status.connection;\n            if (status.wasSuccessCode) {\n                try {\n                    const result = this.callback_(connection, connection.getResponse());\n                    if (isJustDef(result)) {\n                        resolve(result);\n                    } else {\n                        resolve();\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            } else {\n                if (connection !== null) {\n                    const err = unknown();\n                    err.serverResponse = connection.getErrorText();\n                    if (this.errorCallback_) {\n                        reject(this.errorCallback_(connection, err));\n                    } else {\n                        reject(err);\n                    }\n                } else {\n                    if (status.canceled) {\n                        const err = this.appDelete_ ? appDeleted() : canceled();\n                        reject(err);\n                    } else {\n                        const err = retryLimitExceeded();\n                        reject(err);\n                    }\n                }\n            }\n        };\n        if (this.canceled_) {\n            backoffDone(false, new RequestEndStatus(false, null, true));\n        } else {\n            this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);\n        }\n    }\n    /** @inheritDoc */ getPromise() {\n        return this.promise_;\n    }\n    /** @inheritDoc */ cancel(appDelete) {\n        this.canceled_ = true;\n        this.appDelete_ = appDelete || false;\n        if (this.backoffId_ !== null) {\n            stop(this.backoffId_);\n        }\n        if (this.pendingConnection_ !== null) {\n            this.pendingConnection_.abort();\n        }\n    }\n}\n/**\r\n * A collection of information about the result of a network request.\r\n * @param opt_canceled - Defaults to false.\r\n */ class RequestEndStatus {\n    constructor(wasSuccessCode, connection, canceled){\n        this.wasSuccessCode = wasSuccessCode;\n        this.connection = connection;\n        this.canceled = !!canceled;\n    }\n}\nfunction addAuthHeader_(headers, authToken) {\n    if (authToken !== null && authToken.length > 0) {\n        headers[\"Authorization\"] = \"Firebase \" + authToken;\n    }\n}\nfunction addVersionHeader_(headers, firebaseVersion) {\n    headers[\"X-Firebase-Storage-Version\"] = \"webjs/\" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : \"AppManager\");\n}\nfunction addGmpidHeader_(headers, appId) {\n    if (appId) {\n        headers[\"X-Firebase-GMPID\"] = appId;\n    }\n}\nfunction addAppCheckHeader_(headers, appCheckToken) {\n    if (appCheckToken !== null) {\n        headers[\"X-Firebase-AppCheck\"] = appCheckToken;\n    }\n}\nfunction makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion, retry = true) {\n    const queryPart = makeQueryString(requestInfo.urlParams);\n    const url = requestInfo.url + queryPart;\n    const headers = Object.assign({}, requestInfo.headers);\n    addGmpidHeader_(headers, appId);\n    addAuthHeader_(headers, authToken);\n    addVersionHeader_(headers, firebaseVersion);\n    addAppCheckHeader_(headers, appCheckToken);\n    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory, retry);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getBlobBuilder() {\n    if (typeof BlobBuilder !== \"undefined\") {\n        return BlobBuilder;\n    } else if (typeof WebKitBlobBuilder !== \"undefined\") {\n        return WebKitBlobBuilder;\n    } else {\n        return undefined;\n    }\n}\n/**\r\n * Concatenates one or more values together and converts them to a Blob.\r\n *\r\n * @param args The values that will make up the resulting blob.\r\n * @return The blob.\r\n */ function getBlob$1(...args) {\n    const BlobBuilder1 = getBlobBuilder();\n    if (BlobBuilder1 !== undefined) {\n        const bb = new BlobBuilder1();\n        for(let i = 0; i < args.length; i++){\n            bb.append(args[i]);\n        }\n        return bb.getBlob();\n    } else {\n        if (isNativeBlobDefined()) {\n            return new Blob(args);\n        } else {\n            throw new StorageError(StorageErrorCode.UNSUPPORTED_ENVIRONMENT, \"This browser doesn't seem to support creating Blobs\");\n        }\n    }\n}\n/**\r\n * Slices the blob. The returned blob contains data from the start byte\r\n * (inclusive) till the end byte (exclusive). Negative indices cannot be used.\r\n *\r\n * @param blob The blob to be sliced.\r\n * @param start Index of the starting byte.\r\n * @param end Index of the ending byte.\r\n * @return The blob slice or null if not supported.\r\n */ function sliceBlob(blob, start, end) {\n    if (blob.webkitSlice) {\n        return blob.webkitSlice(start, end);\n    } else if (blob.mozSlice) {\n        return blob.mozSlice(start, end);\n    } else if (blob.slice) {\n        return blob.slice(start, end);\n    }\n    return null;\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Converts a Base64 encoded string to a binary string. */ function decodeBase64(encoded) {\n    // Node actually doesn't validate base64 strings.\n    // A quick sanity check that is not a fool-proof validation\n    if (/[^-A-Za-z0-9+/=]/.test(encoded)) {\n        throw invalidFormat(\"base64\", \"Invalid character found\");\n    }\n    return Buffer.from(encoded, \"base64\").toString(\"binary\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An enumeration of the possible string formats for upload.\r\n * @public\r\n */ const StringFormat = {\n    /**\r\n     * Indicates the string should be interpreted \"raw\", that is, as normal text.\r\n     * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte\r\n     * sequence.\r\n     * Example: The string 'Hello! \\\\ud83d\\\\ude0a' becomes the byte sequence\r\n     * 48 65 6c 6c 6f 21 20 f0 9f 98 8a\r\n     */ RAW: \"raw\",\n    /**\r\n     * Indicates the string should be interpreted as base64-encoded data.\r\n     * Padding characters (trailing '='s) are optional.\r\n     * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence\r\n     * ad 69 8e fb e1 3a b7 bf eb 97\r\n     */ BASE64: \"base64\",\n    /**\r\n     * Indicates the string should be interpreted as base64url-encoded data.\r\n     * Padding characters (trailing '='s) are optional.\r\n     * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence\r\n     * ad 69 8e fb e1 3a b7 bf eb 97\r\n     */ BASE64URL: \"base64url\",\n    /**\r\n     * Indicates the string is a data URL, such as one obtained from\r\n     * canvas.toDataURL().\r\n     * Example: the string 'data:application/octet-stream;base64,aaaa'\r\n     * becomes the byte sequence\r\n     * 69 a6 9a\r\n     * (the content-type \"application/octet-stream\" is also applied, but can\r\n     * be overridden in the metadata object).\r\n     */ DATA_URL: \"data_url\"\n};\nclass StringData {\n    constructor(data, contentType){\n        this.data = data;\n        this.contentType = contentType || null;\n    }\n}\n/**\r\n * @internal\r\n */ function dataFromString(format, stringData) {\n    switch(format){\n        case StringFormat.RAW:\n            return new StringData(utf8Bytes_(stringData));\n        case StringFormat.BASE64:\n        case StringFormat.BASE64URL:\n            return new StringData(base64Bytes_(format, stringData));\n        case StringFormat.DATA_URL:\n            return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));\n    }\n    // assert(false);\n    throw unknown();\n}\nfunction utf8Bytes_(value) {\n    const b = [];\n    for(let i = 0; i < value.length; i++){\n        let c = value.charCodeAt(i);\n        if (c <= 127) {\n            b.push(c);\n        } else {\n            if (c <= 2047) {\n                b.push(192 | c >> 6, 128 | c & 63);\n            } else {\n                if ((c & 64512) === 55296) {\n                    // The start of a surrogate pair.\n                    const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;\n                    if (!valid) {\n                        // The second surrogate wasn't there.\n                        b.push(239, 191, 189);\n                    } else {\n                        const hi = c;\n                        const lo = value.charCodeAt(++i);\n                        c = 65536 | (hi & 1023) << 10 | lo & 1023;\n                        b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);\n                    }\n                } else {\n                    if ((c & 64512) === 56320) {\n                        // Invalid low surrogate.\n                        b.push(239, 191, 189);\n                    } else {\n                        b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);\n                    }\n                }\n            }\n        }\n    }\n    return new Uint8Array(b);\n}\nfunction percentEncodedBytes_(value) {\n    let decoded;\n    try {\n        decoded = decodeURIComponent(value);\n    } catch (e) {\n        throw invalidFormat(StringFormat.DATA_URL, \"Malformed data URL.\");\n    }\n    return utf8Bytes_(decoded);\n}\nfunction base64Bytes_(format, value) {\n    switch(format){\n        case StringFormat.BASE64:\n            {\n                const hasMinus = value.indexOf(\"-\") !== -1;\n                const hasUnder = value.indexOf(\"_\") !== -1;\n                if (hasMinus || hasUnder) {\n                    const invalidChar = hasMinus ? \"-\" : \"_\";\n                    throw invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64url encoded?\");\n                }\n                break;\n            }\n        case StringFormat.BASE64URL:\n            {\n                const hasPlus = value.indexOf(\"+\") !== -1;\n                const hasSlash = value.indexOf(\"/\") !== -1;\n                if (hasPlus || hasSlash) {\n                    const invalidChar = hasPlus ? \"+\" : \"/\";\n                    throw invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\");\n                }\n                value = value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n                break;\n            }\n    }\n    let bytes;\n    try {\n        bytes = decodeBase64(value);\n    } catch (e) {\n        if (e.message.includes(\"polyfill\")) {\n            throw e;\n        }\n        throw invalidFormat(format, \"Invalid character found\");\n    }\n    const array = new Uint8Array(bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        array[i] = bytes.charCodeAt(i);\n    }\n    return array;\n}\nclass DataURLParts {\n    constructor(dataURL){\n        this.base64 = false;\n        this.contentType = null;\n        const matches = dataURL.match(/^data:([^,]+)?,/);\n        if (matches === null) {\n            throw invalidFormat(StringFormat.DATA_URL, \"Must be formatted 'data:[<mediatype>][;base64],<data>\");\n        }\n        const middle = matches[1] || null;\n        if (middle != null) {\n            this.base64 = endsWith(middle, \";base64\");\n            this.contentType = this.base64 ? middle.substring(0, middle.length - \";base64\".length) : middle;\n        }\n        this.rest = dataURL.substring(dataURL.indexOf(\",\") + 1);\n    }\n}\nfunction dataURLBytes_(dataUrl) {\n    const parts = new DataURLParts(dataUrl);\n    if (parts.base64) {\n        return base64Bytes_(StringFormat.BASE64, parts.rest);\n    } else {\n        return percentEncodedBytes_(parts.rest);\n    }\n}\nfunction dataURLContentType_(dataUrl) {\n    const parts = new DataURLParts(dataUrl);\n    return parts.contentType;\n}\nfunction endsWith(s, end) {\n    const longEnough = s.length >= end.length;\n    if (!longEnough) {\n        return false;\n    }\n    return s.substring(s.length - end.length) === end;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @param opt_elideCopy - If true, doesn't copy mutable input data\r\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\r\n *     modified after this blob's construction.\r\n *\r\n * @internal\r\n */ class FbsBlob {\n    constructor(data, elideCopy){\n        let size = 0;\n        let blobType = \"\";\n        if (isNativeBlob(data)) {\n            this.data_ = data;\n            size = data.size;\n            blobType = data.type;\n        } else if (data instanceof ArrayBuffer) {\n            if (elideCopy) {\n                this.data_ = new Uint8Array(data);\n            } else {\n                this.data_ = new Uint8Array(data.byteLength);\n                this.data_.set(new Uint8Array(data));\n            }\n            size = this.data_.length;\n        } else if (data instanceof Uint8Array) {\n            if (elideCopy) {\n                this.data_ = data;\n            } else {\n                this.data_ = new Uint8Array(data.length);\n                this.data_.set(data);\n            }\n            size = data.length;\n        }\n        this.size_ = size;\n        this.type_ = blobType;\n    }\n    size() {\n        return this.size_;\n    }\n    type() {\n        return this.type_;\n    }\n    slice(startByte, endByte) {\n        if (isNativeBlob(this.data_)) {\n            const realBlob = this.data_;\n            const sliced = sliceBlob(realBlob, startByte, endByte);\n            if (sliced === null) {\n                return null;\n            }\n            return new FbsBlob(sliced);\n        } else {\n            const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\n            return new FbsBlob(slice, true);\n        }\n    }\n    static getBlob(...args) {\n        if (isNativeBlobDefined()) {\n            const blobby = args.map((val)=>{\n                if (val instanceof FbsBlob) {\n                    return val.data_;\n                } else {\n                    return val;\n                }\n            });\n            return new FbsBlob(getBlob$1.apply(null, blobby));\n        } else {\n            const uint8Arrays = args.map((val)=>{\n                if (isString(val)) {\n                    return dataFromString(StringFormat.RAW, val).data;\n                } else {\n                    // Blobs don't exist, so this has to be a Uint8Array.\n                    return val.data_;\n                }\n            });\n            let finalLength = 0;\n            uint8Arrays.forEach((array)=>{\n                finalLength += array.byteLength;\n            });\n            const merged = new Uint8Array(finalLength);\n            let index = 0;\n            uint8Arrays.forEach((array)=>{\n                for(let i = 0; i < array.length; i++){\n                    merged[index++] = array[i];\n                }\n            });\n            return new FbsBlob(merged, true);\n        }\n    }\n    uploadData() {\n        return this.data_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns the Object resulting from parsing the given JSON, or null if the\r\n * given string does not represent a JSON object.\r\n */ function jsonObjectOrNull(s) {\n    let obj;\n    try {\n        obj = JSON.parse(s);\n    } catch (e) {\n        return null;\n    }\n    if (isNonArrayObject(obj)) {\n        return obj;\n    } else {\n        return null;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Contains helper methods for manipulating paths.\r\n */ /**\r\n * @return Null if the path is already at the root.\r\n */ function parent(path) {\n    if (path.length === 0) {\n        return null;\n    }\n    const index = path.lastIndexOf(\"/\");\n    if (index === -1) {\n        return \"\";\n    }\n    const newPath = path.slice(0, index);\n    return newPath;\n}\nfunction child(path, childPath) {\n    const canonicalChildPath = childPath.split(\"/\").filter((component)=>component.length > 0).join(\"/\");\n    if (path.length === 0) {\n        return canonicalChildPath;\n    } else {\n        return path + \"/\" + canonicalChildPath;\n    }\n}\n/**\r\n * Returns the last component of a path.\r\n * '/foo/bar' -> 'bar'\r\n * '/foo/bar/baz/' -> 'baz/'\r\n * '/a' -> 'a'\r\n */ function lastComponent(path) {\n    const index = path.lastIndexOf(\"/\", path.length - 2);\n    if (index === -1) {\n        return path;\n    } else {\n        return path.slice(index + 1);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function noXform_(metadata, value) {\n    return value;\n}\nclass Mapping {\n    constructor(server, local, writable, xform){\n        this.server = server;\n        this.local = local || server;\n        this.writable = !!writable;\n        this.xform = xform || noXform_;\n    }\n}\nlet mappings_ = null;\nfunction xformPath(fullPath) {\n    if (!isString(fullPath) || fullPath.length < 2) {\n        return fullPath;\n    } else {\n        return lastComponent(fullPath);\n    }\n}\nfunction getMappings() {\n    if (mappings_) {\n        return mappings_;\n    }\n    const mappings = [];\n    mappings.push(new Mapping(\"bucket\"));\n    mappings.push(new Mapping(\"generation\"));\n    mappings.push(new Mapping(\"metageneration\"));\n    mappings.push(new Mapping(\"name\", \"fullPath\", true));\n    function mappingsXformPath(_metadata, fullPath) {\n        return xformPath(fullPath);\n    }\n    const nameMapping = new Mapping(\"name\");\n    nameMapping.xform = mappingsXformPath;\n    mappings.push(nameMapping);\n    /**\r\n     * Coerces the second param to a number, if it is defined.\r\n     */ function xformSize(_metadata, size) {\n        if (size !== undefined) {\n            return Number(size);\n        } else {\n            return size;\n        }\n    }\n    const sizeMapping = new Mapping(\"size\");\n    sizeMapping.xform = xformSize;\n    mappings.push(sizeMapping);\n    mappings.push(new Mapping(\"timeCreated\"));\n    mappings.push(new Mapping(\"updated\"));\n    mappings.push(new Mapping(\"md5Hash\", null, true));\n    mappings.push(new Mapping(\"cacheControl\", null, true));\n    mappings.push(new Mapping(\"contentDisposition\", null, true));\n    mappings.push(new Mapping(\"contentEncoding\", null, true));\n    mappings.push(new Mapping(\"contentLanguage\", null, true));\n    mappings.push(new Mapping(\"contentType\", null, true));\n    mappings.push(new Mapping(\"metadata\", \"customMetadata\", true));\n    mappings_ = mappings;\n    return mappings_;\n}\nfunction addRef(metadata, service) {\n    function generateRef() {\n        const bucket = metadata[\"bucket\"];\n        const path = metadata[\"fullPath\"];\n        const loc = new Location(bucket, path);\n        return service._makeStorageReference(loc);\n    }\n    Object.defineProperty(metadata, \"ref\", {\n        get: generateRef\n    });\n}\nfunction fromResource(service, resource, mappings) {\n    const metadata = {};\n    metadata[\"type\"] = \"file\";\n    const len = mappings.length;\n    for(let i = 0; i < len; i++){\n        const mapping = mappings[i];\n        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n    }\n    addRef(metadata, service);\n    return metadata;\n}\nfunction fromResourceString(service, resourceString, mappings) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    const resource = obj;\n    return fromResource(service, resource, mappings);\n}\nfunction downloadUrlFromResourceString(metadata, resourceString, host, protocol) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    if (!isString(obj[\"downloadTokens\"])) {\n        // This can happen if objects are uploaded through GCS and retrieved\n        // through list, so we don't want to throw an Error.\n        return null;\n    }\n    const tokens = obj[\"downloadTokens\"];\n    if (tokens.length === 0) {\n        return null;\n    }\n    const encode = encodeURIComponent;\n    const tokensList = tokens.split(\",\");\n    const urls = tokensList.map((token)=>{\n        const bucket = metadata[\"bucket\"];\n        const path = metadata[\"fullPath\"];\n        const urlPart = \"/b/\" + encode(bucket) + \"/o/\" + encode(path);\n        const base = makeUrl(urlPart, host, protocol);\n        const queryString = makeQueryString({\n            alt: \"media\",\n            token\n        });\n        return base + queryString;\n    });\n    return urls[0];\n}\nfunction toResourceString(metadata, mappings) {\n    const resource = {};\n    const len = mappings.length;\n    for(let i = 0; i < len; i++){\n        const mapping = mappings[i];\n        if (mapping.writable) {\n            resource[mapping.server] = metadata[mapping.local];\n        }\n    }\n    return JSON.stringify(resource);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const PREFIXES_KEY = \"prefixes\";\nconst ITEMS_KEY = \"items\";\nfunction fromBackendResponse(service, bucket, resource) {\n    const listResult = {\n        prefixes: [],\n        items: [],\n        nextPageToken: resource[\"nextPageToken\"]\n    };\n    if (resource[PREFIXES_KEY]) {\n        for (const path of resource[PREFIXES_KEY]){\n            const pathWithoutTrailingSlash = path.replace(/\\/$/, \"\");\n            const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));\n            listResult.prefixes.push(reference);\n        }\n    }\n    if (resource[ITEMS_KEY]) {\n        for (const item of resource[ITEMS_KEY]){\n            const reference = service._makeStorageReference(new Location(bucket, item[\"name\"]));\n            listResult.items.push(reference);\n        }\n    }\n    return listResult;\n}\nfunction fromResponseString(service, bucket, resourceString) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    const resource = obj;\n    return fromBackendResponse(service, bucket, resource);\n}\n/**\r\n * Contains a fully specified request.\r\n *\r\n * @param I - the type of the backend's network response.\r\n * @param O - the output response type used by the rest of the SDK.\r\n */ class RequestInfo {\n    constructor(url, method, /**\r\n     * Returns the value with which to resolve the request's promise. Only called\r\n     * if the request is successful. Throw from this function to reject the\r\n     * returned Request's promise with the thrown error.\r\n     * Note: The XhrIo passed to this function may be reused after this callback\r\n     * returns. Do not keep a reference to it in any way.\r\n     */ handler, timeout){\n        this.url = url;\n        this.method = method;\n        this.handler = handler;\n        this.timeout = timeout;\n        this.urlParams = {};\n        this.headers = {};\n        this.body = null;\n        this.errorHandler = null;\n        /**\r\n         * Called with the current number of bytes uploaded and total size (-1 if not\r\n         * computable) of the request body (i.e. used to report upload progress).\r\n         */ this.progressCallback = null;\n        this.successCodes = [\n            200\n        ];\n        this.additionalRetryCodes = [];\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Throws the UNKNOWN StorageError if cndn is false.\r\n */ function handlerCheck(cndn) {\n    if (!cndn) {\n        throw unknown();\n    }\n}\nfunction metadataHandler(service, mappings) {\n    function handler(xhr, text) {\n        const metadata = fromResourceString(service, text, mappings);\n        handlerCheck(metadata !== null);\n        return metadata;\n    }\n    return handler;\n}\nfunction listHandler(service, bucket) {\n    function handler(xhr, text) {\n        const listResult = fromResponseString(service, bucket, text);\n        handlerCheck(listResult !== null);\n        return listResult;\n    }\n    return handler;\n}\nfunction downloadUrlHandler(service, mappings) {\n    function handler(xhr, text) {\n        const metadata = fromResourceString(service, text, mappings);\n        handlerCheck(metadata !== null);\n        return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);\n    }\n    return handler;\n}\nfunction sharedErrorHandler(location) {\n    function errorHandler(xhr, err) {\n        let newErr;\n        if (xhr.getStatus() === 401) {\n            if (// This exact message string is the only consistent part of the\n            // server's error response that identifies it as an App Check error.\n            xhr.getErrorText().includes(\"Firebase App Check token is invalid\")) {\n                newErr = unauthorizedApp();\n            } else {\n                newErr = unauthenticated();\n            }\n        } else {\n            if (xhr.getStatus() === 402) {\n                newErr = quotaExceeded(location.bucket);\n            } else {\n                if (xhr.getStatus() === 403) {\n                    newErr = unauthorized(location.path);\n                } else {\n                    newErr = err;\n                }\n            }\n        }\n        newErr.status = xhr.getStatus();\n        newErr.serverResponse = err.serverResponse;\n        return newErr;\n    }\n    return errorHandler;\n}\nfunction objectErrorHandler(location) {\n    const shared = sharedErrorHandler(location);\n    function errorHandler(xhr, err) {\n        let newErr = shared(xhr, err);\n        if (xhr.getStatus() === 404) {\n            newErr = objectNotFound(location.path);\n        }\n        newErr.serverResponse = err.serverResponse;\n        return newErr;\n    }\n    return errorHandler;\n}\nfunction getMetadata$2(service, location, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = \"GET\";\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction list$2(service, location, delimiter, pageToken, maxResults) {\n    const urlParams = {};\n    if (location.isRoot) {\n        urlParams[\"prefix\"] = \"\";\n    } else {\n        urlParams[\"prefix\"] = location.path + \"/\";\n    }\n    if (delimiter && delimiter.length > 0) {\n        urlParams[\"delimiter\"] = delimiter;\n    }\n    if (pageToken) {\n        urlParams[\"pageToken\"] = pageToken;\n    }\n    if (maxResults) {\n        urlParams[\"maxResults\"] = maxResults;\n    }\n    const urlPart = location.bucketOnlyServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = \"GET\";\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\nfunction getBytes$1(service, location, maxDownloadSizeBytes) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol) + \"?alt=media\";\n    const method = \"GET\";\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, (_, data)=>data, timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    if (maxDownloadSizeBytes !== undefined) {\n        requestInfo.headers[\"Range\"] = `bytes=0-${maxDownloadSizeBytes}`;\n        requestInfo.successCodes = [\n            200 /* OK */ ,\n            206 /* Partial Content */ \n        ];\n    }\n    return requestInfo;\n}\nfunction getDownloadUrl(service, location, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = \"GET\";\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction updateMetadata$2(service, location, metadata, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = \"PATCH\";\n    const body = toResourceString(metadata, mappings);\n    const headers = {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n    };\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction deleteObject$2(service, location) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = \"DELETE\";\n    const timeout = service.maxOperationRetryTime;\n    function handler(_xhr, _text) {}\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.successCodes = [\n        200,\n        204\n    ];\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction determineContentType_(metadata, blob) {\n    return metadata && metadata[\"contentType\"] || blob && blob.type() || \"application/octet-stream\";\n}\nfunction metadataForUpload_(location, blob, metadata) {\n    const metadataClone = Object.assign({}, metadata);\n    metadataClone[\"fullPath\"] = location.path;\n    metadataClone[\"size\"] = blob.size();\n    if (!metadataClone[\"contentType\"]) {\n        metadataClone[\"contentType\"] = determineContentType_(null, blob);\n    }\n    return metadataClone;\n}\n/**\r\n * Prepare RequestInfo for uploads as Content-Type: multipart.\r\n */ function multipartUpload(service, location, mappings, blob, metadata) {\n    const urlPart = location.bucketOnlyServerUrl();\n    const headers = {\n        \"X-Goog-Upload-Protocol\": \"multipart\"\n    };\n    function genBoundary() {\n        let str = \"\";\n        for(let i = 0; i < 2; i++){\n            str = str + Math.random().toString().slice(2);\n        }\n        return str;\n    }\n    const boundary = genBoundary();\n    headers[\"Content-Type\"] = \"multipart/related; boundary=\" + boundary;\n    const metadata_ = metadataForUpload_(location, blob, metadata);\n    const metadataString = toResourceString(metadata_, mappings);\n    const preBlobPart = \"--\" + boundary + \"\\r\\n\" + \"Content-Type: application/json; charset=utf-8\\r\\n\\r\\n\" + metadataString + \"\\r\\n--\" + boundary + \"\\r\\n\" + \"Content-Type: \" + metadata_[\"contentType\"] + \"\\r\\n\\r\\n\";\n    const postBlobPart = \"\\r\\n--\" + boundary + \"--\";\n    const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n    if (body === null) {\n        throw cannotSliceBlob();\n    }\n    const urlParams = {\n        name: metadata_[\"fullPath\"]\n    };\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = \"POST\";\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\r\n * @param current The number of bytes that have been uploaded so far.\r\n * @param total The total number of bytes in the upload.\r\n * @param opt_finalized True if the server has finished the upload.\r\n * @param opt_metadata The upload metadata, should\r\n *     only be passed if opt_finalized is true.\r\n */ class ResumableUploadStatus {\n    constructor(current, total, finalized, metadata){\n        this.current = current;\n        this.total = total;\n        this.finalized = !!finalized;\n        this.metadata = metadata || null;\n    }\n}\nfunction checkResumeHeader_(xhr, allowed) {\n    let status = null;\n    try {\n        status = xhr.getResponseHeader(\"X-Goog-Upload-Status\");\n    } catch (e) {\n        handlerCheck(false);\n    }\n    const allowedStatus = allowed || [\n        \"active\"\n    ];\n    handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);\n    return status;\n}\nfunction createResumableUpload(service, location, mappings, blob, metadata) {\n    const urlPart = location.bucketOnlyServerUrl();\n    const metadataForUpload = metadataForUpload_(location, blob, metadata);\n    const urlParams = {\n        name: metadataForUpload[\"fullPath\"]\n    };\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = \"POST\";\n    const headers = {\n        \"X-Goog-Upload-Protocol\": \"resumable\",\n        \"X-Goog-Upload-Command\": \"start\",\n        \"X-Goog-Upload-Header-Content-Length\": `${blob.size()}`,\n        \"X-Goog-Upload-Header-Content-Type\": metadataForUpload[\"contentType\"],\n        \"Content-Type\": \"application/json; charset=utf-8\"\n    };\n    const body = toResourceString(metadataForUpload, mappings);\n    const timeout = service.maxUploadRetryTime;\n    function handler(xhr) {\n        checkResumeHeader_(xhr);\n        let url;\n        try {\n            url = xhr.getResponseHeader(\"X-Goog-Upload-URL\");\n        } catch (e) {\n            handlerCheck(false);\n        }\n        handlerCheck(isString(url));\n        return url;\n    }\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\r\n * @param url From a call to fbs.requests.createResumableUpload.\r\n */ function getResumableUploadStatus(service, location, url, blob) {\n    const headers = {\n        \"X-Goog-Upload-Command\": \"query\"\n    };\n    function handler(xhr) {\n        const status = checkResumeHeader_(xhr, [\n            \"active\",\n            \"final\"\n        ]);\n        let sizeString = null;\n        try {\n            sizeString = xhr.getResponseHeader(\"X-Goog-Upload-Size-Received\");\n        } catch (e) {\n            handlerCheck(false);\n        }\n        if (!sizeString) {\n            // null or empty string\n            handlerCheck(false);\n        }\n        const size = Number(sizeString);\n        handlerCheck(!isNaN(size));\n        return new ResumableUploadStatus(size, blob.size(), status === \"final\");\n    }\n    const method = \"POST\";\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\r\n * Any uploads via the resumable upload API must transfer a number of bytes\r\n * that is a multiple of this number.\r\n */ const RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;\n/**\r\n * @param url From a call to fbs.requests.createResumableUpload.\r\n * @param chunkSize Number of bytes to upload.\r\n * @param status The previous status.\r\n *     If not passed or null, we start from the beginning.\r\n * @throws fbs.Error If the upload is already complete, the passed in status\r\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\r\n *     for upload.\r\n */ function continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {\n    // TODO(andysoto): standardize on internal asserts\n    // assert(!(opt_status && opt_status.finalized));\n    const status_ = new ResumableUploadStatus(0, 0);\n    if (status) {\n        status_.current = status.current;\n        status_.total = status.total;\n    } else {\n        status_.current = 0;\n        status_.total = blob.size();\n    }\n    if (blob.size() !== status_.total) {\n        throw serverFileWrongSize();\n    }\n    const bytesLeft = status_.total - status_.current;\n    let bytesToUpload = bytesLeft;\n    if (chunkSize > 0) {\n        bytesToUpload = Math.min(bytesToUpload, chunkSize);\n    }\n    const startByte = status_.current;\n    const endByte = startByte + bytesToUpload;\n    let uploadCommand = \"\";\n    if (bytesToUpload === 0) {\n        uploadCommand = \"finalize\";\n    } else if (bytesLeft === bytesToUpload) {\n        uploadCommand = \"upload, finalize\";\n    } else {\n        uploadCommand = \"upload\";\n    }\n    const headers = {\n        \"X-Goog-Upload-Command\": uploadCommand,\n        \"X-Goog-Upload-Offset\": `${status_.current}`\n    };\n    const body = blob.slice(startByte, endByte);\n    if (body === null) {\n        throw cannotSliceBlob();\n    }\n    function handler(xhr, text) {\n        // TODO(andysoto): Verify the MD5 of each uploaded range:\n        // the 'x-range-md5' header comes back with status code 308 responses.\n        // We'll only be able to bail out though, because you can't re-upload a\n        // range that you previously uploaded.\n        const uploadStatus = checkResumeHeader_(xhr, [\n            \"active\",\n            \"final\"\n        ]);\n        const newCurrent = status_.current + bytesToUpload;\n        const size = blob.size();\n        let metadata;\n        if (uploadStatus === \"final\") {\n            metadata = metadataHandler(service, mappings)(xhr, text);\n        } else {\n            metadata = null;\n        }\n        return new ResumableUploadStatus(newCurrent, size, uploadStatus === \"final\", metadata);\n    }\n    const method = \"POST\";\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.progressCallback = progressCallback || null;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An event that is triggered on a task.\r\n * @internal\r\n */ const TaskEvent = {\n    /**\r\n     * For this event,\r\n     * <ul>\r\n     *   <li>The `next` function is triggered on progress updates and when the\r\n     *       task is paused/resumed with an `UploadTaskSnapshot` as the first\r\n     *       argument.</li>\r\n     *   <li>The `error` function is triggered if the upload is canceled or fails\r\n     *       for another reason.</li>\r\n     *   <li>The `complete` function is triggered if the upload completes\r\n     *       successfully.</li>\r\n     * </ul>\r\n     */ STATE_CHANGED: \"state_changed\"\n};\n// type keys = keyof TaskState\n/**\r\n * Represents the current state of a running upload.\r\n * @internal\r\n */ const TaskState = {\n    /** The task is currently transferring data. */ RUNNING: \"running\",\n    /** The task was paused by the user. */ PAUSED: \"paused\",\n    /** The task completed successfully. */ SUCCESS: \"success\",\n    /** The task was canceled. */ CANCELED: \"canceled\",\n    /** The task failed with an error. */ ERROR: \"error\"\n};\nfunction taskStateFromInternalTaskState(state) {\n    switch(state){\n        case \"running\" /* InternalTaskState.RUNNING */ :\n        case \"pausing\" /* InternalTaskState.PAUSING */ :\n        case \"canceling\" /* InternalTaskState.CANCELING */ :\n            return TaskState.RUNNING;\n        case \"paused\" /* InternalTaskState.PAUSED */ :\n            return TaskState.PAUSED;\n        case \"success\" /* InternalTaskState.SUCCESS */ :\n            return TaskState.SUCCESS;\n        case \"canceled\" /* InternalTaskState.CANCELED */ :\n            return TaskState.CANCELED;\n        case \"error\" /* InternalTaskState.ERROR */ :\n            return TaskState.ERROR;\n        default:\n            // TODO(andysoto): assert(false);\n            return TaskState.ERROR;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Observer {\n    constructor(nextOrObserver, error, complete){\n        const asFunctions = isFunction(nextOrObserver) || error != null || complete != null;\n        if (asFunctions) {\n            this.next = nextOrObserver;\n            this.error = error !== null && error !== void 0 ? error : undefined;\n            this.complete = complete !== null && complete !== void 0 ? complete : undefined;\n        } else {\n            const observer = nextOrObserver;\n            this.next = observer.next;\n            this.error = observer.error;\n            this.complete = observer.complete;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a function that invokes f with its arguments asynchronously as a\r\n * microtask, i.e. as soon as possible after the current script returns back\r\n * into browser code.\r\n */ // eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(f) {\n    return (...argsToForward)=>{\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(()=>f(...argsToForward));\n    };\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** An override for the text-based Connection. Used in tests. */ let textFactoryOverride = null;\n/**\r\n * Network layer that works in Node.\r\n *\r\n * This network implementation should not be used in browsers as it does not\r\n * support progress updates.\r\n */ class FetchConnection {\n    constructor(){\n        this.errorText_ = \"\";\n        this.sent_ = false;\n        this.fetch_ = undici__WEBPACK_IMPORTED_MODULE_3__.fetch;\n        this.errorCode_ = ErrorCode.NO_ERROR;\n    }\n    async send(url, method, body, headers) {\n        if (this.sent_) {\n            throw internalError(\"cannot .send() more than once\");\n        }\n        this.sent_ = true;\n        try {\n            const response = await this.fetch_(url, {\n                method,\n                headers: headers || {},\n                body: body\n            });\n            this.headers_ = response.headers;\n            this.statusCode_ = response.status;\n            this.errorCode_ = ErrorCode.NO_ERROR;\n            this.body_ = await response.arrayBuffer();\n        } catch (e) {\n            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;\n            // emulate XHR which sets status to 0 when encountering a network error\n            this.statusCode_ = 0;\n            this.errorCode_ = ErrorCode.NETWORK_ERROR;\n        }\n    }\n    getErrorCode() {\n        if (this.errorCode_ === undefined) {\n            throw internalError(\"cannot .getErrorCode() before receiving response\");\n        }\n        return this.errorCode_;\n    }\n    getStatus() {\n        if (this.statusCode_ === undefined) {\n            throw internalError(\"cannot .getStatus() before receiving response\");\n        }\n        return this.statusCode_;\n    }\n    getErrorText() {\n        return this.errorText_;\n    }\n    abort() {\n    // Not supported\n    }\n    getResponseHeader(header) {\n        if (!this.headers_) {\n            throw internalError(\"cannot .getResponseHeader() before receiving response\");\n        }\n        return this.headers_.get(header);\n    }\n    addUploadProgressListener(listener) {\n    // Not supported\n    }\n    removeUploadProgressListener(listener) {\n    // Not supported\n    }\n}\nclass FetchTextConnection extends FetchConnection {\n    getResponse() {\n        if (!this.body_) {\n            throw internalError(\"cannot .getResponse() before receiving response\");\n        }\n        return Buffer.from(this.body_).toString(\"utf-8\");\n    }\n}\nfunction newTextConnection() {\n    return textFactoryOverride ? textFactoryOverride() : new FetchTextConnection();\n}\nclass FetchBytesConnection extends FetchConnection {\n    getResponse() {\n        if (!this.body_) {\n            throw internalError(\"cannot .getResponse() before sending\");\n        }\n        return this.body_;\n    }\n}\nfunction newBytesConnection() {\n    return new FetchBytesConnection();\n}\nclass FetchStreamConnection extends FetchConnection {\n    constructor(){\n        super(...arguments);\n        this.stream_ = null;\n    }\n    async send(url, method, body, headers) {\n        if (this.sent_) {\n            throw internalError(\"cannot .send() more than once\");\n        }\n        this.sent_ = true;\n        try {\n            const response = await this.fetch_(url, {\n                method,\n                headers: headers || {},\n                body: body\n            });\n            this.headers_ = response.headers;\n            this.statusCode_ = response.status;\n            this.errorCode_ = ErrorCode.NO_ERROR;\n            this.stream_ = response.body;\n        } catch (e) {\n            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;\n            // emulate XHR which sets status to 0 when encountering a network error\n            this.statusCode_ = 0;\n            this.errorCode_ = ErrorCode.NETWORK_ERROR;\n        }\n    }\n    getResponse() {\n        if (!this.stream_) {\n            throw internalError(\"cannot .getResponse() before sending\");\n        }\n        return this.stream_;\n    }\n}\nfunction newStreamConnection() {\n    return new FetchStreamConnection();\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\r\n * upload and manage callbacks for various events.\r\n * @internal\r\n */ class UploadTask {\n    /**\r\n     * @param ref - The firebaseStorage.Reference object this task came\r\n     *     from, untyped to avoid cyclic dependencies.\r\n     * @param blob - The blob to upload.\r\n     */ constructor(ref, blob, metadata = null){\n        /**\r\n         * Number of bytes transferred so far.\r\n         */ this._transferred = 0;\n        this._needToFetchStatus = false;\n        this._needToFetchMetadata = false;\n        this._observers = [];\n        this._error = undefined;\n        this._uploadUrl = undefined;\n        this._request = undefined;\n        this._chunkMultiplier = 1;\n        this._resolve = undefined;\n        this._reject = undefined;\n        this._ref = ref;\n        this._blob = blob;\n        this._metadata = metadata;\n        this._mappings = getMappings();\n        this._resumable = this._shouldDoResumable(this._blob);\n        this._state = \"running\" /* InternalTaskState.RUNNING */ ;\n        this._errorHandler = (error)=>{\n            this._request = undefined;\n            this._chunkMultiplier = 1;\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\n                this._needToFetchStatus = true;\n                this.completeTransitions_();\n            } else {\n                const backoffExpired = this.isExponentialBackoffExpired();\n                if (isRetryStatusCode(error.status, [])) {\n                    if (backoffExpired) {\n                        error = retryLimitExceeded();\n                    } else {\n                        this.sleepTime = Math.max(this.sleepTime * 2, DEFAULT_MIN_SLEEP_TIME_MILLIS);\n                        this._needToFetchStatus = true;\n                        this.completeTransitions_();\n                        return;\n                    }\n                }\n                this._error = error;\n                this._transition(\"error\" /* InternalTaskState.ERROR */ );\n            }\n        };\n        this._metadataErrorHandler = (error)=>{\n            this._request = undefined;\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\n                this.completeTransitions_();\n            } else {\n                this._error = error;\n                this._transition(\"error\" /* InternalTaskState.ERROR */ );\n            }\n        };\n        this.sleepTime = 0;\n        this.maxSleepTime = this._ref.storage.maxUploadRetryTime;\n        this._promise = new Promise((resolve, reject)=>{\n            this._resolve = resolve;\n            this._reject = reject;\n            this._start();\n        });\n        // Prevent uncaught rejections on the internal promise from bubbling out\n        // to the top level with a dummy handler.\n        this._promise.then(null, ()=>{});\n    }\n    isExponentialBackoffExpired() {\n        return this.sleepTime > this.maxSleepTime;\n    }\n    _makeProgressCallback() {\n        const sizeBefore = this._transferred;\n        return (loaded)=>this._updateProgress(sizeBefore + loaded);\n    }\n    _shouldDoResumable(blob) {\n        return blob.size() > 256 * 1024;\n    }\n    _start() {\n        if (this._state !== \"running\" /* InternalTaskState.RUNNING */ ) {\n            // This can happen if someone pauses us in a resume callback, for example.\n            return;\n        }\n        if (this._request !== undefined) {\n            return;\n        }\n        if (this._resumable) {\n            if (this._uploadUrl === undefined) {\n                this._createResumable();\n            } else {\n                if (this._needToFetchStatus) {\n                    this._fetchStatus();\n                } else {\n                    if (this._needToFetchMetadata) {\n                        // Happens if we miss the metadata on upload completion.\n                        this._fetchMetadata();\n                    } else {\n                        this.pendingTimeout = setTimeout(()=>{\n                            this.pendingTimeout = undefined;\n                            this._continueUpload();\n                        }, this.sleepTime);\n                    }\n                }\n            }\n        } else {\n            this._oneShotUpload();\n        }\n    }\n    _resolveToken(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.all([\n            this._ref.storage._getAuthToken(),\n            this._ref.storage._getAppCheckToken()\n        ]).then(([authToken, appCheckToken])=>{\n            switch(this._state){\n                case \"running\" /* InternalTaskState.RUNNING */ :\n                    callback(authToken, appCheckToken);\n                    break;\n                case \"canceling\" /* InternalTaskState.CANCELING */ :\n                    this._transition(\"canceled\" /* InternalTaskState.CANCELED */ );\n                    break;\n                case \"pausing\" /* InternalTaskState.PAUSING */ :\n                    this._transition(\"paused\" /* InternalTaskState.PAUSED */ );\n                    break;\n            }\n        });\n    }\n    // TODO(andysoto): assert false\n    _createResumable() {\n        this._resolveToken((authToken, appCheckToken)=>{\n            const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\n            const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = createRequest;\n            createRequest.getPromise().then((url)=>{\n                this._request = undefined;\n                this._uploadUrl = url;\n                this._needToFetchStatus = false;\n                this.completeTransitions_();\n            }, this._errorHandler);\n        });\n    }\n    _fetchStatus() {\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        const url = this._uploadUrl;\n        this._resolveToken((authToken, appCheckToken)=>{\n            const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);\n            const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = statusRequest;\n            statusRequest.getPromise().then((status)=>{\n                status = status;\n                this._request = undefined;\n                this._updateProgress(status.current);\n                this._needToFetchStatus = false;\n                if (status.finalized) {\n                    this._needToFetchMetadata = true;\n                }\n                this.completeTransitions_();\n            }, this._errorHandler);\n        });\n    }\n    _continueUpload() {\n        const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\n        const status = new ResumableUploadStatus(this._transferred, this._blob.size());\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        const url = this._uploadUrl;\n        this._resolveToken((authToken, appCheckToken)=>{\n            let requestInfo;\n            try {\n                requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());\n            } catch (e) {\n                this._error = e;\n                this._transition(\"error\" /* InternalTaskState.ERROR */ );\n                return;\n            }\n            const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken, /*retry=*/ false // Upload requests should not be retried as each retry should be preceded by another query request. Which is handled in this file.\n            );\n            this._request = uploadRequest;\n            uploadRequest.getPromise().then((newStatus)=>{\n                this._increaseMultiplier();\n                this._request = undefined;\n                this._updateProgress(newStatus.current);\n                if (newStatus.finalized) {\n                    this._metadata = newStatus.metadata;\n                    this._transition(\"success\" /* InternalTaskState.SUCCESS */ );\n                } else {\n                    this.completeTransitions_();\n                }\n            }, this._errorHandler);\n        });\n    }\n    _increaseMultiplier() {\n        const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\n        // Max chunk size is 32M.\n        if (currentSize * 2 < 32 * 1024 * 1024) {\n            this._chunkMultiplier *= 2;\n        }\n    }\n    _fetchMetadata() {\n        this._resolveToken((authToken, appCheckToken)=>{\n            const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);\n            const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = metadataRequest;\n            metadataRequest.getPromise().then((metadata)=>{\n                this._request = undefined;\n                this._metadata = metadata;\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */ );\n            }, this._metadataErrorHandler);\n        });\n    }\n    _oneShotUpload() {\n        this._resolveToken((authToken, appCheckToken)=>{\n            const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\n            const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = multipartRequest;\n            multipartRequest.getPromise().then((metadata)=>{\n                this._request = undefined;\n                this._metadata = metadata;\n                this._updateProgress(this._blob.size());\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */ );\n            }, this._errorHandler);\n        });\n    }\n    _updateProgress(transferred) {\n        const old = this._transferred;\n        this._transferred = transferred;\n        // A progress update can make the \"transferred\" value smaller (e.g. a\n        // partial upload not completed by server, after which the \"transferred\"\n        // value may reset to the value at the beginning of the request).\n        if (this._transferred !== old) {\n            this._notifyObservers();\n        }\n    }\n    _transition(state) {\n        if (this._state === state) {\n            return;\n        }\n        switch(state){\n            case \"canceling\" /* InternalTaskState.CANCELING */ :\n            case \"pausing\" /* InternalTaskState.PAUSING */ :\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                this._state = state;\n                if (this._request !== undefined) {\n                    this._request.cancel();\n                } else if (this.pendingTimeout) {\n                    clearTimeout(this.pendingTimeout);\n                    this.pendingTimeout = undefined;\n                    this.completeTransitions_();\n                }\n                break;\n            case \"running\" /* InternalTaskState.RUNNING */ :\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                const wasPaused = this._state === \"paused\" /* InternalTaskState.PAUSED */ ;\n                this._state = state;\n                if (wasPaused) {\n                    this._notifyObservers();\n                    this._start();\n                }\n                break;\n            case \"paused\" /* InternalTaskState.PAUSED */ :\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"canceled\" /* InternalTaskState.CANCELED */ :\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._error = canceled();\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"error\" /* InternalTaskState.ERROR */ :\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"success\" /* InternalTaskState.SUCCESS */ :\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n        }\n    }\n    completeTransitions_() {\n        switch(this._state){\n            case \"pausing\" /* InternalTaskState.PAUSING */ :\n                this._transition(\"paused\" /* InternalTaskState.PAUSED */ );\n                break;\n            case \"canceling\" /* InternalTaskState.CANCELING */ :\n                this._transition(\"canceled\" /* InternalTaskState.CANCELED */ );\n                break;\n            case \"running\" /* InternalTaskState.RUNNING */ :\n                this._start();\n                break;\n        }\n    }\n    /**\r\n     * A snapshot of the current task state.\r\n     */ get snapshot() {\n        const externalState = taskStateFromInternalTaskState(this._state);\n        return {\n            bytesTransferred: this._transferred,\n            totalBytes: this._blob.size(),\n            state: externalState,\n            metadata: this._metadata,\n            task: this,\n            ref: this._ref\n        };\n    }\n    /**\r\n     * Adds a callback for an event.\r\n     * @param type - The type of event to listen for.\r\n     * @param nextOrObserver -\r\n     *     The `next` function, which gets called for each item in\r\n     *     the event stream, or an observer object with some or all of these three\r\n     *     properties (`next`, `error`, `complete`).\r\n     * @param error - A function that gets called with a `StorageError`\r\n     *     if the event stream ends due to an error.\r\n     * @param completed - A function that gets called if the\r\n     *     event stream ends normally.\r\n     * @returns\r\n     *     If only the event argument is passed, returns a function you can use to\r\n     *     add callbacks (see the examples above). If more than just the event\r\n     *     argument is passed, returns a function you can call to unregister the\r\n     *     callbacks.\r\n     */ on(type, nextOrObserver, error, completed) {\n        // Note: `type` isn't being used. Its type is also incorrect. TaskEvent should not be a string.\n        const observer = new Observer(nextOrObserver || undefined, error || undefined, completed || undefined);\n        this._addObserver(observer);\n        return ()=>{\n            this._removeObserver(observer);\n        };\n    }\n    /**\r\n     * This object behaves like a Promise, and resolves with its snapshot data\r\n     * when the upload completes.\r\n     * @param onFulfilled - The fulfillment callback. Promise chaining works as normal.\r\n     * @param onRejected - The rejection callback.\r\n     */ then(onFulfilled, onRejected) {\n        // These casts are needed so that TypeScript can infer the types of the\n        // resulting Promise.\n        return this._promise.then(onFulfilled, onRejected);\n    }\n    /**\r\n     * Equivalent to calling `then(null, onRejected)`.\r\n     */ catch(onRejected) {\n        return this.then(null, onRejected);\n    }\n    /**\r\n     * Adds the given observer.\r\n     */ _addObserver(observer) {\n        this._observers.push(observer);\n        this._notifyObserver(observer);\n    }\n    /**\r\n     * Removes the given observer.\r\n     */ _removeObserver(observer) {\n        const i = this._observers.indexOf(observer);\n        if (i !== -1) {\n            this._observers.splice(i, 1);\n        }\n    }\n    _notifyObservers() {\n        this._finishPromise();\n        const observers = this._observers.slice();\n        observers.forEach((observer)=>{\n            this._notifyObserver(observer);\n        });\n    }\n    _finishPromise() {\n        if (this._resolve !== undefined) {\n            let triggered = true;\n            switch(taskStateFromInternalTaskState(this._state)){\n                case TaskState.SUCCESS:\n                    async(this._resolve.bind(null, this.snapshot))();\n                    break;\n                case TaskState.CANCELED:\n                case TaskState.ERROR:\n                    const toCall = this._reject;\n                    async(toCall.bind(null, this._error))();\n                    break;\n                default:\n                    triggered = false;\n                    break;\n            }\n            if (triggered) {\n                this._resolve = undefined;\n                this._reject = undefined;\n            }\n        }\n    }\n    _notifyObserver(observer) {\n        const externalState = taskStateFromInternalTaskState(this._state);\n        switch(externalState){\n            case TaskState.RUNNING:\n            case TaskState.PAUSED:\n                if (observer.next) {\n                    async(observer.next.bind(observer, this.snapshot))();\n                }\n                break;\n            case TaskState.SUCCESS:\n                if (observer.complete) {\n                    async(observer.complete.bind(observer))();\n                }\n                break;\n            case TaskState.CANCELED:\n            case TaskState.ERROR:\n                if (observer.error) {\n                    async(observer.error.bind(observer, this._error))();\n                }\n                break;\n            default:\n                // TODO(andysoto): assert(false);\n                if (observer.error) {\n                    async(observer.error.bind(observer, this._error))();\n                }\n        }\n    }\n    /**\r\n     * Resumes a paused task. Has no effect on a currently running or failed task.\r\n     * @returns True if the operation took effect, false if ignored.\r\n     */ resume() {\n        const valid = this._state === \"paused\" /* InternalTaskState.PAUSED */  || this._state === \"pausing\" /* InternalTaskState.PAUSING */ ;\n        if (valid) {\n            this._transition(\"running\" /* InternalTaskState.RUNNING */ );\n        }\n        return valid;\n    }\n    /**\r\n     * Pauses a currently running task. Has no effect on a paused or failed task.\r\n     * @returns True if the operation took effect, false if ignored.\r\n     */ pause() {\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */ ;\n        if (valid) {\n            this._transition(\"pausing\" /* InternalTaskState.PAUSING */ );\n        }\n        return valid;\n    }\n    /**\r\n     * Cancels a currently running or paused task. Has no effect on a complete or\r\n     * failed task.\r\n     * @returns True if the operation took effect, false if ignored.\r\n     */ cancel() {\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */  || this._state === \"pausing\" /* InternalTaskState.PAUSING */ ;\n        if (valid) {\n            this._transition(\"canceling\" /* InternalTaskState.CANCELING */ );\n        }\n        return valid;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provides methods to interact with a bucket in the Firebase Storage service.\r\n * @internal\r\n * @param _location - An fbs.location, or the URL at\r\n *     which to base this object, in one of the following forms:\r\n *         gs://<bucket>/<object-path>\r\n *         http[s]://firebasestorage.googleapis.com/\r\n *                     <api-version>/b/<bucket>/o/<object-path>\r\n *     Any query or fragment strings will be ignored in the http[s]\r\n *     format. If no value is passed, the storage object will use a URL based on\r\n *     the project ID of the base firebase.App instance.\r\n */ class Reference {\n    constructor(_service, location){\n        this._service = _service;\n        if (location instanceof Location) {\n            this._location = location;\n        } else {\n            this._location = Location.makeFromUrl(location, _service.host);\n        }\n    }\n    /**\r\n     * Returns the URL for the bucket and path this object references,\r\n     *     in the form gs://<bucket>/<object-path>\r\n     * @override\r\n     */ toString() {\n        return \"gs://\" + this._location.bucket + \"/\" + this._location.path;\n    }\n    _newRef(service, location) {\n        return new Reference(service, location);\n    }\n    /**\r\n     * A reference to the root of this object's bucket.\r\n     */ get root() {\n        const location = new Location(this._location.bucket, \"\");\n        return this._newRef(this._service, location);\n    }\n    /**\r\n     * The name of the bucket containing this reference's object.\r\n     */ get bucket() {\n        return this._location.bucket;\n    }\n    /**\r\n     * The full path of this object.\r\n     */ get fullPath() {\n        return this._location.path;\n    }\n    /**\r\n     * The short name of this object, which is the last component of the full path.\r\n     * For example, if fullPath is 'full/path/image.png', name is 'image.png'.\r\n     */ get name() {\n        return lastComponent(this._location.path);\n    }\n    /**\r\n     * The `StorageService` instance this `StorageReference` is associated with.\r\n     */ get storage() {\n        return this._service;\n    }\n    /**\r\n     * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if\r\n     * this reference is the root.\r\n     */ get parent() {\n        const newPath = parent(this._location.path);\n        if (newPath === null) {\n            return null;\n        }\n        const location = new Location(this._location.bucket, newPath);\n        return new Reference(this._service, location);\n    }\n    /**\r\n     * Utility function to throw an error in methods that do not accept a root reference.\r\n     */ _throwIfRoot(name) {\n        if (this._location.path === \"\") {\n            throw invalidRootOperation(name);\n        }\n    }\n}\n/**\r\n * Download the bytes at the object's location.\r\n * @returns A Promise containing the downloaded bytes.\r\n */ function getBytesInternal(ref, maxDownloadSizeBytes) {\n    ref._throwIfRoot(\"getBytes\");\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\n    return ref.storage.makeRequestWithTokens(requestInfo, newBytesConnection).then((bytes)=>maxDownloadSizeBytes !== undefined ? bytes.slice(0, maxDownloadSizeBytes) : bytes);\n}\n/** Stream the bytes at the object's location. */ function getStreamInternal(ref, maxDownloadSizeBytes) {\n    ref._throwIfRoot(\"getStream\");\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\n    /** A transformer that passes through the first n bytes. */ const newMaxSizeTransform = (n)=>{\n        let missingBytes = n;\n        return {\n            transform (chunk, encoding, callback) {\n                // GCS may not honor the Range header for small files\n                if (chunk.length < missingBytes) {\n                    this.push(chunk);\n                    missingBytes -= chunk.length;\n                } else {\n                    this.push(chunk.slice(0, missingBytes));\n                    this.emit(\"end\");\n                }\n                callback();\n            }\n        };\n    };\n    const result = maxDownloadSizeBytes !== undefined ? new stream__WEBPACK_IMPORTED_MODULE_2__.Transform(newMaxSizeTransform(maxDownloadSizeBytes)) : new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();\n    ref.storage.makeRequestWithTokens(requestInfo, newStreamConnection).then((stream)=>stream.pipe(result)).catch((e)=>result.destroy(e));\n    return result;\n}\n/**\r\n * Uploads data to this object's location.\r\n * The upload is not resumable.\r\n *\r\n * @param ref - StorageReference where data should be uploaded.\r\n * @param data - The data to upload.\r\n * @param metadata - Metadata for the newly uploaded data.\r\n * @returns A Promise containing an UploadResult\r\n */ function uploadBytes$1(ref, data, metadata) {\n    ref._throwIfRoot(\"uploadBytes\");\n    const requestInfo = multipartUpload(ref.storage, ref._location, getMappings(), new FbsBlob(data, true), metadata);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection).then((finalMetadata)=>{\n        return {\n            metadata: finalMetadata,\n            ref\n        };\n    });\n}\n/**\r\n * Uploads data to this object's location.\r\n * The upload can be paused and resumed, and exposes progress updates.\r\n * @public\r\n * @param ref - StorageReference where data should be uploaded.\r\n * @param data - The data to upload.\r\n * @param metadata - Metadata for the newly uploaded data.\r\n * @returns An UploadTask\r\n */ function uploadBytesResumable$1(ref, data, metadata) {\n    ref._throwIfRoot(\"uploadBytesResumable\");\n    return new UploadTask(ref, new FbsBlob(data), metadata);\n}\n/**\r\n * Uploads a string to this object's location.\r\n * The upload is not resumable.\r\n * @public\r\n * @param ref - StorageReference where string should be uploaded.\r\n * @param value - The string to upload.\r\n * @param format - The format of the string to upload.\r\n * @param metadata - Metadata for the newly uploaded string.\r\n * @returns A Promise containing an UploadResult\r\n */ function uploadString$1(ref, value, format = StringFormat.RAW, metadata) {\n    ref._throwIfRoot(\"uploadString\");\n    const data = dataFromString(format, value);\n    const metadataClone = Object.assign({}, metadata);\n    if (metadataClone[\"contentType\"] == null && data.contentType != null) {\n        metadataClone[\"contentType\"] = data.contentType;\n    }\n    return uploadBytes$1(ref, data.data, metadataClone);\n}\n/**\r\n * List all items (files) and prefixes (folders) under this storage reference.\r\n *\r\n * This is a helper method for calling list() repeatedly until there are\r\n * no more results. The default pagination size is 1000.\r\n *\r\n * Note: The results may not be consistent if objects are changed while this\r\n * operation is running.\r\n *\r\n * Warning: listAll may potentially consume too many resources if there are\r\n * too many results.\r\n * @public\r\n * @param ref - StorageReference to get list from.\r\n *\r\n * @returns A Promise that resolves with all the items and prefixes under\r\n *      the current storage reference. `prefixes` contains references to\r\n *      sub-directories and `items` contains references to objects in this\r\n *      folder. `nextPageToken` is never returned.\r\n */ function listAll$1(ref) {\n    const accumulator = {\n        prefixes: [],\n        items: []\n    };\n    return listAllHelper(ref, accumulator).then(()=>accumulator);\n}\n/**\r\n * Separated from listAll because async functions can't use \"arguments\".\r\n * @param ref\r\n * @param accumulator\r\n * @param pageToken\r\n */ async function listAllHelper(ref, accumulator, pageToken) {\n    const opt = {\n        // maxResults is 1000 by default.\n        pageToken\n    };\n    const nextPage = await list$1(ref, opt);\n    accumulator.prefixes.push(...nextPage.prefixes);\n    accumulator.items.push(...nextPage.items);\n    if (nextPage.nextPageToken != null) {\n        await listAllHelper(ref, accumulator, nextPage.nextPageToken);\n    }\n}\n/**\r\n * List items (files) and prefixes (folders) under this storage reference.\r\n *\r\n * List API is only available for Firebase Rules Version 2.\r\n *\r\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\r\n * delimited folder structure.\r\n * Refer to GCS's List API if you want to learn more.\r\n *\r\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\r\n * support objects whose paths end with \"/\" or contain two consecutive\r\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\r\n * list() may fail if there are too many unsupported objects in the bucket.\r\n * @public\r\n *\r\n * @param ref - StorageReference to get list from.\r\n * @param options - See ListOptions for details.\r\n * @returns A Promise that resolves with the items and prefixes.\r\n *      `prefixes` contains references to sub-folders and `items`\r\n *      contains references to objects in this folder. `nextPageToken`\r\n *      can be used to get the rest of the results.\r\n */ function list$1(ref, options) {\n    if (options != null) {\n        if (typeof options.maxResults === \"number\") {\n            validateNumber(\"options.maxResults\", /* minValue= */ 1, /* maxValue= */ 1000, options.maxResults);\n        }\n    }\n    const op = options || {};\n    const requestInfo = list$2(ref.storage, ref._location, /*delimiter= */ \"/\", op.pageToken, op.maxResults);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\r\n * A `Promise` that resolves with the metadata for this object. If this\r\n * object doesn't exist or metadata cannot be retreived, the promise is\r\n * rejected.\r\n * @public\r\n * @param ref - StorageReference to get metadata from.\r\n */ function getMetadata$1(ref) {\n    ref._throwIfRoot(\"getMetadata\");\n    const requestInfo = getMetadata$2(ref.storage, ref._location, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\r\n * Updates the metadata for this object.\r\n * @public\r\n * @param ref - StorageReference to update metadata for.\r\n * @param metadata - The new metadata for the object.\r\n *     Only values that have been explicitly set will be changed. Explicitly\r\n *     setting a value to null will remove the metadata.\r\n * @returns A `Promise` that resolves\r\n *     with the new metadata for this object.\r\n *     See `firebaseStorage.Reference.prototype.getMetadata`\r\n */ function updateMetadata$1(ref, metadata) {\n    ref._throwIfRoot(\"updateMetadata\");\n    const requestInfo = updateMetadata$2(ref.storage, ref._location, metadata, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\r\n * Returns the download URL for the given Reference.\r\n * @public\r\n * @returns A `Promise` that resolves with the download\r\n *     URL for this object.\r\n */ function getDownloadURL$1(ref) {\n    ref._throwIfRoot(\"getDownloadURL\");\n    const requestInfo = getDownloadUrl(ref.storage, ref._location, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection).then((url)=>{\n        if (url === null) {\n            throw noDownloadURL();\n        }\n        return url;\n    });\n}\n/**\r\n * Deletes the object at this location.\r\n * @public\r\n * @param ref - StorageReference for object to delete.\r\n * @returns A `Promise` that resolves if the deletion succeeds.\r\n */ function deleteObject$1(ref) {\n    ref._throwIfRoot(\"deleteObject\");\n    const requestInfo = deleteObject$2(ref.storage, ref._location);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\r\n * Returns reference for object obtained by appending `childPath` to `ref`.\r\n *\r\n * @param ref - StorageReference to get child of.\r\n * @param childPath - Child path from provided ref.\r\n * @returns A reference to the object obtained by\r\n * appending childPath, removing any duplicate, beginning, or trailing\r\n * slashes.\r\n *\r\n */ function _getChild$1(ref, childPath) {\n    const newPath = child(ref._location.path, childPath);\n    const location = new Location(ref._location.bucket, newPath);\n    return new Reference(ref.storage, location);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function isUrl(path) {\n    return /^[A-Za-z]+:\\/\\//.test(path);\n}\n/**\r\n * Returns a firebaseStorage.Reference for the given url.\r\n */ function refFromURL(service, url) {\n    return new Reference(service, url);\n}\n/**\r\n * Returns a firebaseStorage.Reference for the given path in the default\r\n * bucket.\r\n */ function refFromPath(ref, path) {\n    if (ref instanceof FirebaseStorageImpl) {\n        const service = ref;\n        if (service._bucket == null) {\n            throw noDefaultBucket();\n        }\n        const reference = new Reference(service, service._bucket);\n        if (path != null) {\n            return refFromPath(reference, path);\n        } else {\n            return reference;\n        }\n    } else {\n        // ref is a Reference\n        if (path !== undefined) {\n            return _getChild$1(ref, path);\n        } else {\n            return ref;\n        }\n    }\n}\nfunction ref$1(serviceOrRef, pathOrUrl) {\n    if (pathOrUrl && isUrl(pathOrUrl)) {\n        if (serviceOrRef instanceof FirebaseStorageImpl) {\n            return refFromURL(serviceOrRef, pathOrUrl);\n        } else {\n            throw invalidArgument(\"To use ref(service, url), the first argument must be a Storage instance.\");\n        }\n    } else {\n        return refFromPath(serviceOrRef, pathOrUrl);\n    }\n}\nfunction extractBucket(host, config) {\n    const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];\n    if (bucketString == null) {\n        return null;\n    }\n    return Location.makeFromBucketSpec(bucketString, host);\n}\nfunction connectStorageEmulator$1(storage, host, port, options = {}) {\n    storage.host = `${host}:${port}`;\n    storage._protocol = \"http\";\n    const { mockUserToken } = options;\n    if (mockUserToken) {\n        storage._overrideAuthToken = typeof mockUserToken === \"string\" ? mockUserToken : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(mockUserToken, storage.app.options.projectId);\n    }\n}\n/**\r\n * A service that provides Firebase Storage Reference instances.\r\n * @param opt_url - gs:// url to a custom Storage Bucket\r\n *\r\n * @internal\r\n */ class FirebaseStorageImpl {\n    constructor(/**\r\n     * FirebaseApp associated with this StorageService instance.\r\n     */ app, _authProvider, /**\r\n     * @internal\r\n     */ _appCheckProvider, /**\r\n     * @internal\r\n     */ _url, _firebaseVersion){\n        this.app = app;\n        this._authProvider = _authProvider;\n        this._appCheckProvider = _appCheckProvider;\n        this._url = _url;\n        this._firebaseVersion = _firebaseVersion;\n        this._bucket = null;\n        /**\r\n         * This string can be in the formats:\r\n         * - host\r\n         * - host:port\r\n         */ this._host = DEFAULT_HOST;\n        this._protocol = \"https\";\n        this._appId = null;\n        this._deleted = false;\n        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;\n        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;\n        this._requests = new Set();\n        if (_url != null) {\n            this._bucket = Location.makeFromBucketSpec(_url, this._host);\n        } else {\n            this._bucket = extractBucket(this._host, this.app.options);\n        }\n    }\n    /**\r\n     * The host string for this service, in the form of `host` or\r\n     * `host:port`.\r\n     */ get host() {\n        return this._host;\n    }\n    set host(host) {\n        this._host = host;\n        if (this._url != null) {\n            this._bucket = Location.makeFromBucketSpec(this._url, host);\n        } else {\n            this._bucket = extractBucket(host, this.app.options);\n        }\n    }\n    /**\r\n     * The maximum time to retry uploads in milliseconds.\r\n     */ get maxUploadRetryTime() {\n        return this._maxUploadRetryTime;\n    }\n    set maxUploadRetryTime(time) {\n        validateNumber(\"time\", /* minValue=*/ 0, /* maxValue= */ Number.POSITIVE_INFINITY, time);\n        this._maxUploadRetryTime = time;\n    }\n    /**\r\n     * The maximum time to retry operations other than uploads or downloads in\r\n     * milliseconds.\r\n     */ get maxOperationRetryTime() {\n        return this._maxOperationRetryTime;\n    }\n    set maxOperationRetryTime(time) {\n        validateNumber(\"time\", /* minValue=*/ 0, /* maxValue= */ Number.POSITIVE_INFINITY, time);\n        this._maxOperationRetryTime = time;\n    }\n    async _getAuthToken() {\n        if (this._overrideAuthToken) {\n            return this._overrideAuthToken;\n        }\n        const auth = this._authProvider.getImmediate({\n            optional: true\n        });\n        if (auth) {\n            const tokenData = await auth.getToken();\n            if (tokenData !== null) {\n                return tokenData.accessToken;\n            }\n        }\n        return null;\n    }\n    async _getAppCheckToken() {\n        const appCheck = this._appCheckProvider.getImmediate({\n            optional: true\n        });\n        if (appCheck) {\n            const result = await appCheck.getToken();\n            // TODO: What do we want to do if there is an error getting the token?\n            // Context: appCheck.getToken() will never throw even if an error happened. In the error case, a dummy token will be\n            // returned along with an error field describing the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            return result.token;\n        }\n        return null;\n    }\n    /**\r\n     * Stop running requests and prevent more from being created.\r\n     */ _delete() {\n        if (!this._deleted) {\n            this._deleted = true;\n            this._requests.forEach((request)=>request.cancel());\n            this._requests.clear();\n        }\n        return Promise.resolve();\n    }\n    /**\r\n     * Returns a new firebaseStorage.Reference object referencing this StorageService\r\n     * at the given Location.\r\n     */ _makeStorageReference(loc) {\n        return new Reference(this, loc);\n    }\n    /**\r\n     * @param requestInfo - HTTP RequestInfo object\r\n     * @param authToken - Firebase auth token\r\n     */ _makeRequest(requestInfo, requestFactory, authToken, appCheckToken, retry = true) {\n        if (!this._deleted) {\n            const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion, retry);\n            this._requests.add(request);\n            // Request removes itself from set when complete.\n            request.getPromise().then(()=>this._requests.delete(request), ()=>this._requests.delete(request));\n            return request;\n        } else {\n            return new FailRequest(appDeleted());\n        }\n    }\n    async makeRequestWithTokens(requestInfo, requestFactory) {\n        const [authToken, appCheckToken] = await Promise.all([\n            this._getAuthToken(),\n            this._getAppCheckToken()\n        ]);\n        return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();\n    }\n}\nconst name = \"@firebase/storage\";\nconst version = \"0.12.6\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Type constant for Firebase Storage.\r\n */ const STORAGE_TYPE = \"storage\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Downloads the data at the object's location. Returns an error if the object\r\n * is not found.\r\n *\r\n * To use this functionality, you have to whitelist your app's origin in your\r\n * Cloud Storage bucket. See also\r\n * https://cloud.google.com/storage/docs/configuring-cors\r\n *\r\n * @public\r\n * @param ref - StorageReference where data should be downloaded.\r\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\r\n * retrieve.\r\n * @returns A Promise containing the object's bytes\r\n */ function getBytes(ref, maxDownloadSizeBytes) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getBytesInternal(ref, maxDownloadSizeBytes);\n}\n/**\r\n * Uploads data to this object's location.\r\n * The upload is not resumable.\r\n * @public\r\n * @param ref - {@link StorageReference} where data should be uploaded.\r\n * @param data - The data to upload.\r\n * @param metadata - Metadata for the data to upload.\r\n * @returns A Promise containing an UploadResult\r\n */ function uploadBytes(ref, data, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadBytes$1(ref, data, metadata);\n}\n/**\r\n * Uploads a string to this object's location.\r\n * The upload is not resumable.\r\n * @public\r\n * @param ref - {@link StorageReference} where string should be uploaded.\r\n * @param value - The string to upload.\r\n * @param format - The format of the string to upload.\r\n * @param metadata - Metadata for the string to upload.\r\n * @returns A Promise containing an UploadResult\r\n */ function uploadString(ref, value, format, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadString$1(ref, value, format, metadata);\n}\n/**\r\n * Uploads data to this object's location.\r\n * The upload can be paused and resumed, and exposes progress updates.\r\n * @public\r\n * @param ref - {@link StorageReference} where data should be uploaded.\r\n * @param data - The data to upload.\r\n * @param metadata - Metadata for the data to upload.\r\n * @returns An UploadTask\r\n */ function uploadBytesResumable(ref, data, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadBytesResumable$1(ref, data, metadata);\n}\n/**\r\n * A `Promise` that resolves with the metadata for this object. If this\r\n * object doesn't exist or metadata cannot be retreived, the promise is\r\n * rejected.\r\n * @public\r\n * @param ref - {@link StorageReference} to get metadata from.\r\n */ function getMetadata(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getMetadata$1(ref);\n}\n/**\r\n * Updates the metadata for this object.\r\n * @public\r\n * @param ref - {@link StorageReference} to update metadata for.\r\n * @param metadata - The new metadata for the object.\r\n *     Only values that have been explicitly set will be changed. Explicitly\r\n *     setting a value to null will remove the metadata.\r\n * @returns A `Promise` that resolves with the new metadata for this object.\r\n */ function updateMetadata(ref, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return updateMetadata$1(ref, metadata);\n}\n/**\r\n * List items (files) and prefixes (folders) under this storage reference.\r\n *\r\n * List API is only available for Firebase Rules Version 2.\r\n *\r\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\r\n * delimited folder structure.\r\n * Refer to GCS's List API if you want to learn more.\r\n *\r\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\r\n * support objects whose paths end with \"/\" or contain two consecutive\r\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\r\n * list() may fail if there are too many unsupported objects in the bucket.\r\n * @public\r\n *\r\n * @param ref - {@link StorageReference} to get list from.\r\n * @param options - See {@link ListOptions} for details.\r\n * @returns A `Promise` that resolves with the items and prefixes.\r\n *      `prefixes` contains references to sub-folders and `items`\r\n *      contains references to objects in this folder. `nextPageToken`\r\n *      can be used to get the rest of the results.\r\n */ function list(ref, options) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return list$1(ref, options);\n}\n/**\r\n * List all items (files) and prefixes (folders) under this storage reference.\r\n *\r\n * This is a helper method for calling list() repeatedly until there are\r\n * no more results. The default pagination size is 1000.\r\n *\r\n * Note: The results may not be consistent if objects are changed while this\r\n * operation is running.\r\n *\r\n * Warning: `listAll` may potentially consume too many resources if there are\r\n * too many results.\r\n * @public\r\n * @param ref - {@link StorageReference} to get list from.\r\n *\r\n * @returns A `Promise` that resolves with all the items and prefixes under\r\n *      the current storage reference. `prefixes` contains references to\r\n *      sub-directories and `items` contains references to objects in this\r\n *      folder. `nextPageToken` is never returned.\r\n */ function listAll(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return listAll$1(ref);\n}\n/**\r\n * Returns the download URL for the given {@link StorageReference}.\r\n * @public\r\n * @param ref - {@link StorageReference} to get the download URL for.\r\n * @returns A `Promise` that resolves with the download\r\n *     URL for this object.\r\n */ function getDownloadURL(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getDownloadURL$1(ref);\n}\n/**\r\n * Deletes the object at this location.\r\n * @public\r\n * @param ref - {@link StorageReference} for object to delete.\r\n * @returns A `Promise` that resolves if the deletion succeeds.\r\n */ function deleteObject(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return deleteObject$1(ref);\n}\nfunction ref(serviceOrRef, pathOrUrl) {\n    serviceOrRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(serviceOrRef);\n    return ref$1(serviceOrRef, pathOrUrl);\n}\n/**\r\n * @internal\r\n */ function _getChild(ref, childPath) {\n    return _getChild$1(ref, childPath);\n}\n/**\r\n * Gets a {@link FirebaseStorage} instance for the given Firebase app.\r\n * @public\r\n * @param app - Firebase app to get {@link FirebaseStorage} instance for.\r\n * @param bucketUrl - The gs:// url to your Firebase Storage Bucket.\r\n * If not passed, uses the app's default Storage Bucket.\r\n * @returns A {@link FirebaseStorage} instance.\r\n */ function getStorage(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(), bucketUrl) {\n    app = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(app);\n    const storageProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, STORAGE_TYPE);\n    const storageInstance = storageProvider.getImmediate({\n        identifier: bucketUrl\n    });\n    const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)(\"storage\");\n    if (emulator) {\n        connectStorageEmulator(storageInstance, ...emulator);\n    }\n    return storageInstance;\n}\n/**\r\n * Modify this {@link FirebaseStorage} instance to communicate with the Cloud Storage emulator.\r\n *\r\n * @param storage - The {@link FirebaseStorage} instance\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 5001)\r\n * @param options - Emulator options. `options.mockUserToken` is the mock auth\r\n * token to use for unit testing Security Rules.\r\n * @public\r\n */ function connectStorageEmulator(storage, host, port, options = {}) {\n    connectStorageEmulator$1(storage, host, port, options);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Downloads the data at the object's location. Returns an error if the object\r\n * is not found.\r\n *\r\n * To use this functionality, you have to whitelist your app's origin in your\r\n * Cloud Storage bucket. See also\r\n * https://cloud.google.com/storage/docs/configuring-cors\r\n *\r\n * This API is not available in Node.\r\n *\r\n * @public\r\n * @param ref - StorageReference where data should be downloaded.\r\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\r\n * retrieve.\r\n * @returns A Promise that resolves with a Blob containing the object's bytes\r\n */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getBlob(ref, maxDownloadSizeBytes) {\n    throw new Error(\"getBlob() is only available in Browser-like environments\");\n}\n/**\r\n * Downloads the data at the object's location. Raises an error event if the\r\n * object is not found.\r\n *\r\n * This API is only available in Node.\r\n *\r\n * @public\r\n * @param ref - StorageReference where data should be downloaded.\r\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\r\n * retrieve.\r\n * @returns A stream with the object's data as bytes\r\n */ function getStream(ref, maxDownloadSizeBytes) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getStreamInternal(ref, maxDownloadSizeBytes);\n}\n/**\r\n * Cloud Storage for Firebase\r\n *\r\n * @packageDocumentation\r\n */ function factory(container, { instanceIdentifier: url }) {\n    const app = container.getProvider(\"app\").getImmediate();\n    const authProvider = container.getProvider(\"auth-internal\");\n    const appCheckProvider = container.getProvider(\"app-check-internal\");\n    return new FirebaseStorageImpl(app, authProvider, appCheckProvider, url, _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n}\nfunction registerStorage() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(STORAGE_TYPE, factory, \"PUBLIC\" /* ComponentType.PUBLIC */ ).setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\n}\nregisterStorage();\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L25vZGUtZXNtL2luZGV4Lm5vZGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVHO0FBQ29CO0FBQzNFO0FBQ2pCO0FBQ2lCO0FBRWhEOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOztDQUVDLEdBQ0Q7O0NBRUMsR0FDRCxNQUFNYSxlQUFlO0FBQ3JCOztDQUVDLEdBQ0QsTUFBTUMsNEJBQTRCO0FBQ2xDOzs7O0NBSUMsR0FDRCxNQUFNQyxtQ0FBbUMsSUFBSSxLQUFLO0FBQ2xEOzs7O0NBSUMsR0FDRCxNQUFNQyxnQ0FBZ0MsS0FBSyxLQUFLO0FBQ2hEOztDQUVDLEdBQ0QsTUFBTUMsZ0NBQWdDO0FBRXRDOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1DLHFCQUFxQmIseURBQWFBO0lBQ3BDOzs7OztLQUtDLEdBQ0RjLFlBQVlDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxVQUFVLENBQUMsQ0FBRTtRQUNwQyxLQUFLLENBQUNDLFlBQVlILE9BQU8sQ0FBQyxrQkFBa0IsRUFBRUMsUUFBUSxFQUFFLEVBQUVFLFlBQVlILE1BQU0sQ0FBQyxDQUFDO1FBQzlFLElBQUksQ0FBQ0UsT0FBTyxHQUFHQTtRQUNmOztTQUVDLEdBQ0QsSUFBSSxDQUFDRSxVQUFVLEdBQUc7WUFBRUMsZ0JBQWdCO1FBQUs7UUFDekMsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSSxDQUFDTCxPQUFPO1FBQ2hDLGlFQUFpRTtRQUNqRSxpQkFBaUI7UUFDakJNLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUVWLGFBQWFXLFNBQVM7SUFDdEQ7SUFDQSxJQUFJQyxTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUNSLE9BQU87SUFDdkI7SUFDQSxJQUFJUSxPQUFPQSxNQUFNLEVBQUU7UUFDZixJQUFJLENBQUNSLE9BQU8sR0FB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RjtBQUNYO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0csdUJBQXVCbEosT0FBTyxFQUFFMWMsSUFBSSxFQUFFNGlCLElBQUksRUFBRWxCLFVBQVUsQ0FBQyxDQUFDO0lBQzdEaUIseUJBQXlCakcsU0FBUzFjLE1BQU00aUIsTUFBTWxCO0FBQ2xEO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0Q7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsNkRBQTZEO0FBQzdELFNBQVNsVyxRQUFRd1AsR0FBRyxFQUFFL0Usb0JBQW9CO0lBQ3RDLE1BQU0sSUFBSTRQLE1BQU07QUFDcEI7QUFDQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNDLFVBQVU5SyxHQUFHLEVBQUUvRSxvQkFBb0I7SUFDeEMrRSxNQUFNL2Ysa0VBQWtCQSxDQUFDK2Y7SUFDekIsT0FBT3FGLGtCQUFrQnJGLEtBQUsvRTtBQUNsQztBQUVBOzs7O0NBSUMsR0FDRCxTQUFTOFAsUUFBUUMsU0FBUyxFQUFFLEVBQUVDLG9CQUFvQm5vQixHQUFHLEVBQUU7SUFDbkQsTUFBTWlsQixNQUFNaUQsVUFBVUUsV0FBVyxDQUFDLE9BQU9uQyxZQUFZO0lBQ3JELE1BQU1vQyxlQUFlSCxVQUFVRSxXQUFXLENBQUM7SUFDM0MsTUFBTUUsbUJBQW1CSixVQUFVRSxXQUFXLENBQUM7SUFDL0MsT0FBTyxJQUFJOUQsb0JBQW9CVyxLQUFLb0QsY0FBY0Msa0JBQWtCdG9CLEtBQUtoRCxzREFBV0E7QUFDeEY7QUFDQSxTQUFTdXJCO0lBQ0x6ckIsaUVBQWtCQSxDQUFDLElBQUlVLDBEQUFTQSxDQUFDb3BCLGNBQWNxQixTQUFTLFNBQVMsd0JBQXdCLEtBQUlPLG9CQUFvQixDQUFDO0lBQ2xIenJCLDhEQUFlQSxDQUFDa0UsTUFBTWlDO0FBQzFCO0FBQ0FxbEI7QUFFcWYsQ0FDcmYsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hla2hhci1lbnRlcnByaXNlcy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L25vZGUtZXNtL2luZGV4Lm5vZGUuZXNtLmpzPzllOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2dldFByb3ZpZGVyLCBnZXRBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uLCBTREtfVkVSU0lPTiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgY3JlYXRlTW9ja1VzZXJUb2tlbiwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0sIFBhc3NUaHJvdWdoIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB7IGZldGNoIH0gZnJvbSAndW5kaWNpJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBDb25zdGFudHMgdXNlZCBpbiB0aGUgRmlyZWJhc2UgU3RvcmFnZSBsaWJyYXJ5LlxyXG4gKi9cclxuLyoqXHJcbiAqIERvbWFpbiBuYW1lIGZvciBmaXJlYmFzZSBzdG9yYWdlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9IT1NUID0gJ2ZpcmViYXNlc3RvcmFnZS5nb29nbGVhcGlzLmNvbSc7XHJcbi8qKlxyXG4gKiBUaGUga2V5IGluIEZpcmViYXNlIGNvbmZpZyBqc29uIGZvciB0aGUgc3RvcmFnZSBidWNrZXQuXHJcbiAqL1xyXG5jb25zdCBDT05GSUdfU1RPUkFHRV9CVUNLRVRfS0VZID0gJ3N0b3JhZ2VCdWNrZXQnO1xyXG4vKipcclxuICogMiBtaW51dGVzXHJcbiAqXHJcbiAqIFRoZSB0aW1lb3V0IGZvciBhbGwgb3BlcmF0aW9ucyBleGNlcHQgdXBsb2FkLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9NQVhfT1BFUkFUSU9OX1JFVFJZX1RJTUUgPSAyICogNjAgKiAxMDAwO1xyXG4vKipcclxuICogMTAgbWludXRlc1xyXG4gKlxyXG4gKiBUaGUgdGltZW91dCBmb3IgdXBsb2FkLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9NQVhfVVBMT0FEX1JFVFJZX1RJTUUgPSAxMCAqIDYwICogMTAwMDtcclxuLyoqXHJcbiAqIDEgc2Vjb25kXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX01JTl9TTEVFUF9USU1FX01JTExJUyA9IDEwMDA7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBlcnJvciByZXR1cm5lZCBieSB0aGUgRmlyZWJhc2UgU3RvcmFnZSBTREsuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFN0b3JhZ2VFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29kZSAtIEEgYFN0b3JhZ2VFcnJvckNvZGVgIHN0cmluZyB0byBiZSBwcmVmaXhlZCB3aXRoICdzdG9yYWdlLycgYW5kXHJcbiAgICAgKiAgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgbWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlICAtIEVycm9yIG1lc3NhZ2UuXHJcbiAgICAgKiBAcGFyYW0gc3RhdHVzXyAtIENvcnJlc3BvbmRpbmcgSFRUUCBTdGF0dXMgQ29kZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBzdGF0dXNfID0gMCkge1xyXG4gICAgICAgIHN1cGVyKHByZXBlbmRDb2RlKGNvZGUpLCBgRmlyZWJhc2UgU3RvcmFnZTogJHttZXNzYWdlfSAoJHtwcmVwZW5kQ29kZShjb2RlKX0pYCk7XHJcbiAgICAgICAgdGhpcy5zdGF0dXNfID0gc3RhdHVzXztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9yZXMgY3VzdG9tIGVycm9yIGRhdGEgdW5pcXVlIHRvIHRoZSBgU3RvcmFnZUVycm9yYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSB7IHNlcnZlclJlc3BvbnNlOiBudWxsIH07XHJcbiAgICAgICAgdGhpcy5fYmFzZU1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2U7XHJcbiAgICAgICAgLy8gV2l0aG91dCB0aGlzLCBgaW5zdGFuY2VvZiBTdG9yYWdlRXJyb3JgLCBpbiB0ZXN0cyBmb3IgZXhhbXBsZSxcclxuICAgICAgICAvLyByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBTdG9yYWdlRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxuICAgIGdldCBzdGF0dXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzXztcclxuICAgIH1cclxuICAgIHNldCBzdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0dXNfID0gc3RhdHVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyBhIGBTdG9yYWdlRXJyb3JDb2RlYCBhZ2FpbnN0IHRoaXMgZXJyb3IncyBjb2RlLCBmaWx0ZXJpbmcgb3V0IHRoZSBwcmVmaXguXHJcbiAgICAgKi9cclxuICAgIF9jb2RlRXF1YWxzKGNvZGUpIHtcclxuICAgICAgICByZXR1cm4gcHJlcGVuZENvZGUoY29kZSkgPT09IHRoaXMuY29kZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9uYWwgcmVzcG9uc2UgbWVzc2FnZSB0aGF0IHdhcyBhZGRlZCBieSB0aGUgc2VydmVyLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2VydmVyUmVzcG9uc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRGF0YS5zZXJ2ZXJSZXNwb25zZTtcclxuICAgIH1cclxuICAgIHNldCBzZXJ2ZXJSZXNwb25zZShzZXJ2ZXJSZXNwb25zZSkge1xyXG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YS5zZXJ2ZXJSZXNwb25zZSA9IHNlcnZlclJlc3BvbnNlO1xyXG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7dGhpcy5fYmFzZU1lc3NhZ2V9XFxuJHt0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2V9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX2Jhc2VNZXNzYWdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHB1YmxpY1xyXG4gKiBFcnJvciBjb2RlcyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBgU3RvcmFnZUVycm9yYCBvYmplY3RzLlxyXG4gKi9cclxudmFyIFN0b3JhZ2VFcnJvckNvZGU7XHJcbihmdW5jdGlvbiAoU3RvcmFnZUVycm9yQ29kZSkge1xyXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gYWxsIHBsYXRmb3Jtc1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJPQkpFQ1RfTk9UX0ZPVU5EXCJdID0gXCJvYmplY3Qtbm90LWZvdW5kXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiQlVDS0VUX05PVF9GT1VORFwiXSA9IFwiYnVja2V0LW5vdC1mb3VuZFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlBST0pFQ1RfTk9UX0ZPVU5EXCJdID0gXCJwcm9qZWN0LW5vdC1mb3VuZFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlFVT1RBX0VYQ0VFREVEXCJdID0gXCJxdW90YS1leGNlZWRlZFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlVOQVVUSEVOVElDQVRFRFwiXSA9IFwidW5hdXRoZW50aWNhdGVkXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5BVVRIT1JJWkVEXCJdID0gXCJ1bmF1dGhvcml6ZWRcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTkFVVEhPUklaRURfQVBQXCJdID0gXCJ1bmF1dGhvcml6ZWQtYXBwXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiUkVUUllfTElNSVRfRVhDRUVERURcIl0gPSBcInJldHJ5LWxpbWl0LWV4Y2VlZGVkXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9DSEVDS1NVTVwiXSA9IFwiaW52YWxpZC1jaGVja3N1bVwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIkNBTkNFTEVEXCJdID0gXCJjYW5jZWxlZFwiO1xyXG4gICAgLy8gSlMgc3BlY2lmaWNcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0VWRU5UX05BTUVcIl0gPSBcImludmFsaWQtZXZlbnQtbmFtZVwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfVVJMXCJdID0gXCJpbnZhbGlkLXVybFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfREVGQVVMVF9CVUNLRVRcIl0gPSBcImludmFsaWQtZGVmYXVsdC1idWNrZXRcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJOT19ERUZBVUxUX0JVQ0tFVFwiXSA9IFwibm8tZGVmYXVsdC1idWNrZXRcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJDQU5OT1RfU0xJQ0VfQkxPQlwiXSA9IFwiY2Fubm90LXNsaWNlLWJsb2JcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJTRVJWRVJfRklMRV9XUk9OR19TSVpFXCJdID0gXCJzZXJ2ZXItZmlsZS13cm9uZy1zaXplXCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiTk9fRE9XTkxPQURfVVJMXCJdID0gXCJuby1kb3dubG9hZC11cmxcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gXCJpbnZhbGlkLWFyZ3VtZW50XCI7XHJcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVF9DT1VOVFwiXSA9IFwiaW52YWxpZC1hcmd1bWVudC1jb3VudFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIkFQUF9ERUxFVEVEXCJdID0gXCJhcHAtZGVsZXRlZFwiO1xyXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfUk9PVF9PUEVSQVRJT05cIl0gPSBcImludmFsaWQtcm9vdC1vcGVyYXRpb25cIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0ZPUk1BVFwiXSA9IFwiaW52YWxpZC1mb3JtYXRcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlRFUk5BTF9FUlJPUlwiXSA9IFwiaW50ZXJuYWwtZXJyb3JcIjtcclxuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9FTlZJUk9OTUVOVFwiXSA9IFwidW5zdXBwb3J0ZWQtZW52aXJvbm1lbnRcIjtcclxufSkoU3RvcmFnZUVycm9yQ29kZSB8fCAoU3RvcmFnZUVycm9yQ29kZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIHByZXBlbmRDb2RlKGNvZGUpIHtcclxuICAgIHJldHVybiAnc3RvcmFnZS8nICsgY29kZTtcclxufVxyXG5mdW5jdGlvbiB1bmtub3duKCkge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLCBwbGVhc2UgY2hlY2sgdGhlIGVycm9yIHBheWxvYWQgZm9yICcgK1xyXG4gICAgICAgICdzZXJ2ZXIgcmVzcG9uc2UuJztcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuVU5LTk9XTiwgbWVzc2FnZSk7XHJcbn1cclxuZnVuY3Rpb24gb2JqZWN0Tm90Rm91bmQocGF0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5PQkpFQ1RfTk9UX0ZPVU5ELCBcIk9iamVjdCAnXCIgKyBwYXRoICsgXCInIGRvZXMgbm90IGV4aXN0LlwiKTtcclxufVxyXG5mdW5jdGlvbiBxdW90YUV4Y2VlZGVkKGJ1Y2tldCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5RVU9UQV9FWENFRURFRCwgXCJRdW90YSBmb3IgYnVja2V0ICdcIiArXHJcbiAgICAgICAgYnVja2V0ICtcclxuICAgICAgICBcIicgZXhjZWVkZWQsIHBsZWFzZSB2aWV3IHF1b3RhIG9uIFwiICtcclxuICAgICAgICAnaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL3ByaWNpbmcvLicpO1xyXG59XHJcbmZ1bmN0aW9uIHVuYXV0aGVudGljYXRlZCgpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnVXNlciBpcyBub3QgYXV0aGVudGljYXRlZCwgcGxlYXNlIGF1dGhlbnRpY2F0ZSB1c2luZyBGaXJlYmFzZSAnICtcclxuICAgICAgICAnQXV0aGVudGljYXRpb24gYW5kIHRyeSBhZ2Fpbi4nO1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTkFVVEhFTlRJQ0FURUQsIG1lc3NhZ2UpO1xyXG59XHJcbmZ1bmN0aW9uIHVuYXV0aG9yaXplZEFwcCgpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuVU5BVVRIT1JJWkVEX0FQUCwgJ1RoaXMgYXBwIGRvZXMgbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgRmlyZWJhc2UgU3RvcmFnZSBvbiB0aGlzIHByb2plY3QuJyk7XHJcbn1cclxuZnVuY3Rpb24gdW5hdXRob3JpemVkKHBhdGgpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuVU5BVVRIT1JJWkVELCBcIlVzZXIgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyAnXCIgKyBwYXRoICsgXCInLlwiKTtcclxufVxyXG5mdW5jdGlvbiByZXRyeUxpbWl0RXhjZWVkZWQoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlJFVFJZX0xJTUlUX0VYQ0VFREVELCAnTWF4IHJldHJ5IHRpbWUgZm9yIG9wZXJhdGlvbiBleGNlZWRlZCwgcGxlYXNlIHRyeSBhZ2Fpbi4nKTtcclxufVxyXG5mdW5jdGlvbiBjYW5jZWxlZCgpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuQ0FOQ0VMRUQsICdVc2VyIGNhbmNlbGVkIHRoZSB1cGxvYWQvZG93bmxvYWQuJyk7XHJcbn1cclxuZnVuY3Rpb24gaW52YWxpZFVybCh1cmwpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5WQUxJRF9VUkwsIFwiSW52YWxpZCBVUkwgJ1wiICsgdXJsICsgXCInLlwiKTtcclxufVxyXG5mdW5jdGlvbiBpbnZhbGlkRGVmYXVsdEJ1Y2tldChidWNrZXQpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5WQUxJRF9ERUZBVUxUX0JVQ0tFVCwgXCJJbnZhbGlkIGRlZmF1bHQgYnVja2V0ICdcIiArIGJ1Y2tldCArIFwiJy5cIik7XHJcbn1cclxuZnVuY3Rpb24gbm9EZWZhdWx0QnVja2V0KCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5OT19ERUZBVUxUX0JVQ0tFVCwgJ05vIGRlZmF1bHQgYnVja2V0ICcgK1xyXG4gICAgICAgIFwiZm91bmQuIERpZCB5b3Ugc2V0IHRoZSAnXCIgK1xyXG4gICAgICAgIENPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVkgK1xyXG4gICAgICAgIFwiJyBwcm9wZXJ0eSB3aGVuIGluaXRpYWxpemluZyB0aGUgYXBwP1wiKTtcclxufVxyXG5mdW5jdGlvbiBjYW5ub3RTbGljZUJsb2IoKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLkNBTk5PVF9TTElDRV9CTE9CLCAnQ2Fubm90IHNsaWNlIGJsb2IgZm9yIHVwbG9hZC4gUGxlYXNlIHJldHJ5IHRoZSB1cGxvYWQuJyk7XHJcbn1cclxuZnVuY3Rpb24gc2VydmVyRmlsZVdyb25nU2l6ZSgpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuU0VSVkVSX0ZJTEVfV1JPTkdfU0laRSwgJ1NlcnZlciByZWNvcmRlZCBpbmNvcnJlY3QgdXBsb2FkIGZpbGUgc2l6ZSwgcGxlYXNlIHJldHJ5IHRoZSB1cGxvYWQuJyk7XHJcbn1cclxuZnVuY3Rpb24gbm9Eb3dubG9hZFVSTCgpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuTk9fRE9XTkxPQURfVVJMLCAnVGhlIGdpdmVuIGZpbGUgZG9lcyBub3QgaGF2ZSBhbnkgZG93bmxvYWQgVVJMcy4nKTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnZhbGlkQXJndW1lbnQobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBtZXNzYWdlKTtcclxufVxyXG5mdW5jdGlvbiBhcHBEZWxldGVkKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5BUFBfREVMRVRFRCwgJ1RoZSBGaXJlYmFzZSBhcHAgd2FzIGRlbGV0ZWQuJyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0aGF0IHdhcyBpbnZhbGlkLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGludmFsaWRSb290T3BlcmF0aW9uKG5hbWUpIHtcclxuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5WQUxJRF9ST09UX09QRVJBVElPTiwgXCJUaGUgb3BlcmF0aW9uICdcIiArXHJcbiAgICAgICAgbmFtZSArXHJcbiAgICAgICAgXCInIGNhbm5vdCBiZSBwZXJmb3JtZWQgb24gYSByb290IHJlZmVyZW5jZSwgY3JlYXRlIGEgbm9uLXJvb3QgXCIgK1xyXG4gICAgICAgIFwicmVmZXJlbmNlIHVzaW5nIGNoaWxkLCBzdWNoIGFzIC5jaGlsZCgnZmlsZS5wbmcnKS5cIik7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRoYXQgd2FzIG5vdCB2YWxpZC5cclxuICogQHBhcmFtIG1lc3NhZ2UgLSBBIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgZm9ybWF0IHZpb2xhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGludmFsaWRGb3JtYXQoZm9ybWF0LCBtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfRk9STUFULCBcIlN0cmluZyBkb2VzIG5vdCBtYXRjaCBmb3JtYXQgJ1wiICsgZm9ybWF0ICsgXCInOiBcIiArIG1lc3NhZ2UpO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEEgbWVzc2FnZSBkZXNjcmliaW5nIHRoZSBpbnRlcm5hbCBlcnJvci5cclxuICovXHJcbmZ1bmN0aW9uIGludGVybmFsRXJyb3IobWVzc2FnZSkge1xyXG4gICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SLCAnSW50ZXJuYWwgZXJyb3I6ICcgKyBtZXNzYWdlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmlyZWJhc2UgU3RvcmFnZSBsb2NhdGlvbiBkYXRhLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIExvY2F0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGJ1Y2tldCwgcGF0aCkge1xyXG4gICAgICAgIHRoaXMuYnVja2V0ID0gYnVja2V0O1xyXG4gICAgICAgIHRoaXMucGF0aF8gPSBwYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aF87XHJcbiAgICB9XHJcbiAgICBnZXQgaXNSb290KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgZnVsbFNlcnZlclVybCgpIHtcclxuICAgICAgICBjb25zdCBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XHJcbiAgICAgICAgcmV0dXJuICcvYi8nICsgZW5jb2RlKHRoaXMuYnVja2V0KSArICcvby8nICsgZW5jb2RlKHRoaXMucGF0aCk7XHJcbiAgICB9XHJcbiAgICBidWNrZXRPbmx5U2VydmVyVXJsKCkge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcclxuICAgICAgICByZXR1cm4gJy9iLycgKyBlbmNvZGUodGhpcy5idWNrZXQpICsgJy9vJztcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYWtlRnJvbUJ1Y2tldFNwZWMoYnVja2V0U3RyaW5nLCBob3N0KSB7XHJcbiAgICAgICAgbGV0IGJ1Y2tldExvY2F0aW9uO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGJ1Y2tldExvY2F0aW9uID0gTG9jYXRpb24ubWFrZUZyb21VcmwoYnVja2V0U3RyaW5nLCBob3N0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gTm90IHZhbGlkIFVSTCwgdXNlIGFzLWlzLiBUaGlzIGxldHMgeW91IHB1dCBiYXJlIGJ1Y2tldCBuYW1lcyBpblxyXG4gICAgICAgICAgICAvLyBjb25maWcuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9jYXRpb24oYnVja2V0U3RyaW5nLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWNrZXRMb2NhdGlvbi5wYXRoID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYnVja2V0TG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkRGVmYXVsdEJ1Y2tldChidWNrZXRTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBtYWtlRnJvbVVybCh1cmwsIGhvc3QpIHtcclxuICAgICAgICBsZXQgbG9jYXRpb24gPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGJ1Y2tldERvbWFpbiA9ICcoW0EtWmEtejAtOS5cXFxcLV9dKyknO1xyXG4gICAgICAgIGZ1bmN0aW9uIGdzTW9kaWZ5KGxvYykge1xyXG4gICAgICAgICAgICBpZiAobG9jLnBhdGguY2hhckF0KGxvYy5wYXRoLmxlbmd0aCAtIDEpID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgIGxvYy5wYXRoXyA9IGxvYy5wYXRoXy5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZ3NQYXRoID0gJygvKC4qKSk/JCc7XHJcbiAgICAgICAgY29uc3QgZ3NSZWdleCA9IG5ldyBSZWdFeHAoJ15nczovLycgKyBidWNrZXREb21haW4gKyBnc1BhdGgsICdpJyk7XHJcbiAgICAgICAgY29uc3QgZ3NJbmRpY2VzID0geyBidWNrZXQ6IDEsIHBhdGg6IDMgfTtcclxuICAgICAgICBmdW5jdGlvbiBodHRwTW9kaWZ5KGxvYykge1xyXG4gICAgICAgICAgICBsb2MucGF0aF8gPSBkZWNvZGVVUklDb21wb25lbnQobG9jLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ3ZbQS1aYS16MC05X10rJztcclxuICAgICAgICBjb25zdCBmaXJlYmFzZVN0b3JhZ2VIb3N0ID0gaG9zdC5yZXBsYWNlKC9bLl0vZywgJ1xcXFwuJyk7XHJcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTdG9yYWdlUGF0aCA9ICcoLyhbXj8jXSopLiopPyQnO1xyXG4gICAgICAgIGNvbnN0IGZpcmViYXNlU3RvcmFnZVJlZ0V4cCA9IG5ldyBSZWdFeHAoYF5odHRwcz86Ly8ke2ZpcmViYXNlU3RvcmFnZUhvc3R9LyR7dmVyc2lvbn0vYi8ke2J1Y2tldERvbWFpbn0vbyR7ZmlyZWJhc2VTdG9yYWdlUGF0aH1gLCAnaScpO1xyXG4gICAgICAgIGNvbnN0IGZpcmViYXNlU3RvcmFnZUluZGljZXMgPSB7IGJ1Y2tldDogMSwgcGF0aDogMyB9O1xyXG4gICAgICAgIGNvbnN0IGNsb3VkU3RvcmFnZUhvc3QgPSBob3N0ID09PSBERUZBVUxUX0hPU1RcclxuICAgICAgICAgICAgPyAnKD86c3RvcmFnZS5nb29nbGVhcGlzLmNvbXxzdG9yYWdlLmNsb3VkLmdvb2dsZS5jb20pJ1xyXG4gICAgICAgICAgICA6IGhvc3Q7XHJcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlUGF0aCA9ICcoW14/I10qKSc7XHJcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlUmVnRXhwID0gbmV3IFJlZ0V4cChgXmh0dHBzPzovLyR7Y2xvdWRTdG9yYWdlSG9zdH0vJHtidWNrZXREb21haW59LyR7Y2xvdWRTdG9yYWdlUGF0aH1gLCAnaScpO1xyXG4gICAgICAgIGNvbnN0IGNsb3VkU3RvcmFnZUluZGljZXMgPSB7IGJ1Y2tldDogMSwgcGF0aDogMiB9O1xyXG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IFtcclxuICAgICAgICAgICAgeyByZWdleDogZ3NSZWdleCwgaW5kaWNlczogZ3NJbmRpY2VzLCBwb3N0TW9kaWZ5OiBnc01vZGlmeSB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZWdleDogZmlyZWJhc2VTdG9yYWdlUmVnRXhwLFxyXG4gICAgICAgICAgICAgICAgaW5kaWNlczogZmlyZWJhc2VTdG9yYWdlSW5kaWNlcyxcclxuICAgICAgICAgICAgICAgIHBvc3RNb2RpZnk6IGh0dHBNb2RpZnlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVnZXg6IGNsb3VkU3RvcmFnZVJlZ0V4cCxcclxuICAgICAgICAgICAgICAgIGluZGljZXM6IGNsb3VkU3RvcmFnZUluZGljZXMsXHJcbiAgICAgICAgICAgICAgICBwb3N0TW9kaWZ5OiBodHRwTW9kaWZ5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlcyA9IGdyb3VwLnJlZ2V4LmV4ZWModXJsKTtcclxuICAgICAgICAgICAgaWYgKGNhcHR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidWNrZXRWYWx1ZSA9IGNhcHR1cmVzW2dyb3VwLmluZGljZXMuYnVja2V0XTtcclxuICAgICAgICAgICAgICAgIGxldCBwYXRoVmFsdWUgPSBjYXB0dXJlc1tncm91cC5pbmRpY2VzLnBhdGhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbmV3IExvY2F0aW9uKGJ1Y2tldFZhbHVlLCBwYXRoVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAucG9zdE1vZGlmeShsb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkVXJsKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQSByZXF1ZXN0IHdob3NlIHByb21pc2UgYWx3YXlzIGZhaWxzLlxyXG4gKi9cclxuY2xhc3MgRmFpbFJlcXVlc3Qge1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnByb21pc2VfID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcm9taXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VfO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBjYW5jZWwoX2FwcERlbGV0ZSA9IGZhbHNlKSB7IH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQWNjZXB0cyBhIGNhbGxiYWNrIGZvciBhbiBhY3Rpb24gdG8gcGVyZm9ybSAoYGRvUmVxdWVzdGApLFxyXG4gKiBhbmQgdGhlbiBhIGNhbGxiYWNrIGZvciB3aGVuIHRoZSBiYWNrb2ZmIGhhcyBjb21wbGV0ZWQgKGBiYWNrb2ZmQ29tcGxldGVDYmApLlxyXG4gKiBUaGUgY2FsbGJhY2sgc2VudCB0byBzdGFydCByZXF1aXJlcyBhbiBhcmd1bWVudCB0byBjYWxsIChgb25SZXF1ZXN0Q29tcGxldGVgKS5cclxuICogV2hlbiBgc3RhcnRgIGNhbGxzIGBkb1JlcXVlc3RgLCBpdCBwYXNzZXMgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgcmVxdWVzdCBoYXNcclxuICogY29tcGxldGVkLCBgb25SZXF1ZXN0Q29tcGxldGVgLiBCYXNlZCBvbiB0aGlzLCB0aGUgYmFja29mZiBjb250aW51ZXMsIHdpdGhcclxuICogYW5vdGhlciBjYWxsIHRvIGBkb1JlcXVlc3RgIGFuZCB0aGUgYWJvdmUgbG9vcCBjb250aW51ZXMgdW50aWwgdGhlIHRpbWVvdXRcclxuICogaXMgaGl0LCBvciBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugb2NjdXJzLlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQHBhcmFtIGRvUmVxdWVzdCBDYWxsYmFjayB0byBwZXJmb3JtIHJlcXVlc3RcclxuICogQHBhcmFtIGJhY2tvZmZDb21wbGV0ZUNiIENhbGxiYWNrIHRvIGNhbGwgd2hlbiBiYWNrb2ZmIGhhcyBiZWVuIGNvbXBsZXRlZFxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnQoZG9SZXF1ZXN0LCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuYmFja29mZkNvbXBsZXRlQ2IsIHRpbWVvdXQpIHtcclxuICAgIC8vIFRPRE8oYW5keXNvdG8pOiBtYWtlIHRoaXMgY29kZSBjbGVhbmVyIChwcm9iYWJseSByZWZhY3RvciBpbnRvIGFuIGFjdHVhbFxyXG4gICAgLy8gdHlwZSBpbnN0ZWFkIG9mIGEgYnVuY2ggb2YgZnVuY3Rpb25zIHdpdGggc3RhdGUgc2hhcmVkIGluIHRoZSBjbG9zdXJlKVxyXG4gICAgbGV0IHdhaXRTZWNvbmRzID0gMTtcclxuICAgIC8vIFdvdWxkIHR5cGUgdGhpcyBhcyBcIm51bWJlclwiIGJ1dCB0aGF0IGRvZXNuJ3Qgd29yayBmb3IgTm9kZSBzbyDCr1xcXyjjg4QpXy/Cr1xyXG4gICAgLy8gVE9ETzogZmluZCBhIHdheSB0byBleGNsdWRlIE5vZGUgdHlwZSBkZWZpbml0aW9uIGZvciBzdG9yYWdlIGJlY2F1c2Ugc3RvcmFnZSBvbmx5IHdvcmtzIGluIGJyb3dzZXJcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBsZXQgcmV0cnlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGxldCBnbG9iYWxUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgbGV0IGhpdFRpbWVvdXQgPSBmYWxzZTtcclxuICAgIGxldCBjYW5jZWxTdGF0ZSA9IDA7XHJcbiAgICBmdW5jdGlvbiBjYW5jZWxlZCgpIHtcclxuICAgICAgICByZXR1cm4gY2FuY2VsU3RhdGUgPT09IDI7XHJcbiAgICB9XHJcbiAgICBsZXQgdHJpZ2dlcmVkQ2FsbGJhY2sgPSBmYWxzZTtcclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJDYWxsYmFjayguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKCF0cmlnZ2VyZWRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0cmlnZ2VyZWRDYWxsYmFjayA9IHRydWU7XHJcbiAgICAgICAgICAgIGJhY2tvZmZDb21wbGV0ZUNiLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNhbGxXaXRoRGVsYXkobWlsbGlzKSB7XHJcbiAgICAgICAgcmV0cnlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgcmV0cnlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICBkb1JlcXVlc3QocmVzcG9uc2VIYW5kbGVyLCBjYW5jZWxlZCgpKTtcclxuICAgICAgICB9LCBtaWxsaXMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJHbG9iYWxUaW1lb3V0KCkge1xyXG4gICAgICAgIGlmIChnbG9iYWxUaW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGdsb2JhbFRpbWVvdXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVzcG9uc2VIYW5kbGVyKHN1Y2Nlc3MsIC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAodHJpZ2dlcmVkQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY2xlYXJHbG9iYWxUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgY2xlYXJHbG9iYWxUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgIHRyaWdnZXJDYWxsYmFjay5jYWxsKG51bGwsIHN1Y2Nlc3MsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG11c3RTdG9wID0gY2FuY2VsZWQoKSB8fCBoaXRUaW1lb3V0O1xyXG4gICAgICAgIGlmIChtdXN0U3RvcCkge1xyXG4gICAgICAgICAgICBjbGVhckdsb2JhbFRpbWVvdXQoKTtcclxuICAgICAgICAgICAgdHJpZ2dlckNhbGxiYWNrLmNhbGwobnVsbCwgc3VjY2VzcywgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdhaXRTZWNvbmRzIDwgNjQpIHtcclxuICAgICAgICAgICAgLyogVE9ETyhhbmR5c290byk6IGRvbid0IGJhY2sgb2ZmIHNvIHF1aWNrbHkgaWYgd2Uga25vdyB3ZSdyZSBvZmZsaW5lLiAqL1xyXG4gICAgICAgICAgICB3YWl0U2Vjb25kcyAqPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgd2FpdE1pbGxpcztcclxuICAgICAgICBpZiAoY2FuY2VsU3RhdGUgPT09IDEpIHtcclxuICAgICAgICAgICAgY2FuY2VsU3RhdGUgPSAyO1xyXG4gICAgICAgICAgICB3YWl0TWlsbGlzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhaXRNaWxsaXMgPSAod2FpdFNlY29uZHMgKyBNYXRoLnJhbmRvbSgpKSAqIDEwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxXaXRoRGVsYXkod2FpdE1pbGxpcyk7XHJcbiAgICB9XHJcbiAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gc3RvcCh3YXNUaW1lb3V0KSB7XHJcbiAgICAgICAgaWYgKHN0b3BwZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICBjbGVhckdsb2JhbFRpbWVvdXQoKTtcclxuICAgICAgICBpZiAodHJpZ2dlcmVkQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmV0cnlUaW1lb3V0SWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKCF3YXNUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZW91dElkKTtcclxuICAgICAgICAgICAgY2FsbFdpdGhEZWxheSgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghd2FzVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsU3RhdGUgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FsbFdpdGhEZWxheSgwKTtcclxuICAgIGdsb2JhbFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGhpdFRpbWVvdXQgPSB0cnVlO1xyXG4gICAgICAgIHN0b3AodHJ1ZSk7XHJcbiAgICB9LCB0aW1lb3V0KTtcclxuICAgIHJldHVybiBzdG9wO1xyXG59XHJcbi8qKlxyXG4gKiBTdG9wcyB0aGUgcmV0cnkgbG9vcCBmcm9tIHJlcGVhdGluZy5cclxuICogSWYgdGhlIGZ1bmN0aW9uIGlzIGN1cnJlbnRseSBcImluIGJldHdlZW5cIiByZXRyaWVzLCBpdCBpcyBpbnZva2VkIGltbWVkaWF0ZWx5XHJcbiAqIHdpdGggdGhlIHNlY29uZCBwYXJhbWV0ZXIgYXMgXCJ0cnVlXCIuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnZva2VkIG9uY2UgbW9yZVxyXG4gKiBhZnRlciB0aGUgY3VycmVudCBpbnZvY2F0aW9uIGZpbmlzaGVzIGlmZiB0aGUgY3VycmVudCBpbnZvY2F0aW9uIHdvdWxkIGhhdmVcclxuICogdHJpZ2dlcmVkIGFub3RoZXIgcmV0cnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdG9wKGlkKSB7XHJcbiAgICBpZChmYWxzZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNKdXN0RGVmKHApIHtcclxuICAgIHJldHVybiBwICE9PSB2b2lkIDA7XHJcbn1cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZnVuY3Rpb24gaXNGdW5jdGlvbihwKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuZnVuY3Rpb24gaXNOb25BcnJheU9iamVjdChwKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHApO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RyaW5nKHApIHtcclxuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ3N0cmluZycgfHwgcCBpbnN0YW5jZW9mIFN0cmluZztcclxufVxyXG5mdW5jdGlvbiBpc05hdGl2ZUJsb2IocCkge1xyXG4gICAgcmV0dXJuIGlzTmF0aXZlQmxvYkRlZmluZWQoKSAmJiBwIGluc3RhbmNlb2YgQmxvYjtcclxufVxyXG5mdW5jdGlvbiBpc05hdGl2ZUJsb2JEZWZpbmVkKCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihhcmd1bWVudCwgbWluVmFsdWUsIG1heFZhbHVlLCB2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlIDwgbWluVmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBpbnZhbGlkQXJndW1lbnQoYEludmFsaWQgdmFsdWUgZm9yICcke2FyZ3VtZW50fScuIEV4cGVjdGVkICR7bWluVmFsdWV9IG9yIGdyZWF0ZXIuYCk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPiBtYXhWYWx1ZSkge1xyXG4gICAgICAgIHRocm93IGludmFsaWRBcmd1bWVudChgSW52YWxpZCB2YWx1ZSBmb3IgJyR7YXJndW1lbnR9Jy4gRXhwZWN0ZWQgJHttYXhWYWx1ZX0gb3IgbGVzcy5gKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlVXJsKHVybFBhcnQsIGhvc3QsIHByb3RvY29sKSB7XHJcbiAgICBsZXQgb3JpZ2luID0gaG9zdDtcclxuICAgIGlmIChwcm90b2NvbCA9PSBudWxsKSB7XHJcbiAgICAgICAgb3JpZ2luID0gYGh0dHBzOi8vJHtob3N0fWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9Oi8vJHtvcmlnaW59L3YwJHt1cmxQYXJ0fWA7XHJcbn1cclxuZnVuY3Rpb24gbWFrZVF1ZXJ5U3RyaW5nKHBhcmFtcykge1xyXG4gICAgY29uc3QgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xyXG4gICAgbGV0IHF1ZXJ5UGFydCA9ICc/JztcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0UGFydCA9IGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHBhcmFtc1trZXldKTtcclxuICAgICAgICAgICAgcXVlcnlQYXJ0ID0gcXVlcnlQYXJ0ICsgbmV4dFBhcnQgKyAnJic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2hvcCBvZmYgdGhlIGV4dHJhICcmJyBvciAnPycgb24gdGhlIGVuZFxyXG4gICAgcXVlcnlQYXJ0ID0gcXVlcnlQYXJ0LnNsaWNlKDAsIC0xKTtcclxuICAgIHJldHVybiBxdWVyeVBhcnQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEVycm9yIGNvZGVzIGZvciByZXF1ZXN0cyBtYWRlIGJ5IHRoZSB0aGUgWGhySW8gd3JhcHBlci5cclxuICovXHJcbnZhciBFcnJvckNvZGU7XHJcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XHJcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTk9fRVJST1JcIl0gPSAwXSA9IFwiTk9fRVJST1JcIjtcclxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gMV0gPSBcIk5FVFdPUktfRVJST1JcIjtcclxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJBQk9SVFwiXSA9IDJdID0gXCJBQk9SVFwiO1xyXG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDaGVja3MgdGhlIHN0YXR1cyBjb2RlIHRvIHNlZSBpZiB0aGUgYWN0aW9uIHNob3VsZCBiZSByZXRyaWVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3RhdHVzIEN1cnJlbnQgSFRUUCBzdGF0dXMgY29kZSByZXR1cm5lZCBieSBzZXJ2ZXIuXHJcbiAqIEBwYXJhbSBhZGRpdGlvbmFsUmV0cnlDb2RlcyBhZGRpdGlvbmFsIHJldHJ5IGNvZGVzIHRvIGNoZWNrIGFnYWluc3RcclxuICovXHJcbmZ1bmN0aW9uIGlzUmV0cnlTdGF0dXNDb2RlKHN0YXR1cywgYWRkaXRpb25hbFJldHJ5Q29kZXMpIHtcclxuICAgIC8vIFRoZSBjb2RlcyBmb3Igd2hpY2ggdG8gcmV0cnkgY2FtZSBmcm9tIHRoaXMgcGFnZTpcclxuICAgIC8vIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9zdG9yYWdlL2RvY3MvZXhwb25lbnRpYWwtYmFja29mZlxyXG4gICAgY29uc3QgaXNGaXZlSHVuZHJlZENvZGUgPSBzdGF0dXMgPj0gNTAwICYmIHN0YXR1cyA8IDYwMDtcclxuICAgIGNvbnN0IGV4dHJhUmV0cnlDb2RlcyA9IFtcclxuICAgICAgICAvLyBSZXF1ZXN0IFRpbWVvdXQ6IHdlYiBzZXJ2ZXIgZGlkbid0IHJlY2VpdmUgZnVsbCByZXF1ZXN0IGluIHRpbWUuXHJcbiAgICAgICAgNDA4LFxyXG4gICAgICAgIC8vIFRvbyBNYW55IFJlcXVlc3RzOiB5b3UncmUgZ2V0dGluZyByYXRlLWxpbWl0ZWQsIGJhc2ljYWxseS5cclxuICAgICAgICA0MjlcclxuICAgIF07XHJcbiAgICBjb25zdCBpc0V4dHJhUmV0cnlDb2RlID0gZXh0cmFSZXRyeUNvZGVzLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTE7XHJcbiAgICBjb25zdCBpc0FkZGl0aW9uYWxSZXRyeUNvZGUgPSBhZGRpdGlvbmFsUmV0cnlDb2Rlcy5pbmRleE9mKHN0YXR1cykgIT09IC0xO1xyXG4gICAgcmV0dXJuIGlzRml2ZUh1bmRyZWRDb2RlIHx8IGlzRXh0cmFSZXRyeUNvZGUgfHwgaXNBZGRpdGlvbmFsUmV0cnlDb2RlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBIYW5kbGVzIG5ldHdvcmsgbG9naWMgZm9yIGFsbCBTdG9yYWdlIFJlcXVlc3RzLCBpbmNsdWRpbmcgZXJyb3IgcmVwb3J0aW5nIGFuZFxyXG4gKiByZXRyaWVzIHdpdGggYmFja29mZi5cclxuICpcclxuICogQHBhcmFtIEkgLSB0aGUgdHlwZSBvZiB0aGUgYmFja2VuZCdzIG5ldHdvcmsgcmVzcG9uc2UuXHJcbiAqIEBwYXJhbSAtIE8gdGhlIG91dHB1dCB0eXBlIHVzZWQgYnkgdGhlIHJlc3Qgb2YgdGhlIFNESy4gVGhlIGNvbnZlcnNpb25cclxuICogaGFwcGVucyBpbiB0aGUgc3BlY2lmaWVkIGBjYWxsYmFja19gLlxyXG4gKi9cclxuY2xhc3MgTmV0d29ya1JlcXVlc3Qge1xyXG4gICAgY29uc3RydWN0b3IodXJsXywgbWV0aG9kXywgaGVhZGVyc18sIGJvZHlfLCBzdWNjZXNzQ29kZXNfLCBhZGRpdGlvbmFsUmV0cnlDb2Rlc18sIGNhbGxiYWNrXywgZXJyb3JDYWxsYmFja18sIHRpbWVvdXRfLCBwcm9ncmVzc0NhbGxiYWNrXywgY29ubmVjdGlvbkZhY3RvcnlfLCByZXRyeSA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLnVybF8gPSB1cmxfO1xyXG4gICAgICAgIHRoaXMubWV0aG9kXyA9IG1ldGhvZF87XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzXyA9IGhlYWRlcnNfO1xyXG4gICAgICAgIHRoaXMuYm9keV8gPSBib2R5XztcclxuICAgICAgICB0aGlzLnN1Y2Nlc3NDb2Rlc18gPSBzdWNjZXNzQ29kZXNfO1xyXG4gICAgICAgIHRoaXMuYWRkaXRpb25hbFJldHJ5Q29kZXNfID0gYWRkaXRpb25hbFJldHJ5Q29kZXNfO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2tfO1xyXG4gICAgICAgIHRoaXMuZXJyb3JDYWxsYmFja18gPSBlcnJvckNhbGxiYWNrXztcclxuICAgICAgICB0aGlzLnRpbWVvdXRfID0gdGltZW91dF87XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrXyA9IHByb2dyZXNzQ2FsbGJhY2tfO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkZhY3RvcnlfID0gY29ubmVjdGlvbkZhY3RvcnlfO1xyXG4gICAgICAgIHRoaXMucmV0cnkgPSByZXRyeTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0aW9uXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmSWRfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNhbmNlbGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXBwRGVsZXRlXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZV8gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZV8gPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLnJlamVjdF8gPSByZWplY3Q7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRfKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjdHVhbGx5IHN0YXJ0cyB0aGUgcmV0cnkgbG9vcC5cclxuICAgICAqL1xyXG4gICAgc3RhcnRfKCkge1xyXG4gICAgICAgIGNvbnN0IGRvVGhlUmVxdWVzdCA9IChiYWNrb2ZmQ2FsbGJhY2ssIGNhbmNlbGVkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCkge1xyXG4gICAgICAgICAgICAgICAgYmFja29mZkNhbGxiYWNrKGZhbHNlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhmYWxzZSwgbnVsbCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb25GYWN0b3J5XygpO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0aW9uXyA9IGNvbm5lY3Rpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzTGlzdGVuZXIgPSBwcm9ncmVzc0V2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHByb2dyZXNzRXZlbnQubG9hZGVkO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBwcm9ncmVzc0V2ZW50Lmxlbmd0aENvbXB1dGFibGUgPyBwcm9ncmVzc0V2ZW50LnRvdGFsIDogLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9ncmVzc0NhbGxiYWNrXyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18obG9hZGVkLCB0b3RhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmFkZFVwbG9hZFByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3NMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbi5zZW5kKCkgbmV2ZXIgcmVqZWN0cywgc28gd2UgZG9uJ3QgbmVlZCB0byBoYXZlIGEgZXJyb3IgaGFuZGxlciBvciB1c2UgY2F0Y2ggb24gdGhlIHJldHVybmVkIHByb21pc2UuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgLnNlbmQodGhpcy51cmxfLCB0aGlzLm1ldGhvZF8sIHRoaXMuYm9keV8sIHRoaXMuaGVhZGVyc18pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9ncmVzc0NhbGxiYWNrXyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlVXBsb2FkUHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzc0xpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3Rpb25fID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhpdFNlcnZlciA9IGNvbm5lY3Rpb24uZ2V0RXJyb3JDb2RlKCkgPT09IEVycm9yQ29kZS5OT19FUlJPUjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGNvbm5lY3Rpb24uZ2V0U3RhdHVzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhpdFNlcnZlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChpc1JldHJ5U3RhdHVzQ29kZShzdGF0dXMsIHRoaXMuYWRkaXRpb25hbFJldHJ5Q29kZXNfKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhc0NhbmNlbGVkID0gY29ubmVjdGlvbi5nZXRFcnJvckNvZGUoKSA9PT0gRXJyb3JDb2RlLkFCT1JUO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tvZmZDYWxsYmFjayhmYWxzZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoZmFsc2UsIG51bGwsIHdhc0NhbmNlbGVkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc0NvZGUgPSB0aGlzLnN1Y2Nlc3NDb2Rlc18uaW5kZXhPZihzdGF0dXMpICE9PSAtMTtcclxuICAgICAgICAgICAgICAgIGJhY2tvZmZDYWxsYmFjayh0cnVlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhzdWNjZXNzQ29kZSwgY29ubmVjdGlvbikpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSByZXF1ZXN0V2VudFRocm91Z2ggLSBUcnVlIGlmIHRoZSByZXF1ZXN0IGV2ZW50dWFsbHkgd2VudFxyXG4gICAgICAgICAqICAgICB0aHJvdWdoLCBmYWxzZSBpZiBpdCBoaXQgdGhlIHJldHJ5IGxpbWl0IG9yIHdhcyBjYW5jZWxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBiYWNrb2ZmRG9uZSA9IChyZXF1ZXN0V2VudFRocm91Z2gsIHN0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gdGhpcy5yZXNvbHZlXztcclxuICAgICAgICAgICAgY29uc3QgcmVqZWN0ID0gdGhpcy5yZWplY3RfO1xyXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gc3RhdHVzLmNvbm5lY3Rpb247XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMud2FzU3VjY2Vzc0NvZGUpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jYWxsYmFja18oY29ubmVjdGlvbiwgY29ubmVjdGlvbi5nZXRSZXNwb25zZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNKdXN0RGVmKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB1bmtub3duKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLnNlcnZlclJlc3BvbnNlID0gY29ubmVjdGlvbi5nZXRFcnJvclRleHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnJvckNhbGxiYWNrXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5lcnJvckNhbGxiYWNrXyhjb25uZWN0aW9uLCBlcnIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5hcHBEZWxldGVfID8gYXBwRGVsZXRlZCgpIDogY2FuY2VsZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSByZXRyeUxpbWl0RXhjZWVkZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5jYW5jZWxlZF8pIHtcclxuICAgICAgICAgICAgYmFja29mZkRvbmUoZmFsc2UsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKGZhbHNlLCBudWxsLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZJZF8gPSBzdGFydChkb1RoZVJlcXVlc3QsIGJhY2tvZmZEb25lLCB0aGlzLnRpbWVvdXRfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldFByb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZV87XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGNhbmNlbChhcHBEZWxldGUpIHtcclxuICAgICAgICB0aGlzLmNhbmNlbGVkXyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hcHBEZWxldGVfID0gYXBwRGVsZXRlIHx8IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmJhY2tvZmZJZF8gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RvcCh0aGlzLmJhY2tvZmZJZF8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8uYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVzdWx0IG9mIGEgbmV0d29yayByZXF1ZXN0LlxyXG4gKiBAcGFyYW0gb3B0X2NhbmNlbGVkIC0gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAqL1xyXG5jbGFzcyBSZXF1ZXN0RW5kU3RhdHVzIHtcclxuICAgIGNvbnN0cnVjdG9yKHdhc1N1Y2Nlc3NDb2RlLCBjb25uZWN0aW9uLCBjYW5jZWxlZCkge1xyXG4gICAgICAgIHRoaXMud2FzU3VjY2Vzc0NvZGUgPSB3YXNTdWNjZXNzQ29kZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsZWQgPSAhIWNhbmNlbGVkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZEF1dGhIZWFkZXJfKGhlYWRlcnMsIGF1dGhUb2tlbikge1xyXG4gICAgaWYgKGF1dGhUb2tlbiAhPT0gbnVsbCAmJiBhdXRoVG9rZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdGaXJlYmFzZSAnICsgYXV0aFRva2VuO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZFZlcnNpb25IZWFkZXJfKGhlYWRlcnMsIGZpcmViYXNlVmVyc2lvbikge1xyXG4gICAgaGVhZGVyc1snWC1GaXJlYmFzZS1TdG9yYWdlLVZlcnNpb24nXSA9XHJcbiAgICAgICAgJ3dlYmpzLycgKyAoZmlyZWJhc2VWZXJzaW9uICE9PSBudWxsICYmIGZpcmViYXNlVmVyc2lvbiAhPT0gdm9pZCAwID8gZmlyZWJhc2VWZXJzaW9uIDogJ0FwcE1hbmFnZXInKTtcclxufVxyXG5mdW5jdGlvbiBhZGRHbXBpZEhlYWRlcl8oaGVhZGVycywgYXBwSWQpIHtcclxuICAgIGlmIChhcHBJZCkge1xyXG4gICAgICAgIGhlYWRlcnNbJ1gtRmlyZWJhc2UtR01QSUQnXSA9IGFwcElkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZEFwcENoZWNrSGVhZGVyXyhoZWFkZXJzLCBhcHBDaGVja1Rva2VuKSB7XHJcbiAgICBpZiAoYXBwQ2hlY2tUb2tlbiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGhlYWRlcnNbJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXSA9IGFwcENoZWNrVG9rZW47XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIGFwcElkLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHJlcXVlc3RGYWN0b3J5LCBmaXJlYmFzZVZlcnNpb24sIHJldHJ5ID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgcXVlcnlQYXJ0ID0gbWFrZVF1ZXJ5U3RyaW5nKHJlcXVlc3RJbmZvLnVybFBhcmFtcyk7XHJcbiAgICBjb25zdCB1cmwgPSByZXF1ZXN0SW5mby51cmwgKyBxdWVyeVBhcnQ7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluZm8uaGVhZGVycyk7XHJcbiAgICBhZGRHbXBpZEhlYWRlcl8oaGVhZGVycywgYXBwSWQpO1xyXG4gICAgYWRkQXV0aEhlYWRlcl8oaGVhZGVycywgYXV0aFRva2VuKTtcclxuICAgIGFkZFZlcnNpb25IZWFkZXJfKGhlYWRlcnMsIGZpcmViYXNlVmVyc2lvbik7XHJcbiAgICBhZGRBcHBDaGVja0hlYWRlcl8oaGVhZGVycywgYXBwQ2hlY2tUb2tlbik7XHJcbiAgICByZXR1cm4gbmV3IE5ldHdvcmtSZXF1ZXN0KHVybCwgcmVxdWVzdEluZm8ubWV0aG9kLCBoZWFkZXJzLCByZXF1ZXN0SW5mby5ib2R5LCByZXF1ZXN0SW5mby5zdWNjZXNzQ29kZXMsIHJlcXVlc3RJbmZvLmFkZGl0aW9uYWxSZXRyeUNvZGVzLCByZXF1ZXN0SW5mby5oYW5kbGVyLCByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIsIHJlcXVlc3RJbmZvLnRpbWVvdXQsIHJlcXVlc3RJbmZvLnByb2dyZXNzQ2FsbGJhY2ssIHJlcXVlc3RGYWN0b3J5LCByZXRyeSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QmxvYkJ1aWxkZXIoKSB7XHJcbiAgICBpZiAodHlwZW9mIEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBCbG9iQnVpbGRlcjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBXZWJLaXRCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gV2ViS2l0QmxvYkJ1aWxkZXI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb25jYXRlbmF0ZXMgb25lIG9yIG1vcmUgdmFsdWVzIHRvZ2V0aGVyIGFuZCBjb252ZXJ0cyB0aGVtIHRvIGEgQmxvYi5cclxuICpcclxuICogQHBhcmFtIGFyZ3MgVGhlIHZhbHVlcyB0aGF0IHdpbGwgbWFrZSB1cCB0aGUgcmVzdWx0aW5nIGJsb2IuXHJcbiAqIEByZXR1cm4gVGhlIGJsb2IuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCbG9iJDEoLi4uYXJncykge1xyXG4gICAgY29uc3QgQmxvYkJ1aWxkZXIgPSBnZXRCbG9iQnVpbGRlcigpO1xyXG4gICAgaWYgKEJsb2JCdWlsZGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zdCBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBiYi5hcHBlbmQoYXJnc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYi5nZXRCbG9iKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaXNOYXRpdmVCbG9iRGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTlNVUFBPUlRFRF9FTlZJUk9OTUVOVCwgXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzZWVtIHRvIHN1cHBvcnQgY3JlYXRpbmcgQmxvYnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTbGljZXMgdGhlIGJsb2IuIFRoZSByZXR1cm5lZCBibG9iIGNvbnRhaW5zIGRhdGEgZnJvbSB0aGUgc3RhcnQgYnl0ZVxyXG4gKiAoaW5jbHVzaXZlKSB0aWxsIHRoZSBlbmQgYnl0ZSAoZXhjbHVzaXZlKS4gTmVnYXRpdmUgaW5kaWNlcyBjYW5ub3QgYmUgdXNlZC5cclxuICpcclxuICogQHBhcmFtIGJsb2IgVGhlIGJsb2IgdG8gYmUgc2xpY2VkLlxyXG4gKiBAcGFyYW0gc3RhcnQgSW5kZXggb2YgdGhlIHN0YXJ0aW5nIGJ5dGUuXHJcbiAqIEBwYXJhbSBlbmQgSW5kZXggb2YgdGhlIGVuZGluZyBieXRlLlxyXG4gKiBAcmV0dXJuIFRoZSBibG9iIHNsaWNlIG9yIG51bGwgaWYgbm90IHN1cHBvcnRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHNsaWNlQmxvYihibG9iLCBzdGFydCwgZW5kKSB7XHJcbiAgICBpZiAoYmxvYi53ZWJraXRTbGljZSkge1xyXG4gICAgICAgIHJldHVybiBibG9iLndlYmtpdFNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYmxvYi5tb3pTbGljZSkge1xyXG4gICAgICAgIHJldHVybiBibG9iLm1velNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYmxvYi5zbGljZSkge1xyXG4gICAgICAgIHJldHVybiBibG9iLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIENvbnZlcnRzIGEgQmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYmluYXJ5IHN0cmluZy4gKi9cclxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGVuY29kZWQpIHtcclxuICAgIC8vIE5vZGUgYWN0dWFsbHkgZG9lc24ndCB2YWxpZGF0ZSBiYXNlNjQgc3RyaW5ncy5cclxuICAgIC8vIEEgcXVpY2sgc2FuaXR5IGNoZWNrIHRoYXQgaXMgbm90IGEgZm9vbC1wcm9vZiB2YWxpZGF0aW9uXHJcbiAgICBpZiAoL1teLUEtWmEtejAtOSsvPV0vLnRlc3QoZW5jb2RlZCkpIHtcclxuICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KCdiYXNlNjQnLCAnSW52YWxpZCBjaGFyYWN0ZXIgZm91bmQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShlbmNvZGVkLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB0aGUgcG9zc2libGUgc3RyaW5nIGZvcm1hdHMgZm9yIHVwbG9hZC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgU3RyaW5nRm9ybWF0ID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgXCJyYXdcIiwgdGhhdCBpcywgYXMgbm9ybWFsIHRleHQuXHJcbiAgICAgKiBUaGUgc3RyaW5nIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgVVRGLTE2LCB0aGVuIHVwbG9hZGVkIGFzIGEgVVRGLTggYnl0ZVxyXG4gICAgICogc2VxdWVuY2UuXHJcbiAgICAgKiBFeGFtcGxlOiBUaGUgc3RyaW5nICdIZWxsbyEgXFxcXHVkODNkXFxcXHVkZTBhJyBiZWNvbWVzIHRoZSBieXRlIHNlcXVlbmNlXHJcbiAgICAgKiA0OCA2NSA2YyA2YyA2ZiAyMSAyMCBmMCA5ZiA5OCA4YVxyXG4gICAgICovXHJcbiAgICBSQVc6ICdyYXcnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzZTY0LWVuY29kZWQgZGF0YS5cclxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyAodHJhaWxpbmcgJz0ncykgYXJlIG9wdGlvbmFsLlxyXG4gICAgICogRXhhbXBsZTogVGhlIHN0cmluZyAncldtTysrRTZ0Ny9ybHc9PScgYmVjb21lcyB0aGUgYnl0ZSBzZXF1ZW5jZVxyXG4gICAgICogYWQgNjkgOGUgZmIgZTEgM2EgYjcgYmYgZWIgOTdcclxuICAgICAqL1xyXG4gICAgQkFTRTY0OiAnYmFzZTY0JyxcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoZSBzdHJpbmcgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2U2NHVybC1lbmNvZGVkIGRhdGEuXHJcbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgKHRyYWlsaW5nICc9J3MpIGFyZSBvcHRpb25hbC5cclxuICAgICAqIEV4YW1wbGU6IFRoZSBzdHJpbmcgJ3JXbU8tLUU2dDdfcmx3PT0nIGJlY29tZXMgdGhlIGJ5dGUgc2VxdWVuY2VcclxuICAgICAqIGFkIDY5IDhlIGZiIGUxIDNhIGI3IGJmIGViIDk3XHJcbiAgICAgKi9cclxuICAgIEJBU0U2NFVSTDogJ2Jhc2U2NHVybCcsXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGUgc3RyaW5nIGlzIGEgZGF0YSBVUkwsIHN1Y2ggYXMgb25lIG9idGFpbmVkIGZyb21cclxuICAgICAqIGNhbnZhcy50b0RhdGFVUkwoKS5cclxuICAgICAqIEV4YW1wbGU6IHRoZSBzdHJpbmcgJ2RhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxhYWFhJ1xyXG4gICAgICogYmVjb21lcyB0aGUgYnl0ZSBzZXF1ZW5jZVxyXG4gICAgICogNjkgYTYgOWFcclxuICAgICAqICh0aGUgY29udGVudC10eXBlIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgaXMgYWxzbyBhcHBsaWVkLCBidXQgY2FuXHJcbiAgICAgKiBiZSBvdmVycmlkZGVuIGluIHRoZSBtZXRhZGF0YSBvYmplY3QpLlxyXG4gICAgICovXHJcbiAgICBEQVRBX1VSTDogJ2RhdGFfdXJsJ1xyXG59O1xyXG5jbGFzcyBTdHJpbmdEYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgfHwgbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBkYXRhRnJvbVN0cmluZyhmb3JtYXQsIHN0cmluZ0RhdGEpIHtcclxuICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuUkFXOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0RhdGEodXRmOEJ5dGVzXyhzdHJpbmdEYXRhKSk7XHJcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuQkFTRTY0OlxyXG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkJBU0U2NFVSTDpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdEYXRhKGJhc2U2NEJ5dGVzXyhmb3JtYXQsIHN0cmluZ0RhdGEpKTtcclxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5EQVRBX1VSTDpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdEYXRhKGRhdGFVUkxCeXRlc18oc3RyaW5nRGF0YSksIGRhdGFVUkxDb250ZW50VHlwZV8oc3RyaW5nRGF0YSkpO1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgIH1cclxuICAgIC8vIGFzc2VydChmYWxzZSk7XHJcbiAgICB0aHJvdyB1bmtub3duKCk7XHJcbn1cclxuZnVuY3Rpb24gdXRmOEJ5dGVzXyh2YWx1ZSkge1xyXG4gICAgY29uc3QgYiA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gdmFsdWUuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8PSAxMjcpIHtcclxuICAgICAgICAgICAgYi5wdXNoKGMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGMgPD0gMjA0Nykge1xyXG4gICAgICAgICAgICAgICAgYi5wdXNoKDE5MiB8IChjID4+IDYpLCAxMjggfCAoYyAmIDYzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHN0YXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBpIDwgdmFsdWUubGVuZ3RoIC0gMSAmJiAodmFsdWUuY2hhckNvZGVBdChpICsgMSkgJiA2NDUxMikgPT09IDU2MzIwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNlY29uZCBzdXJyb2dhdGUgd2Fzbid0IHRoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjM5LCAxOTEsIDE4OSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoaSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvID0gdmFsdWUuY2hhckNvZGVBdCgrK2kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gNjU1MzYgfCAoKGhpICYgMTAyMykgPDwgMTApIHwgKGxvICYgMTAyMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyNDAgfCAoYyA+PiAxOCksIDEyOCB8ICgoYyA+PiAxMikgJiA2MyksIDEyOCB8ICgoYyA+PiA2KSAmIDYzKSwgMTI4IHwgKGMgJiA2MykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTYzMjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBsb3cgc3Vycm9nYXRlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjM5LCAxOTEsIDE4OSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjI0IHwgKGMgPj4gMTIpLCAxMjggfCAoKGMgPj4gNikgJiA2MyksIDEyOCB8IChjICYgNjMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYik7XHJcbn1cclxuZnVuY3Rpb24gcGVyY2VudEVuY29kZWRCeXRlc18odmFsdWUpIHtcclxuICAgIGxldCBkZWNvZGVkO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChTdHJpbmdGb3JtYXQuREFUQV9VUkwsICdNYWxmb3JtZWQgZGF0YSBVUkwuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXRmOEJ5dGVzXyhkZWNvZGVkKTtcclxufVxyXG5mdW5jdGlvbiBiYXNlNjRCeXRlc18oZm9ybWF0LCB2YWx1ZSkge1xyXG4gICAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjQ6IHtcclxuICAgICAgICAgICAgY29uc3QgaGFzTWludXMgPSB2YWx1ZS5pbmRleE9mKCctJykgIT09IC0xO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNVbmRlciA9IHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTE7XHJcbiAgICAgICAgICAgIGlmIChoYXNNaW51cyB8fCBoYXNVbmRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZENoYXIgPSBoYXNNaW51cyA/ICctJyA6ICdfJztcclxuICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoZm9ybWF0LCBcIkludmFsaWQgY2hhcmFjdGVyICdcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZENoYXIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiJyBmb3VuZDogaXMgaXQgYmFzZTY0dXJsIGVuY29kZWQ/XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjRVUkw6IHtcclxuICAgICAgICAgICAgY29uc3QgaGFzUGx1cyA9IHZhbHVlLmluZGV4T2YoJysnKSAhPT0gLTE7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc1NsYXNoID0gdmFsdWUuaW5kZXhPZignLycpICE9PSAtMTtcclxuICAgICAgICAgICAgaWYgKGhhc1BsdXMgfHwgaGFzU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRDaGFyID0gaGFzUGx1cyA/ICcrJyA6ICcvJztcclxuICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoZm9ybWF0LCBcIkludmFsaWQgY2hhcmFjdGVyICdcIiArIGludmFsaWRDaGFyICsgXCInIGZvdW5kOiBpcyBpdCBiYXNlNjQgZW5jb2RlZD9cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfVxyXG4gICAgbGV0IGJ5dGVzO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBieXRlcyA9IGRlY29kZUJhc2U2NCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoJ3BvbHlmaWxsJykpIHtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChmb3JtYXQsICdJbnZhbGlkIGNoYXJhY3RlciBmb3VuZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFycmF5W2ldID0gYnl0ZXMuY2hhckNvZGVBdChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxufVxyXG5jbGFzcyBEYXRhVVJMUGFydHMge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YVVSTCkge1xyXG4gICAgICAgIHRoaXMuYmFzZTY0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGRhdGFVUkwubWF0Y2goL15kYXRhOihbXixdKyk/LC8pO1xyXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoU3RyaW5nRm9ybWF0LkRBVEFfVVJMLCBcIk11c3QgYmUgZm9ybWF0dGVkICdkYXRhOls8bWVkaWF0eXBlPl1bO2Jhc2U2NF0sPGRhdGE+XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtaWRkbGUgPSBtYXRjaGVzWzFdIHx8IG51bGw7XHJcbiAgICAgICAgaWYgKG1pZGRsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZTY0ID0gZW5kc1dpdGgobWlkZGxlLCAnO2Jhc2U2NCcpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gdGhpcy5iYXNlNjRcclxuICAgICAgICAgICAgICAgID8gbWlkZGxlLnN1YnN0cmluZygwLCBtaWRkbGUubGVuZ3RoIC0gJztiYXNlNjQnLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIDogbWlkZGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3QgPSBkYXRhVVJMLnN1YnN0cmluZyhkYXRhVVJMLmluZGV4T2YoJywnKSArIDEpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRhdGFVUkxCeXRlc18oZGF0YVVybCkge1xyXG4gICAgY29uc3QgcGFydHMgPSBuZXcgRGF0YVVSTFBhcnRzKGRhdGFVcmwpO1xyXG4gICAgaWYgKHBhcnRzLmJhc2U2NCkge1xyXG4gICAgICAgIHJldHVybiBiYXNlNjRCeXRlc18oU3RyaW5nRm9ybWF0LkJBU0U2NCwgcGFydHMucmVzdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGVyY2VudEVuY29kZWRCeXRlc18ocGFydHMucmVzdCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGF0YVVSTENvbnRlbnRUeXBlXyhkYXRhVXJsKSB7XHJcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBEYXRhVVJMUGFydHMoZGF0YVVybCk7XHJcbiAgICByZXR1cm4gcGFydHMuY29udGVudFR5cGU7XHJcbn1cclxuZnVuY3Rpb24gZW5kc1dpdGgocywgZW5kKSB7XHJcbiAgICBjb25zdCBsb25nRW5vdWdoID0gcy5sZW5ndGggPj0gZW5kLmxlbmd0aDtcclxuICAgIGlmICghbG9uZ0Vub3VnaCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBzLnN1YnN0cmluZyhzLmxlbmd0aCAtIGVuZC5sZW5ndGgpID09PSBlbmQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBwYXJhbSBvcHRfZWxpZGVDb3B5IC0gSWYgdHJ1ZSwgZG9lc24ndCBjb3B5IG11dGFibGUgaW5wdXQgZGF0YVxyXG4gKiAgICAgKGUuZy4gVWludDhBcnJheXMpLiBQYXNzIHRydWUgb25seSBpZiB5b3Uga25vdyB0aGUgb2JqZWN0cyB3aWxsIG5vdCBiZVxyXG4gKiAgICAgbW9kaWZpZWQgYWZ0ZXIgdGhpcyBibG9iJ3MgY29uc3RydWN0aW9uLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEZic0Jsb2Ige1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgZWxpZGVDb3B5KSB7XHJcbiAgICAgICAgbGV0IHNpemUgPSAwO1xyXG4gICAgICAgIGxldCBibG9iVHlwZSA9ICcnO1xyXG4gICAgICAgIGlmIChpc05hdGl2ZUJsb2IoZGF0YSkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhXyA9IGRhdGE7XHJcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XHJcbiAgICAgICAgICAgIGJsb2JUeXBlID0gZGF0YS50eXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgaWYgKGVsaWRlQ29weSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfLnNldChuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuZGF0YV8ubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgICAgICBpZiAoZWxpZGVDb3B5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfLnNldChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzaXplID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2l6ZV8gPSBzaXplO1xyXG4gICAgICAgIHRoaXMudHlwZV8gPSBibG9iVHlwZTtcclxuICAgIH1cclxuICAgIHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZV87XHJcbiAgICB9XHJcbiAgICB0eXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVfO1xyXG4gICAgfVxyXG4gICAgc2xpY2Uoc3RhcnRCeXRlLCBlbmRCeXRlKSB7XHJcbiAgICAgICAgaWYgKGlzTmF0aXZlQmxvYih0aGlzLmRhdGFfKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZWFsQmxvYiA9IHRoaXMuZGF0YV87XHJcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlZCA9IHNsaWNlQmxvYihyZWFsQmxvYiwgc3RhcnRCeXRlLCBlbmRCeXRlKTtcclxuICAgICAgICAgICAgaWYgKHNsaWNlZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYnNCbG9iKHNsaWNlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YV8uYnVmZmVyLCBzdGFydEJ5dGUsIGVuZEJ5dGUgLSBzdGFydEJ5dGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2Ioc2xpY2UsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRCbG9iKC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAoaXNOYXRpdmVCbG9iRGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2JieSA9IGFyZ3MubWFwKCh2YWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGYnNCbG9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5kYXRhXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2IoZ2V0QmxvYiQxLmFwcGx5KG51bGwsIGJsb2JieSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdWludDhBcnJheXMgPSBhcmdzLm1hcCgodmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhRnJvbVN0cmluZyhTdHJpbmdGb3JtYXQuUkFXLCB2YWwpLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCbG9icyBkb24ndCBleGlzdCwgc28gdGhpcyBoYXMgdG8gYmUgYSBVaW50OEFycmF5LlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuZGF0YV87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgZmluYWxMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB1aW50OEFycmF5cy5mb3JFYWNoKChhcnJheSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZmluYWxMZW5ndGggKz0gYXJyYXkuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBVaW50OEFycmF5KGZpbmFsTGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgdWludDhBcnJheXMuZm9yRWFjaCgoYXJyYXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRbaW5kZXgrK10gPSBhcnJheVtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihtZXJnZWQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwbG9hZERhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YV87XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIE9iamVjdCByZXN1bHRpbmcgZnJvbSBwYXJzaW5nIHRoZSBnaXZlbiBKU09OLCBvciBudWxsIGlmIHRoZVxyXG4gKiBnaXZlbiBzdHJpbmcgZG9lcyBub3QgcmVwcmVzZW50IGEgSlNPTiBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBqc29uT2JqZWN0T3JOdWxsKHMpIHtcclxuICAgIGxldCBvYmo7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG9iaiA9IEpTT04ucGFyc2Uocyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTm9uQXJyYXlPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBDb250YWlucyBoZWxwZXIgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIHBhdGhzLlxyXG4gKi9cclxuLyoqXHJcbiAqIEByZXR1cm4gTnVsbCBpZiB0aGUgcGF0aCBpcyBhbHJlYWR5IGF0IHRoZSByb290LlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyZW50KHBhdGgpIHtcclxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XHJcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3UGF0aCA9IHBhdGguc2xpY2UoMCwgaW5kZXgpO1xyXG4gICAgcmV0dXJuIG5ld1BhdGg7XHJcbn1cclxuZnVuY3Rpb24gY2hpbGQocGF0aCwgY2hpbGRQYXRoKSB7XHJcbiAgICBjb25zdCBjYW5vbmljYWxDaGlsZFBhdGggPSBjaGlsZFBhdGhcclxuICAgICAgICAuc3BsaXQoJy8nKVxyXG4gICAgICAgIC5maWx0ZXIoY29tcG9uZW50ID0+IGNvbXBvbmVudC5sZW5ndGggPiAwKVxyXG4gICAgICAgIC5qb2luKCcvJyk7XHJcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gY2Fub25pY2FsQ2hpbGRQYXRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGggKyAnLycgKyBjYW5vbmljYWxDaGlsZFBhdGg7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxhc3QgY29tcG9uZW50IG9mIGEgcGF0aC5cclxuICogJy9mb28vYmFyJyAtPiAnYmFyJ1xyXG4gKiAnL2Zvby9iYXIvYmF6LycgLT4gJ2Jhei8nXHJcbiAqICcvYScgLT4gJ2EnXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXN0Q29tcG9uZW50KHBhdGgpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycsIHBhdGgubGVuZ3RoIC0gMik7XHJcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShpbmRleCArIDEpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIG5vWGZvcm1fKG1ldGFkYXRhLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmNsYXNzIE1hcHBpbmcge1xyXG4gICAgY29uc3RydWN0b3Ioc2VydmVyLCBsb2NhbCwgd3JpdGFibGUsIHhmb3JtKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XHJcbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsIHx8IHNlcnZlcjtcclxuICAgICAgICB0aGlzLndyaXRhYmxlID0gISF3cml0YWJsZTtcclxuICAgICAgICB0aGlzLnhmb3JtID0geGZvcm0gfHwgbm9YZm9ybV87XHJcbiAgICB9XHJcbn1cclxubGV0IG1hcHBpbmdzXyA9IG51bGw7XHJcbmZ1bmN0aW9uIHhmb3JtUGF0aChmdWxsUGF0aCkge1xyXG4gICAgaWYgKCFpc1N0cmluZyhmdWxsUGF0aCkgfHwgZnVsbFBhdGgubGVuZ3RoIDwgMikge1xyXG4gICAgICAgIHJldHVybiBmdWxsUGF0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsYXN0Q29tcG9uZW50KGZ1bGxQYXRoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRNYXBwaW5ncygpIHtcclxuICAgIGlmIChtYXBwaW5nc18pIHtcclxuICAgICAgICByZXR1cm4gbWFwcGluZ3NfO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWFwcGluZ3MgPSBbXTtcclxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2J1Y2tldCcpKTtcclxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2dlbmVyYXRpb24nKSk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZXRhZ2VuZXJhdGlvbicpKTtcclxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ25hbWUnLCAnZnVsbFBhdGgnLCB0cnVlKSk7XHJcbiAgICBmdW5jdGlvbiBtYXBwaW5nc1hmb3JtUGF0aChfbWV0YWRhdGEsIGZ1bGxQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHhmb3JtUGF0aChmdWxsUGF0aCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYW1lTWFwcGluZyA9IG5ldyBNYXBwaW5nKCduYW1lJyk7XHJcbiAgICBuYW1lTWFwcGluZy54Zm9ybSA9IG1hcHBpbmdzWGZvcm1QYXRoO1xyXG4gICAgbWFwcGluZ3MucHVzaChuYW1lTWFwcGluZyk7XHJcbiAgICAvKipcclxuICAgICAqIENvZXJjZXMgdGhlIHNlY29uZCBwYXJhbSB0byBhIG51bWJlciwgaWYgaXQgaXMgZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24geGZvcm1TaXplKF9tZXRhZGF0YSwgc2l6ZSkge1xyXG4gICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHNpemVNYXBwaW5nID0gbmV3IE1hcHBpbmcoJ3NpemUnKTtcclxuICAgIHNpemVNYXBwaW5nLnhmb3JtID0geGZvcm1TaXplO1xyXG4gICAgbWFwcGluZ3MucHVzaChzaXplTWFwcGluZyk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCd0aW1lQ3JlYXRlZCcpKTtcclxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ3VwZGF0ZWQnKSk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZDVIYXNoJywgbnVsbCwgdHJ1ZSkpO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY2FjaGVDb250cm9sJywgbnVsbCwgdHJ1ZSkpO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudERpc3Bvc2l0aW9uJywgbnVsbCwgdHJ1ZSkpO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudEVuY29kaW5nJywgbnVsbCwgdHJ1ZSkpO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudExhbmd1YWdlJywgbnVsbCwgdHJ1ZSkpO1xyXG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudFR5cGUnLCBudWxsLCB0cnVlKSk7XHJcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZXRhZGF0YScsICdjdXN0b21NZXRhZGF0YScsIHRydWUpKTtcclxuICAgIG1hcHBpbmdzXyA9IG1hcHBpbmdzO1xyXG4gICAgcmV0dXJuIG1hcHBpbmdzXztcclxufVxyXG5mdW5jdGlvbiBhZGRSZWYobWV0YWRhdGEsIHNlcnZpY2UpIHtcclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVmKCkge1xyXG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG1ldGFkYXRhWydidWNrZXQnXTtcclxuICAgICAgICBjb25zdCBwYXRoID0gbWV0YWRhdGFbJ2Z1bGxQYXRoJ107XHJcbiAgICAgICAgY29uc3QgbG9jID0gbmV3IExvY2F0aW9uKGJ1Y2tldCwgcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX21ha2VTdG9yYWdlUmVmZXJlbmNlKGxvYyk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICdyZWYnLCB7IGdldDogZ2VuZXJhdGVSZWYgfSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVJlc291cmNlKHNlcnZpY2UsIHJlc291cmNlLCBtYXBwaW5ncykge1xyXG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcclxuICAgIG1ldGFkYXRhWyd0eXBlJ10gPSAnZmlsZSc7XHJcbiAgICBjb25zdCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xyXG4gICAgICAgIG1ldGFkYXRhW21hcHBpbmcubG9jYWxdID0gbWFwcGluZy54Zm9ybShtZXRhZGF0YSwgcmVzb3VyY2VbbWFwcGluZy5zZXJ2ZXJdKTtcclxuICAgIH1cclxuICAgIGFkZFJlZihtZXRhZGF0YSwgc2VydmljZSk7XHJcbiAgICByZXR1cm4gbWV0YWRhdGE7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVJlc291cmNlU3RyaW5nKHNlcnZpY2UsIHJlc291cmNlU3RyaW5nLCBtYXBwaW5ncykge1xyXG4gICAgY29uc3Qgb2JqID0ganNvbk9iamVjdE9yTnVsbChyZXNvdXJjZVN0cmluZyk7XHJcbiAgICBpZiAob2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXNvdXJjZSA9IG9iajtcclxuICAgIHJldHVybiBmcm9tUmVzb3VyY2Uoc2VydmljZSwgcmVzb3VyY2UsIG1hcHBpbmdzKTtcclxufVxyXG5mdW5jdGlvbiBkb3dubG9hZFVybEZyb21SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgcmVzb3VyY2VTdHJpbmcsIGhvc3QsIHByb3RvY29sKSB7XHJcbiAgICBjb25zdCBvYmogPSBqc29uT2JqZWN0T3JOdWxsKHJlc291cmNlU3RyaW5nKTtcclxuICAgIGlmIChvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICghaXNTdHJpbmcob2JqWydkb3dubG9hZFRva2VucyddKSkge1xyXG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBvYmplY3RzIGFyZSB1cGxvYWRlZCB0aHJvdWdoIEdDUyBhbmQgcmV0cmlldmVkXHJcbiAgICAgICAgLy8gdGhyb3VnaCBsaXN0LCBzbyB3ZSBkb24ndCB3YW50IHRvIHRocm93IGFuIEVycm9yLlxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdG9rZW5zID0gb2JqWydkb3dubG9hZFRva2VucyddO1xyXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcclxuICAgIGNvbnN0IHRva2Vuc0xpc3QgPSB0b2tlbnMuc3BsaXQoJywnKTtcclxuICAgIGNvbnN0IHVybHMgPSB0b2tlbnNMaXN0Lm1hcCgodG9rZW4pID0+IHtcclxuICAgICAgICBjb25zdCBidWNrZXQgPSBtZXRhZGF0YVsnYnVja2V0J107XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IG1ldGFkYXRhWydmdWxsUGF0aCddO1xyXG4gICAgICAgIGNvbnN0IHVybFBhcnQgPSAnL2IvJyArIGVuY29kZShidWNrZXQpICsgJy9vLycgKyBlbmNvZGUocGF0aCk7XHJcbiAgICAgICAgY29uc3QgYmFzZSA9IG1ha2VVcmwodXJsUGFydCwgaG9zdCwgcHJvdG9jb2wpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbWFrZVF1ZXJ5U3RyaW5nKHtcclxuICAgICAgICAgICAgYWx0OiAnbWVkaWEnLFxyXG4gICAgICAgICAgICB0b2tlblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBiYXNlICsgcXVlcnlTdHJpbmc7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB1cmxzWzBdO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmVzb3VyY2VTdHJpbmcobWV0YWRhdGEsIG1hcHBpbmdzKSB7XHJcbiAgICBjb25zdCByZXNvdXJjZSA9IHt9O1xyXG4gICAgY29uc3QgbGVuID0gbWFwcGluZ3MubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcclxuICAgICAgICBpZiAobWFwcGluZy53cml0YWJsZSkge1xyXG4gICAgICAgICAgICByZXNvdXJjZVttYXBwaW5nLnNlcnZlcl0gPSBtZXRhZGF0YVttYXBwaW5nLmxvY2FsXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzb3VyY2UpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFBSRUZJWEVTX0tFWSA9ICdwcmVmaXhlcyc7XHJcbmNvbnN0IElURU1TX0tFWSA9ICdpdGVtcyc7XHJcbmZ1bmN0aW9uIGZyb21CYWNrZW5kUmVzcG9uc2Uoc2VydmljZSwgYnVja2V0LCByZXNvdXJjZSkge1xyXG4gICAgY29uc3QgbGlzdFJlc3VsdCA9IHtcclxuICAgICAgICBwcmVmaXhlczogW10sXHJcbiAgICAgICAgaXRlbXM6IFtdLFxyXG4gICAgICAgIG5leHRQYWdlVG9rZW46IHJlc291cmNlWyduZXh0UGFnZVRva2VuJ11cclxuICAgIH07XHJcbiAgICBpZiAocmVzb3VyY2VbUFJFRklYRVNfS0VZXSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiByZXNvdXJjZVtQUkVGSVhFU19LRVldKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGhXaXRob3V0VHJhaWxpbmdTbGFzaCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gc2VydmljZS5fbWFrZVN0b3JhZ2VSZWZlcmVuY2UobmV3IExvY2F0aW9uKGJ1Y2tldCwgcGF0aFdpdGhvdXRUcmFpbGluZ1NsYXNoKSk7XHJcbiAgICAgICAgICAgIGxpc3RSZXN1bHQucHJlZml4ZXMucHVzaChyZWZlcmVuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyZXNvdXJjZVtJVEVNU19LRVldKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHJlc291cmNlW0lURU1TX0tFWV0pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gc2VydmljZS5fbWFrZVN0b3JhZ2VSZWZlcmVuY2UobmV3IExvY2F0aW9uKGJ1Y2tldCwgaXRlbVsnbmFtZSddKSk7XHJcbiAgICAgICAgICAgIGxpc3RSZXN1bHQuaXRlbXMucHVzaChyZWZlcmVuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsaXN0UmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21SZXNwb25zZVN0cmluZyhzZXJ2aWNlLCBidWNrZXQsIHJlc291cmNlU3RyaW5nKSB7XHJcbiAgICBjb25zdCBvYmogPSBqc29uT2JqZWN0T3JOdWxsKHJlc291cmNlU3RyaW5nKTtcclxuICAgIGlmIChvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc291cmNlID0gb2JqO1xyXG4gICAgcmV0dXJuIGZyb21CYWNrZW5kUmVzcG9uc2Uoc2VydmljZSwgYnVja2V0LCByZXNvdXJjZSk7XHJcbn1cblxuLyoqXHJcbiAqIENvbnRhaW5zIGEgZnVsbHkgc3BlY2lmaWVkIHJlcXVlc3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBJIC0gdGhlIHR5cGUgb2YgdGhlIGJhY2tlbmQncyBuZXR3b3JrIHJlc3BvbnNlLlxyXG4gKiBAcGFyYW0gTyAtIHRoZSBvdXRwdXQgcmVzcG9uc2UgdHlwZSB1c2VkIGJ5IHRoZSByZXN0IG9mIHRoZSBTREsuXHJcbiAqL1xyXG5jbGFzcyBSZXF1ZXN0SW5mbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG1ldGhvZCwgXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIHdpdGggd2hpY2ggdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdCdzIHByb21pc2UuIE9ubHkgY2FsbGVkXHJcbiAgICAgKiBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLiBUaHJvdyBmcm9tIHRoaXMgZnVuY3Rpb24gdG8gcmVqZWN0IHRoZVxyXG4gICAgICogcmV0dXJuZWQgUmVxdWVzdCdzIHByb21pc2Ugd2l0aCB0aGUgdGhyb3duIGVycm9yLlxyXG4gICAgICogTm90ZTogVGhlIFhocklvIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIG1heSBiZSByZXVzZWQgYWZ0ZXIgdGhpcyBjYWxsYmFja1xyXG4gICAgICogcmV0dXJucy4gRG8gbm90IGtlZXAgYSByZWZlcmVuY2UgdG8gaXQgaW4gYW55IHdheS5cclxuICAgICAqL1xyXG4gICAgaGFuZGxlciwgdGltZW91dCkge1xyXG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xyXG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcclxuICAgICAgICB0aGlzLnVybFBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuYm9keSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCB3aXRoIHRoZSBjdXJyZW50IG51bWJlciBvZiBieXRlcyB1cGxvYWRlZCBhbmQgdG90YWwgc2l6ZSAoLTEgaWYgbm90XHJcbiAgICAgICAgICogY29tcHV0YWJsZSkgb2YgdGhlIHJlcXVlc3QgYm9keSAoaS5lLiB1c2VkIHRvIHJlcG9ydCB1cGxvYWQgcHJvZ3Jlc3MpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdWNjZXNzQ29kZXMgPSBbMjAwXTtcclxuICAgICAgICB0aGlzLmFkZGl0aW9uYWxSZXRyeUNvZGVzID0gW107XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRocm93cyB0aGUgVU5LTk9XTiBTdG9yYWdlRXJyb3IgaWYgY25kbiBpcyBmYWxzZS5cclxuICovXHJcbmZ1bmN0aW9uIGhhbmRsZXJDaGVjayhjbmRuKSB7XHJcbiAgICBpZiAoIWNuZG4pIHtcclxuICAgICAgICB0aHJvdyB1bmtub3duKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSB7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZnJvbVJlc291cmNlU3RyaW5nKHNlcnZpY2UsIHRleHQsIG1hcHBpbmdzKTtcclxuICAgICAgICBoYW5kbGVyQ2hlY2sobWV0YWRhdGEgIT09IG51bGwpO1xyXG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYW5kbGVyO1xyXG59XHJcbmZ1bmN0aW9uIGxpc3RIYW5kbGVyKHNlcnZpY2UsIGJ1Y2tldCkge1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcclxuICAgICAgICBjb25zdCBsaXN0UmVzdWx0ID0gZnJvbVJlc3BvbnNlU3RyaW5nKHNlcnZpY2UsIGJ1Y2tldCwgdGV4dCk7XHJcbiAgICAgICAgaGFuZGxlckNoZWNrKGxpc3RSZXN1bHQgIT09IG51bGwpO1xyXG4gICAgICAgIHJldHVybiBsaXN0UmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbn1cclxuZnVuY3Rpb24gZG93bmxvYWRVcmxIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSB7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZnJvbVJlc291cmNlU3RyaW5nKHNlcnZpY2UsIHRleHQsIG1hcHBpbmdzKTtcclxuICAgICAgICBoYW5kbGVyQ2hlY2sobWV0YWRhdGEgIT09IG51bGwpO1xyXG4gICAgICAgIHJldHVybiBkb3dubG9hZFVybEZyb21SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgdGV4dCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxufVxyXG5mdW5jdGlvbiBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pIHtcclxuICAgIGZ1bmN0aW9uIGVycm9ySGFuZGxlcih4aHIsIGVycikge1xyXG4gICAgICAgIGxldCBuZXdFcnI7XHJcbiAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAxKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgLy8gVGhpcyBleGFjdCBtZXNzYWdlIHN0cmluZyBpcyB0aGUgb25seSBjb25zaXN0ZW50IHBhcnQgb2YgdGhlXHJcbiAgICAgICAgICAgIC8vIHNlcnZlcidzIGVycm9yIHJlc3BvbnNlIHRoYXQgaWRlbnRpZmllcyBpdCBhcyBhbiBBcHAgQ2hlY2sgZXJyb3IuXHJcbiAgICAgICAgICAgIHhoci5nZXRFcnJvclRleHQoKS5pbmNsdWRlcygnRmlyZWJhc2UgQXBwIENoZWNrIHRva2VuIGlzIGludmFsaWQnKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3RXJyID0gdW5hdXRob3JpemVkQXBwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFcnIgPSB1bmF1dGhlbnRpY2F0ZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAyKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFcnIgPSBxdW90YUV4Y2VlZGVkKGxvY2F0aW9uLmJ1Y2tldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDMpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFcnIgPSB1bmF1dGhvcml6ZWQobG9jYXRpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFcnIgPSBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3RXJyLnN0YXR1cyA9IHhoci5nZXRTdGF0dXMoKTtcclxuICAgICAgICBuZXdFcnIuc2VydmVyUmVzcG9uc2UgPSBlcnIuc2VydmVyUmVzcG9uc2U7XHJcbiAgICAgICAgcmV0dXJuIG5ld0VycjtcclxuICAgIH1cclxuICAgIHJldHVybiBlcnJvckhhbmRsZXI7XHJcbn1cclxuZnVuY3Rpb24gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKSB7XHJcbiAgICBjb25zdCBzaGFyZWQgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgZnVuY3Rpb24gZXJyb3JIYW5kbGVyKHhociwgZXJyKSB7XHJcbiAgICAgICAgbGV0IG5ld0VyciA9IHNoYXJlZCh4aHIsIGVycik7XHJcbiAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgIG5ld0VyciA9IG9iamVjdE5vdEZvdW5kKGxvY2F0aW9uLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdFcnIuc2VydmVyUmVzcG9uc2UgPSBlcnIuc2VydmVyUmVzcG9uc2U7XHJcbiAgICAgICAgcmV0dXJuIG5ld0VycjtcclxuICAgIH1cclxuICAgIHJldHVybiBlcnJvckhhbmRsZXI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWV0YWRhdGEkMihzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MpIHtcclxuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XHJcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSwgdGltZW91dCk7XHJcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xyXG59XHJcbmZ1bmN0aW9uIGxpc3QkMihzZXJ2aWNlLCBsb2NhdGlvbiwgZGVsaW1pdGVyLCBwYWdlVG9rZW4sIG1heFJlc3VsdHMpIHtcclxuICAgIGNvbnN0IHVybFBhcmFtcyA9IHt9O1xyXG4gICAgaWYgKGxvY2F0aW9uLmlzUm9vdCkge1xyXG4gICAgICAgIHVybFBhcmFtc1sncHJlZml4J10gPSAnJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHVybFBhcmFtc1sncHJlZml4J10gPSBsb2NhdGlvbi5wYXRoICsgJy8nO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlbGltaXRlciAmJiBkZWxpbWl0ZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHVybFBhcmFtc1snZGVsaW1pdGVyJ10gPSBkZWxpbWl0ZXI7XHJcbiAgICB9XHJcbiAgICBpZiAocGFnZVRva2VuKSB7XHJcbiAgICAgICAgdXJsUGFyYW1zWydwYWdlVG9rZW4nXSA9IHBhZ2VUb2tlbjtcclxuICAgIH1cclxuICAgIGlmIChtYXhSZXN1bHRzKSB7XHJcbiAgICAgICAgdXJsUGFyYW1zWydtYXhSZXN1bHRzJ10gPSBtYXhSZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmJ1Y2tldE9ubHlTZXJ2ZXJVcmwoKTtcclxuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBsaXN0SGFuZGxlcihzZXJ2aWNlLCBsb2NhdGlvbi5idWNrZXQpLCB0aW1lb3V0KTtcclxuICAgIHJlcXVlc3RJbmZvLnVybFBhcmFtcyA9IHVybFBhcmFtcztcclxuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XHJcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XHJcbn1cclxuZnVuY3Rpb24gZ2V0Qnl0ZXMkMShzZXJ2aWNlLCBsb2NhdGlvbiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcclxuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XHJcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpICsgJz9hbHQ9bWVkaWEnO1xyXG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgKF8sIGRhdGEpID0+IGRhdGEsIHRpbWVvdXQpO1xyXG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcclxuICAgIGlmIChtYXhEb3dubG9hZFNpemVCeXRlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmVxdWVzdEluZm8uaGVhZGVyc1snUmFuZ2UnXSA9IGBieXRlcz0wLSR7bWF4RG93bmxvYWRTaXplQnl0ZXN9YDtcclxuICAgICAgICByZXF1ZXN0SW5mby5zdWNjZXNzQ29kZXMgPSBbMjAwIC8qIE9LICovLCAyMDYgLyogUGFydGlhbCBDb250ZW50ICovXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXF1ZXN0SW5mbztcclxufVxyXG5mdW5jdGlvbiBnZXREb3dubG9hZFVybChzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MpIHtcclxuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XHJcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgZG93bmxvYWRVcmxIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSwgdGltZW91dCk7XHJcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZU1ldGFkYXRhJDIoc2VydmljZSwgbG9jYXRpb24sIG1ldGFkYXRhLCBtYXBwaW5ncykge1xyXG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcclxuICAgIGNvbnN0IHVybCA9IG1ha2VVcmwodXJsUGFydCwgc2VydmljZS5ob3N0LCBzZXJ2aWNlLl9wcm90b2NvbCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSAnUEFUQ0gnO1xyXG4gICAgY29uc3QgYm9keSA9IHRvUmVzb3VyY2VTdHJpbmcobWV0YWRhdGEsIG1hcHBpbmdzKTtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCcgfTtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcclxuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xyXG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHk7XHJcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZU9iamVjdCQyKHNlcnZpY2UsIGxvY2F0aW9uKSB7XHJcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uZnVsbFNlcnZlclVybCgpO1xyXG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcclxuICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xyXG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlcihfeGhyLCBfdGV4dCkgeyB9XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XHJcbiAgICByZXF1ZXN0SW5mby5zdWNjZXNzQ29kZXMgPSBbMjAwLCAyMDRdO1xyXG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcclxuICAgIHJldHVybiByZXF1ZXN0SW5mbztcclxufVxyXG5mdW5jdGlvbiBkZXRlcm1pbmVDb250ZW50VHlwZV8obWV0YWRhdGEsIGJsb2IpIHtcclxuICAgIHJldHVybiAoKG1ldGFkYXRhICYmIG1ldGFkYXRhWydjb250ZW50VHlwZSddKSB8fFxyXG4gICAgICAgIChibG9iICYmIGJsb2IudHlwZSgpKSB8fFxyXG4gICAgICAgICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcclxufVxyXG5mdW5jdGlvbiBtZXRhZGF0YUZvclVwbG9hZF8obG9jYXRpb24sIGJsb2IsIG1ldGFkYXRhKSB7XHJcbiAgICBjb25zdCBtZXRhZGF0YUNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpO1xyXG4gICAgbWV0YWRhdGFDbG9uZVsnZnVsbFBhdGgnXSA9IGxvY2F0aW9uLnBhdGg7XHJcbiAgICBtZXRhZGF0YUNsb25lWydzaXplJ10gPSBibG9iLnNpemUoKTtcclxuICAgIGlmICghbWV0YWRhdGFDbG9uZVsnY29udGVudFR5cGUnXSkge1xyXG4gICAgICAgIG1ldGFkYXRhQ2xvbmVbJ2NvbnRlbnRUeXBlJ10gPSBkZXRlcm1pbmVDb250ZW50VHlwZV8obnVsbCwgYmxvYik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWV0YWRhdGFDbG9uZTtcclxufVxyXG4vKipcclxuICogUHJlcGFyZSBSZXF1ZXN0SW5mbyBmb3IgdXBsb2FkcyBhcyBDb250ZW50LVR5cGU6IG11bHRpcGFydC5cclxuICovXHJcbmZ1bmN0aW9uIG11bHRpcGFydFVwbG9hZChzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MsIGJsb2IsIG1ldGFkYXRhKSB7XHJcbiAgICBjb25zdCB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xyXG4gICAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1Qcm90b2NvbCc6ICdtdWx0aXBhcnQnXHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gZ2VuQm91bmRhcnkoKSB7XHJcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ciArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIGNvbnN0IGJvdW5kYXJ5ID0gZ2VuQm91bmRhcnkoKTtcclxuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ211bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0nICsgYm91bmRhcnk7XHJcbiAgICBjb25zdCBtZXRhZGF0YV8gPSBtZXRhZGF0YUZvclVwbG9hZF8obG9jYXRpb24sIGJsb2IsIG1ldGFkYXRhKTtcclxuICAgIGNvbnN0IG1ldGFkYXRhU3RyaW5nID0gdG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YV8sIG1hcHBpbmdzKTtcclxuICAgIGNvbnN0IHByZUJsb2JQYXJ0ID0gJy0tJyArXHJcbiAgICAgICAgYm91bmRhcnkgK1xyXG4gICAgICAgICdcXHJcXG4nICtcclxuICAgICAgICAnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XFxyXFxuXFxyXFxuJyArXHJcbiAgICAgICAgbWV0YWRhdGFTdHJpbmcgK1xyXG4gICAgICAgICdcXHJcXG4tLScgK1xyXG4gICAgICAgIGJvdW5kYXJ5ICtcclxuICAgICAgICAnXFxyXFxuJyArXHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZTogJyArXHJcbiAgICAgICAgbWV0YWRhdGFfWydjb250ZW50VHlwZSddICtcclxuICAgICAgICAnXFxyXFxuXFxyXFxuJztcclxuICAgIGNvbnN0IHBvc3RCbG9iUGFydCA9ICdcXHJcXG4tLScgKyBib3VuZGFyeSArICctLSc7XHJcbiAgICBjb25zdCBib2R5ID0gRmJzQmxvYi5nZXRCbG9iKHByZUJsb2JQYXJ0LCBibG9iLCBwb3N0QmxvYlBhcnQpO1xyXG4gICAgaWYgKGJvZHkgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBjYW5ub3RTbGljZUJsb2IoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHVybFBhcmFtcyA9IHsgbmFtZTogbWV0YWRhdGFfWydmdWxsUGF0aCddIH07XHJcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xyXG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4VXBsb2FkUmV0cnlUaW1lO1xyXG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIG1ldGFkYXRhSGFuZGxlcihzZXJ2aWNlLCBtYXBwaW5ncyksIHRpbWVvdXQpO1xyXG4gICAgcmVxdWVzdEluZm8udXJsUGFyYW1zID0gdXJsUGFyYW1zO1xyXG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XHJcbiAgICByZXF1ZXN0SW5mby5ib2R5ID0gYm9keS51cGxvYWREYXRhKCk7XHJcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gY3VycmVudCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuIHVwbG9hZGVkIHNvIGZhci5cclxuICogQHBhcmFtIHRvdGFsIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIHVwbG9hZC5cclxuICogQHBhcmFtIG9wdF9maW5hbGl6ZWQgVHJ1ZSBpZiB0aGUgc2VydmVyIGhhcyBmaW5pc2hlZCB0aGUgdXBsb2FkLlxyXG4gKiBAcGFyYW0gb3B0X21ldGFkYXRhIFRoZSB1cGxvYWQgbWV0YWRhdGEsIHNob3VsZFxyXG4gKiAgICAgb25seSBiZSBwYXNzZWQgaWYgb3B0X2ZpbmFsaXplZCBpcyB0cnVlLlxyXG4gKi9cclxuY2xhc3MgUmVzdW1hYmxlVXBsb2FkU3RhdHVzIHtcclxuICAgIGNvbnN0cnVjdG9yKGN1cnJlbnQsIHRvdGFsLCBmaW5hbGl6ZWQsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcclxuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSAhIWZpbmFsaXplZDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEgfHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyLCBhbGxvd2VkKSB7XHJcbiAgICBsZXQgc3RhdHVzID0gbnVsbDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgc3RhdHVzID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUdvb2ctVXBsb2FkLVN0YXR1cycpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBoYW5kbGVyQ2hlY2soZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYWxsb3dlZFN0YXR1cyA9IGFsbG93ZWQgfHwgWydhY3RpdmUnXTtcclxuICAgIGhhbmRsZXJDaGVjayghIXN0YXR1cyAmJiBhbGxvd2VkU3RhdHVzLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTEpO1xyXG4gICAgcmV0dXJuIHN0YXR1cztcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZXN1bWFibGVVcGxvYWQoc2VydmljZSwgbG9jYXRpb24sIG1hcHBpbmdzLCBibG9iLCBtZXRhZGF0YSkge1xyXG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmJ1Y2tldE9ubHlTZXJ2ZXJVcmwoKTtcclxuICAgIGNvbnN0IG1ldGFkYXRhRm9yVXBsb2FkID0gbWV0YWRhdGFGb3JVcGxvYWRfKGxvY2F0aW9uLCBibG9iLCBtZXRhZGF0YSk7XHJcbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7IG5hbWU6IG1ldGFkYXRhRm9yVXBsb2FkWydmdWxsUGF0aCddIH07XHJcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xyXG4gICAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1Qcm90b2NvbCc6ICdyZXN1bWFibGUnLFxyXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLFxyXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LUxlbmd0aCc6IGAke2Jsb2Iuc2l6ZSgpfWAsXHJcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtVHlwZSc6IG1ldGFkYXRhRm9yVXBsb2FkWydjb250ZW50VHlwZSddLFxyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCdcclxuICAgIH07XHJcbiAgICBjb25zdCBib2R5ID0gdG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YUZvclVwbG9hZCwgbWFwcGluZ3MpO1xyXG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4VXBsb2FkUmV0cnlUaW1lO1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIpIHtcclxuICAgICAgICBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyKTtcclxuICAgICAgICBsZXQgdXJsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHVybCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1Hb29nLVVwbG9hZC1VUkwnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaGFuZGxlckNoZWNrKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFuZGxlckNoZWNrKGlzU3RyaW5nKHVybCkpO1xyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XHJcbiAgICByZXF1ZXN0SW5mby51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XHJcbiAgICByZXF1ZXN0SW5mby5oZWFkZXJzID0gaGVhZGVycztcclxuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5O1xyXG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcclxuICAgIHJldHVybiByZXF1ZXN0SW5mbztcclxufVxyXG4vKipcclxuICogQHBhcmFtIHVybCBGcm9tIGEgY2FsbCB0byBmYnMucmVxdWVzdHMuY3JlYXRlUmVzdW1hYmxlVXBsb2FkLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVzdW1hYmxlVXBsb2FkU3RhdHVzKHNlcnZpY2UsIGxvY2F0aW9uLCB1cmwsIGJsb2IpIHtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSB7ICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAncXVlcnknIH07XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhocikge1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGNoZWNrUmVzdW1lSGVhZGVyXyh4aHIsIFsnYWN0aXZlJywgJ2ZpbmFsJ10pO1xyXG4gICAgICAgIGxldCBzaXplU3RyaW5nID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzaXplU3RyaW5nID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUdvb2ctVXBsb2FkLVNpemUtUmVjZWl2ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaGFuZGxlckNoZWNrKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzaXplU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIG51bGwgb3IgZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNpemUgPSBOdW1iZXIoc2l6ZVN0cmluZyk7XHJcbiAgICAgICAgaGFuZGxlckNoZWNrKCFpc05hTihzaXplKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXMoc2l6ZSwgYmxvYi5zaXplKCksIHN0YXR1cyA9PT0gJ2ZpbmFsJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XHJcbiAgICByZXF1ZXN0SW5mby5oZWFkZXJzID0gaGVhZGVycztcclxuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XHJcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XHJcbn1cclxuLyoqXHJcbiAqIEFueSB1cGxvYWRzIHZpYSB0aGUgcmVzdW1hYmxlIHVwbG9hZCBBUEkgbXVzdCB0cmFuc2ZlciBhIG51bWJlciBvZiBieXRlc1xyXG4gKiB0aGF0IGlzIGEgbXVsdGlwbGUgb2YgdGhpcyBudW1iZXIuXHJcbiAqL1xyXG5jb25zdCBSRVNVTUFCTEVfVVBMT0FEX0NIVU5LX1NJWkUgPSAyNTYgKiAxMDI0O1xyXG4vKipcclxuICogQHBhcmFtIHVybCBGcm9tIGEgY2FsbCB0byBmYnMucmVxdWVzdHMuY3JlYXRlUmVzdW1hYmxlVXBsb2FkLlxyXG4gKiBAcGFyYW0gY2h1bmtTaXplIE51bWJlciBvZiBieXRlcyB0byB1cGxvYWQuXHJcbiAqIEBwYXJhbSBzdGF0dXMgVGhlIHByZXZpb3VzIHN0YXR1cy5cclxuICogICAgIElmIG5vdCBwYXNzZWQgb3IgbnVsbCwgd2Ugc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nLlxyXG4gKiBAdGhyb3dzIGZicy5FcnJvciBJZiB0aGUgdXBsb2FkIGlzIGFscmVhZHkgY29tcGxldGUsIHRoZSBwYXNzZWQgaW4gc3RhdHVzXHJcbiAqICAgICBoYXMgYSBmaW5hbCBzaXplIGluY29uc2lzdGVudCB3aXRoIHRoZSBibG9iLCBvciB0aGUgYmxvYiBjYW5ub3QgYmUgc2xpY2VkXHJcbiAqICAgICBmb3IgdXBsb2FkLlxyXG4gKi9cclxuZnVuY3Rpb24gY29udGludWVSZXN1bWFibGVVcGxvYWQobG9jYXRpb24sIHNlcnZpY2UsIHVybCwgYmxvYiwgY2h1bmtTaXplLCBtYXBwaW5ncywgc3RhdHVzLCBwcm9ncmVzc0NhbGxiYWNrKSB7XHJcbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogc3RhbmRhcmRpemUgb24gaW50ZXJuYWwgYXNzZXJ0c1xyXG4gICAgLy8gYXNzZXJ0KCEob3B0X3N0YXR1cyAmJiBvcHRfc3RhdHVzLmZpbmFsaXplZCkpO1xyXG4gICAgY29uc3Qgc3RhdHVzXyA9IG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXMoMCwgMCk7XHJcbiAgICBpZiAoc3RhdHVzKSB7XHJcbiAgICAgICAgc3RhdHVzXy5jdXJyZW50ID0gc3RhdHVzLmN1cnJlbnQ7XHJcbiAgICAgICAgc3RhdHVzXy50b3RhbCA9IHN0YXR1cy50b3RhbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0YXR1c18uY3VycmVudCA9IDA7XHJcbiAgICAgICAgc3RhdHVzXy50b3RhbCA9IGJsb2Iuc2l6ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGJsb2Iuc2l6ZSgpICE9PSBzdGF0dXNfLnRvdGFsKSB7XHJcbiAgICAgICAgdGhyb3cgc2VydmVyRmlsZVdyb25nU2l6ZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYnl0ZXNMZWZ0ID0gc3RhdHVzXy50b3RhbCAtIHN0YXR1c18uY3VycmVudDtcclxuICAgIGxldCBieXRlc1RvVXBsb2FkID0gYnl0ZXNMZWZ0O1xyXG4gICAgaWYgKGNodW5rU2l6ZSA+IDApIHtcclxuICAgICAgICBieXRlc1RvVXBsb2FkID0gTWF0aC5taW4oYnl0ZXNUb1VwbG9hZCwgY2h1bmtTaXplKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0Qnl0ZSA9IHN0YXR1c18uY3VycmVudDtcclxuICAgIGNvbnN0IGVuZEJ5dGUgPSBzdGFydEJ5dGUgKyBieXRlc1RvVXBsb2FkO1xyXG4gICAgbGV0IHVwbG9hZENvbW1hbmQgPSAnJztcclxuICAgIGlmIChieXRlc1RvVXBsb2FkID09PSAwKSB7XHJcbiAgICAgICAgdXBsb2FkQ29tbWFuZCA9ICdmaW5hbGl6ZSc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChieXRlc0xlZnQgPT09IGJ5dGVzVG9VcGxvYWQpIHtcclxuICAgICAgICB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCwgZmluYWxpemUnO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdXBsb2FkQ29tbWFuZCA9ICd1cGxvYWQnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcclxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBgJHtzdGF0dXNfLmN1cnJlbnR9YFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGJvZHkgPSBibG9iLnNsaWNlKHN0YXJ0Qnl0ZSwgZW5kQnl0ZSk7XHJcbiAgICBpZiAoYm9keSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IGNhbm5vdFNsaWNlQmxvYigpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcclxuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogVmVyaWZ5IHRoZSBNRDUgb2YgZWFjaCB1cGxvYWRlZCByYW5nZTpcclxuICAgICAgICAvLyB0aGUgJ3gtcmFuZ2UtbWQ1JyBoZWFkZXIgY29tZXMgYmFjayB3aXRoIHN0YXR1cyBjb2RlIDMwOCByZXNwb25zZXMuXHJcbiAgICAgICAgLy8gV2UnbGwgb25seSBiZSBhYmxlIHRvIGJhaWwgb3V0IHRob3VnaCwgYmVjYXVzZSB5b3UgY2FuJ3QgcmUtdXBsb2FkIGFcclxuICAgICAgICAvLyByYW5nZSB0aGF0IHlvdSBwcmV2aW91c2x5IHVwbG9hZGVkLlxyXG4gICAgICAgIGNvbnN0IHVwbG9hZFN0YXR1cyA9IGNoZWNrUmVzdW1lSGVhZGVyXyh4aHIsIFsnYWN0aXZlJywgJ2ZpbmFsJ10pO1xyXG4gICAgICAgIGNvbnN0IG5ld0N1cnJlbnQgPSBzdGF0dXNfLmN1cnJlbnQgKyBieXRlc1RvVXBsb2FkO1xyXG4gICAgICAgIGNvbnN0IHNpemUgPSBibG9iLnNpemUoKTtcclxuICAgICAgICBsZXQgbWV0YWRhdGE7XHJcbiAgICAgICAgaWYgKHVwbG9hZFN0YXR1cyA9PT0gJ2ZpbmFsJykge1xyXG4gICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhSGFuZGxlcihzZXJ2aWNlLCBtYXBwaW5ncykoeGhyLCB0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXMobmV3Q3VycmVudCwgc2l6ZSwgdXBsb2FkU3RhdHVzID09PSAnZmluYWwnLCBtZXRhZGF0YSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhVcGxvYWRSZXRyeVRpbWU7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XHJcbiAgICByZXF1ZXN0SW5mby5oZWFkZXJzID0gaGVhZGVycztcclxuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5LnVwbG9hZERhdGEoKTtcclxuICAgIHJlcXVlc3RJbmZvLnByb2dyZXNzQ2FsbGJhY2sgPSBwcm9ncmVzc0NhbGxiYWNrIHx8IG51bGw7XHJcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCBvbiBhIHRhc2suXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgVGFza0V2ZW50ID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgdGhpcyBldmVudCxcclxuICAgICAqIDx1bD5cclxuICAgICAqICAgPGxpPlRoZSBgbmV4dGAgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkIG9uIHByb2dyZXNzIHVwZGF0ZXMgYW5kIHdoZW4gdGhlXHJcbiAgICAgKiAgICAgICB0YXNrIGlzIHBhdXNlZC9yZXN1bWVkIHdpdGggYW4gYFVwbG9hZFRhc2tTbmFwc2hvdGAgYXMgdGhlIGZpcnN0XHJcbiAgICAgKiAgICAgICBhcmd1bWVudC48L2xpPlxyXG4gICAgICogICA8bGk+VGhlIGBlcnJvcmAgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkIGlmIHRoZSB1cGxvYWQgaXMgY2FuY2VsZWQgb3IgZmFpbHNcclxuICAgICAqICAgICAgIGZvciBhbm90aGVyIHJlYXNvbi48L2xpPlxyXG4gICAgICogICA8bGk+VGhlIGBjb21wbGV0ZWAgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkIGlmIHRoZSB1cGxvYWQgY29tcGxldGVzXHJcbiAgICAgKiAgICAgICBzdWNjZXNzZnVsbHkuPC9saT5cclxuICAgICAqIDwvdWw+XHJcbiAgICAgKi9cclxuICAgIFNUQVRFX0NIQU5HRUQ6ICdzdGF0ZV9jaGFuZ2VkJ1xyXG59O1xyXG4vLyB0eXBlIGtleXMgPSBrZXlvZiBUYXNrU3RhdGVcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBydW5uaW5nIHVwbG9hZC5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBUYXNrU3RhdGUgPSB7XHJcbiAgICAvKiogVGhlIHRhc2sgaXMgY3VycmVudGx5IHRyYW5zZmVycmluZyBkYXRhLiAqL1xyXG4gICAgUlVOTklORzogJ3J1bm5pbmcnLFxyXG4gICAgLyoqIFRoZSB0YXNrIHdhcyBwYXVzZWQgYnkgdGhlIHVzZXIuICovXHJcbiAgICBQQVVTRUQ6ICdwYXVzZWQnLFxyXG4gICAgLyoqIFRoZSB0YXNrIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuICovXHJcbiAgICBTVUNDRVNTOiAnc3VjY2VzcycsXHJcbiAgICAvKiogVGhlIHRhc2sgd2FzIGNhbmNlbGVkLiAqL1xyXG4gICAgQ0FOQ0VMRUQ6ICdjYW5jZWxlZCcsXHJcbiAgICAvKiogVGhlIHRhc2sgZmFpbGVkIHdpdGggYW4gZXJyb3IuICovXHJcbiAgICBFUlJPUjogJ2Vycm9yJ1xyXG59O1xyXG5mdW5jdGlvbiB0YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGUoc3RhdGUpIHtcclxuICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICBjYXNlIFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi86XHJcbiAgICAgICAgY2FzZSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovOlxyXG4gICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuUlVOTklORztcclxuICAgICAgICBjYXNlIFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovOlxyXG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLlBBVVNFRDtcclxuICAgICAgICBjYXNlIFwic3VjY2Vzc1wiIC8qIEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuU1VDQ0VTUztcclxuICAgICAgICBjYXNlIFwiY2FuY2VsZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5DQU5DRUxFRDtcclxuICAgICAgICBjYXNlIFwiZXJyb3JcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5FUlJPUjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5FUlJPUjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBPYnNlcnZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XHJcbiAgICAgICAgY29uc3QgYXNGdW5jdGlvbnMgPSBpc0Z1bmN0aW9uKG5leHRPck9ic2VydmVyKSB8fCBlcnJvciAhPSBudWxsIHx8IGNvbXBsZXRlICE9IG51bGw7XHJcbiAgICAgICAgaWYgKGFzRnVuY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHRPck9ic2VydmVyO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3IgIT09IG51bGwgJiYgZXJyb3IgIT09IHZvaWQgMCA/IGVycm9yIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGUgIT09IG51bGwgJiYgY29tcGxldGUgIT09IHZvaWQgMCA/IGNvbXBsZXRlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcclxuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb2JzZXJ2ZXIubmV4dDtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG9ic2VydmVyLmVycm9yO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGYgd2l0aCBpdHMgYXJndW1lbnRzIGFzeW5jaHJvbm91c2x5IGFzIGFcclxuICogbWljcm90YXNrLCBpLmUuIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgc2NyaXB0IHJldHVybnMgYmFja1xyXG4gKiBpbnRvIGJyb3dzZXIgY29kZS5cclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmZ1bmN0aW9uIGFzeW5jKGYpIHtcclxuICAgIHJldHVybiAoLi4uYXJnc1RvRm9yd2FyZCkgPT4ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGYoLi4uYXJnc1RvRm9yd2FyZCkpO1xyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogQW4gb3ZlcnJpZGUgZm9yIHRoZSB0ZXh0LWJhc2VkIENvbm5lY3Rpb24uIFVzZWQgaW4gdGVzdHMuICovXHJcbmxldCB0ZXh0RmFjdG9yeU92ZXJyaWRlID0gbnVsbDtcclxuLyoqXHJcbiAqIE5ldHdvcmsgbGF5ZXIgdGhhdCB3b3JrcyBpbiBOb2RlLlxyXG4gKlxyXG4gKiBUaGlzIG5ldHdvcmsgaW1wbGVtZW50YXRpb24gc2hvdWxkIG5vdCBiZSB1c2VkIGluIGJyb3dzZXJzIGFzIGl0IGRvZXMgbm90XHJcbiAqIHN1cHBvcnQgcHJvZ3Jlc3MgdXBkYXRlcy5cclxuICovXHJcbmNsYXNzIEZldGNoQ29ubmVjdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmVycm9yVGV4dF8gPSAnJztcclxuICAgICAgICB0aGlzLnNlbnRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mZXRjaF8gPSBmZXRjaDtcclxuICAgICAgICB0aGlzLmVycm9yQ29kZV8gPSBFcnJvckNvZGUuTk9fRVJST1I7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kKHVybCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VudF8pIHtcclxuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5zZW5kKCkgbW9yZSB0aGFuIG9uY2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW50XyA9IHRydWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoXyh1cmwsIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMgfHwge30sXHJcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNfID0gcmVzcG9uc2UuaGVhZGVycztcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IHJlc3BvbnNlLnN0YXR1cztcclxuICAgICAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gRXJyb3JDb2RlLk5PX0VSUk9SO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlfID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvclRleHRfID0gZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIC8vIGVtdWxhdGUgWEhSIHdoaWNoIHNldHMgc3RhdHVzIHRvIDAgd2hlbiBlbmNvdW50ZXJpbmcgYSBuZXR3b3JrIGVycm9yXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZV8gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZV8gPSBFcnJvckNvZGUuTkVUV09SS19FUlJPUjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRFcnJvckNvZGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JDb2RlXyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0RXJyb3JDb2RlKCkgYmVmb3JlIHJlY2VpdmluZyByZXNwb25zZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvZGVfO1xyXG4gICAgfVxyXG4gICAgZ2V0U3RhdHVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXR1c0NvZGVfID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRTdGF0dXMoKSBiZWZvcmUgcmVjZWl2aW5nIHJlc3BvbnNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1c0NvZGVfO1xyXG4gICAgfVxyXG4gICAgZ2V0RXJyb3JUZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yVGV4dF87XHJcbiAgICB9XHJcbiAgICBhYm9ydCgpIHtcclxuICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkXHJcbiAgICB9XHJcbiAgICBnZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhZGVyc18pIHtcclxuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRSZXNwb25zZUhlYWRlcigpIGJlZm9yZSByZWNlaXZpbmcgcmVzcG9uc2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc18uZ2V0KGhlYWRlcik7XHJcbiAgICB9XHJcbiAgICBhZGRVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gTm90IHN1cHBvcnRlZFxyXG4gICAgfVxyXG4gICAgcmVtb3ZlVXBsb2FkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIE5vdCBzdXBwb3J0ZWRcclxuICAgIH1cclxufVxyXG5jbGFzcyBGZXRjaFRleHRDb25uZWN0aW9uIGV4dGVuZHMgRmV0Y2hDb25uZWN0aW9uIHtcclxuICAgIGdldFJlc3BvbnNlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ib2R5Xykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFJlc3BvbnNlKCkgYmVmb3JlIHJlY2VpdmluZyByZXNwb25zZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5ib2R5XykudG9TdHJpbmcoJ3V0Zi04Jyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3VGV4dENvbm5lY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGV4dEZhY3RvcnlPdmVycmlkZVxyXG4gICAgICAgID8gdGV4dEZhY3RvcnlPdmVycmlkZSgpXHJcbiAgICAgICAgOiBuZXcgRmV0Y2hUZXh0Q29ubmVjdGlvbigpO1xyXG59XHJcbmNsYXNzIEZldGNoQnl0ZXNDb25uZWN0aW9uIGV4dGVuZHMgRmV0Y2hDb25uZWN0aW9uIHtcclxuICAgIGdldFJlc3BvbnNlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ib2R5Xykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFJlc3BvbnNlKCkgYmVmb3JlIHNlbmRpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keV87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3Qnl0ZXNDb25uZWN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG5ldyBGZXRjaEJ5dGVzQ29ubmVjdGlvbigpO1xyXG59XHJcbmNsYXNzIEZldGNoU3RyZWFtQ29ubmVjdGlvbiBleHRlbmRzIEZldGNoQ29ubmVjdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtXyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kKHVybCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VudF8pIHtcclxuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5zZW5kKCkgbW9yZSB0aGFuIG9uY2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW50XyA9IHRydWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoXyh1cmwsIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMgfHwge30sXHJcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNfID0gcmVzcG9uc2UuaGVhZGVycztcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IHJlc3BvbnNlLnN0YXR1cztcclxuICAgICAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gRXJyb3JDb2RlLk5PX0VSUk9SO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbV8gPSByZXNwb25zZS5ib2R5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yVGV4dF8gPSBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZTtcclxuICAgICAgICAgICAgLy8gZW11bGF0ZSBYSFIgd2hpY2ggc2V0cyBzdGF0dXMgdG8gMCB3aGVuIGVuY291bnRlcmluZyBhIG5ldHdvcmsgZXJyb3JcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb2RlXyA9IEVycm9yQ29kZS5ORVRXT1JLX0VSUk9SO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFJlc3BvbnNlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5zdHJlYW1fKSB7XHJcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0UmVzcG9uc2UoKSBiZWZvcmUgc2VuZGluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1fO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1N0cmVhbUNvbm5lY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IEZldGNoU3RyZWFtQ29ubmVjdGlvbigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYmxvYiBiZWluZyB1cGxvYWRlZC4gQ2FuIGJlIHVzZWQgdG8gcGF1c2UvcmVzdW1lL2NhbmNlbCB0aGVcclxuICogdXBsb2FkIGFuZCBtYW5hZ2UgY2FsbGJhY2tzIGZvciB2YXJpb3VzIGV2ZW50cy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBVcGxvYWRUYXNrIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlZiAtIFRoZSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIG9iamVjdCB0aGlzIHRhc2sgY2FtZVxyXG4gICAgICogICAgIGZyb20sIHVudHlwZWQgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY2llcy5cclxuICAgICAqIEBwYXJhbSBibG9iIC0gVGhlIGJsb2IgdG8gdXBsb2FkLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZWYsIGJsb2IsIG1ldGFkYXRhID0gbnVsbCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiBieXRlcyB0cmFuc2ZlcnJlZCBzbyBmYXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdHJhbnNmZXJyZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hNZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2Vycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3VwbG9hZFVybCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2NodW5rTXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9yZWplY3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fcmVmID0gcmVmO1xyXG4gICAgICAgIHRoaXMuX2Jsb2IgPSBibG9iO1xyXG4gICAgICAgIHRoaXMuX21ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5fbWFwcGluZ3MgPSBnZXRNYXBwaW5ncygpO1xyXG4gICAgICAgIHRoaXMuX3Jlc3VtYWJsZSA9IHRoaXMuX3Nob3VsZERvUmVzdW1hYmxlKHRoaXMuX2Jsb2IpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLztcclxuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXIgPSBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2NodW5rTXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5fY29kZUVxdWFscyhTdG9yYWdlRXJyb3JDb2RlLkNBTkNFTEVEKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hTdGF0dXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFja29mZkV4cGlyZWQgPSB0aGlzLmlzRXhwb25lbnRpYWxCYWNrb2ZmRXhwaXJlZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmV0cnlTdGF0dXNDb2RlKGVycm9yLnN0YXR1cywgW10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhY2tvZmZFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gcmV0cnlMaW1pdEV4Y2VlZGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNsZWVwVGltZSA9IE1hdGgubWF4KHRoaXMuc2xlZXBUaW1lICogMiwgREVGQVVMVF9NSU5fU0xFRVBfVElNRV9NSUxMSVMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiZXJyb3JcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX21ldGFkYXRhRXJyb3JIYW5kbGVyID0gZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IuX2NvZGVFcXVhbHMoU3RvcmFnZUVycm9yQ29kZS5DQU5DRUxFRCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiZXJyb3JcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2xlZXBUaW1lID0gMDtcclxuICAgICAgICB0aGlzLm1heFNsZWVwVGltZSA9IHRoaXMuX3JlZi5zdG9yYWdlLm1heFVwbG9hZFJldHJ5VGltZTtcclxuICAgICAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFByZXZlbnQgdW5jYXVnaHQgcmVqZWN0aW9ucyBvbiB0aGUgaW50ZXJuYWwgcHJvbWlzZSBmcm9tIGJ1YmJsaW5nIG91dFxyXG4gICAgICAgIC8vIHRvIHRoZSB0b3AgbGV2ZWwgd2l0aCBhIGR1bW15IGhhbmRsZXIuXHJcbiAgICAgICAgdGhpcy5fcHJvbWlzZS50aGVuKG51bGwsICgpID0+IHsgfSk7XHJcbiAgICB9XHJcbiAgICBpc0V4cG9uZW50aWFsQmFja29mZkV4cGlyZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xlZXBUaW1lID4gdGhpcy5tYXhTbGVlcFRpbWU7XHJcbiAgICB9XHJcbiAgICBfbWFrZVByb2dyZXNzQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZUJlZm9yZSA9IHRoaXMuX3RyYW5zZmVycmVkO1xyXG4gICAgICAgIHJldHVybiBsb2FkZWQgPT4gdGhpcy5fdXBkYXRlUHJvZ3Jlc3Moc2l6ZUJlZm9yZSArIGxvYWRlZCk7XHJcbiAgICB9XHJcbiAgICBfc2hvdWxkRG9SZXN1bWFibGUoYmxvYikge1xyXG4gICAgICAgIHJldHVybiBibG9iLnNpemUoKSA+IDI1NiAqIDEwMjQ7XHJcbiAgICB9XHJcbiAgICBfc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBzb21lb25lIHBhdXNlcyB1cyBpbiBhIHJlc3VtZSBjYWxsYmFjaywgZm9yIGV4YW1wbGUuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9yZXN1bWFibGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3VwbG9hZFVybCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXN1bWFibGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZldGNoU3RhdHVzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmVlZFRvRmV0Y2hNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXBwZW5zIGlmIHdlIG1pc3MgdGhlIG1ldGFkYXRhIG9uIHVwbG9hZCBjb21wbGV0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mZXRjaE1ldGFkYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lb3V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGludWVVcGxvYWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zbGVlcFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fb25lU2hvdFVwbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZXNvbHZlVG9rZW4oY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLl9yZWYuc3RvcmFnZS5fZ2V0QXV0aFRva2VuKCksXHJcbiAgICAgICAgICAgIHRoaXMuX3JlZi5zdG9yYWdlLl9nZXRBcHBDaGVja1Rva2VuKClcclxuICAgICAgICBdKS50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImNhbmNlbGVkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMRUQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0IGZhbHNlXHJcbiAgICBfY3JlYXRlUmVzdW1hYmxlKCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gY3JlYXRlUmVzdW1hYmxlVXBsb2FkKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncywgdGhpcy5fYmxvYiwgdGhpcy5fbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXF1ZXN0ID0gdGhpcy5fcmVmLnN0b3JhZ2UuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbiwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3Q7XHJcbiAgICAgICAgICAgIGNyZWF0ZVJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4oKHVybCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZFVybCA9IHVybDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZmV0Y2hTdGF0dXMoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydCh0aGlzLnVwbG9hZFVybF8gIT09IG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VwbG9hZFVybDtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlVG9rZW4oKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldFJlc3VtYWJsZVVwbG9hZFN0YXR1cyh0aGlzLl9yZWYuc3RvcmFnZSwgdGhpcy5fcmVmLl9sb2NhdGlvbiwgdXJsLCB0aGlzLl9ibG9iKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzUmVxdWVzdCA9IHRoaXMuX3JlZi5zdG9yYWdlLl9tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24sIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBzdGF0dXNSZXF1ZXN0O1xyXG4gICAgICAgICAgICBzdGF0dXNSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKHN0YXR1cyA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3Moc3RhdHVzLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hTdGF0dXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hNZXRhZGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfY29udGludWVVcGxvYWQoKSB7XHJcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gUkVTVU1BQkxFX1VQTE9BRF9DSFVOS19TSVpFICogdGhpcy5fY2h1bmtNdWx0aXBsaWVyO1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBSZXN1bWFibGVVcGxvYWRTdGF0dXModGhpcy5fdHJhbnNmZXJyZWQsIHRoaXMuX2Jsb2Iuc2l6ZSgpKTtcclxuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KHRoaXMudXBsb2FkVXJsXyAhPT0gbnVsbCk7XHJcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5fdXBsb2FkVXJsO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZXF1ZXN0SW5mbztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJbmZvID0gY29udGludWVSZXN1bWFibGVVcGxvYWQodGhpcy5fcmVmLl9sb2NhdGlvbiwgdGhpcy5fcmVmLnN0b3JhZ2UsIHVybCwgdGhpcy5fYmxvYiwgY2h1bmtTaXplLCB0aGlzLl9tYXBwaW5ncywgc3RhdHVzLCB0aGlzLl9tYWtlUHJvZ3Jlc3NDYWxsYmFjaygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZFJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIFxyXG4gICAgICAgICAgICAvKnJldHJ5PSovIGZhbHNlIC8vIFVwbG9hZCByZXF1ZXN0cyBzaG91bGQgbm90IGJlIHJldHJpZWQgYXMgZWFjaCByZXRyeSBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYW5vdGhlciBxdWVyeSByZXF1ZXN0LiBXaGljaCBpcyBoYW5kbGVkIGluIHRoaXMgZmlsZS5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVwbG9hZFJlcXVlc3Q7XHJcbiAgICAgICAgICAgIHVwbG9hZFJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4oKG5ld1N0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVhc2VNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3MobmV3U3RhdHVzLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IG5ld1N0YXR1cy5tZXRhZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwic3VjY2Vzc1wiIC8qIEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzLl9lcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2luY3JlYXNlTXVsdGlwbGllcigpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IFJFU1VNQUJMRV9VUExPQURfQ0hVTktfU0laRSAqIHRoaXMuX2NodW5rTXVsdGlwbGllcjtcclxuICAgICAgICAvLyBNYXggY2h1bmsgc2l6ZSBpcyAzMk0uXHJcbiAgICAgICAgaWYgKGN1cnJlbnRTaXplICogMiA8IDMyICogMTAyNCAqIDEwMjQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2h1bmtNdWx0aXBsaWVyICo9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2ZldGNoTWV0YWRhdGEoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRNZXRhZGF0YSQyKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhUmVxdWVzdCA9IHRoaXMuX3JlZi5zdG9yYWdlLl9tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24sIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBtZXRhZGF0YVJlcXVlc3Q7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbihtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJzdWNjZXNzXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyAqLyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMuX21ldGFkYXRhRXJyb3JIYW5kbGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vbmVTaG90VXBsb2FkKCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbXVsdGlwYXJ0VXBsb2FkKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncywgdGhpcy5fYmxvYiwgdGhpcy5fbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICBjb25zdCBtdWx0aXBhcnRSZXF1ZXN0ID0gdGhpcy5fcmVmLnN0b3JhZ2UuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbiwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG11bHRpcGFydFJlcXVlc3Q7XHJcbiAgICAgICAgICAgIG11bHRpcGFydFJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4obWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcyh0aGlzLl9ibG9iLnNpemUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwic3VjY2Vzc1wiIC8qIEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MgKi8pO1xyXG4gICAgICAgICAgICB9LCB0aGlzLl9lcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVByb2dyZXNzKHRyYW5zZmVycmVkKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5fdHJhbnNmZXJyZWQ7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmZXJyZWQgPSB0cmFuc2ZlcnJlZDtcclxuICAgICAgICAvLyBBIHByb2dyZXNzIHVwZGF0ZSBjYW4gbWFrZSB0aGUgXCJ0cmFuc2ZlcnJlZFwiIHZhbHVlIHNtYWxsZXIgKGUuZy4gYVxyXG4gICAgICAgIC8vIHBhcnRpYWwgdXBsb2FkIG5vdCBjb21wbGV0ZWQgYnkgc2VydmVyLCBhZnRlciB3aGljaCB0aGUgXCJ0cmFuc2ZlcnJlZFwiXHJcbiAgICAgICAgLy8gdmFsdWUgbWF5IHJlc2V0IHRvIHRoZSB2YWx1ZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZXF1ZXN0KS5cclxuICAgICAgICBpZiAodGhpcy5fdHJhbnNmZXJyZWQgIT09IG9sZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdHJhbnNpdGlvbihzdGF0ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gc3RhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLzpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lb3V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi86XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzUGF1c2VkID0gdGhpcy5fc3RhdGUgPT09IFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmICh3YXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi86XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGVkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMRUQgKi86XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGNhbmNlbGVkKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi86XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyB8fFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovOlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XHJcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgfHxcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyB8fFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVycygpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29tcGxldGVUcmFuc2l0aW9uc18oKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi86XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HICovOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImNhbmNlbGVkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMRUQgKi8pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgdGFzayBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNuYXBzaG90KCkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVybmFsU3RhdGUgPSB0YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGUodGhpcy5fc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJ5dGVzVHJhbnNmZXJyZWQ6IHRoaXMuX3RyYW5zZmVycmVkLFxyXG4gICAgICAgICAgICB0b3RhbEJ5dGVzOiB0aGlzLl9ibG9iLnNpemUoKSxcclxuICAgICAgICAgICAgc3RhdGU6IGV4dGVybmFsU3RhdGUsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLl9tZXRhZGF0YSxcclxuICAgICAgICAgICAgdGFzazogdGhpcyxcclxuICAgICAgICAgICAgcmVmOiB0aGlzLl9yZWZcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgY2FsbGJhY2sgZm9yIGFuIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxyXG4gICAgICogQHBhcmFtIG5leHRPck9ic2VydmVyIC1cclxuICAgICAqICAgICBUaGUgYG5leHRgIGZ1bmN0aW9uLCB3aGljaCBnZXRzIGNhbGxlZCBmb3IgZWFjaCBpdGVtIGluXHJcbiAgICAgKiAgICAgdGhlIGV2ZW50IHN0cmVhbSwgb3IgYW4gb2JzZXJ2ZXIgb2JqZWN0IHdpdGggc29tZSBvciBhbGwgb2YgdGhlc2UgdGhyZWVcclxuICAgICAqICAgICBwcm9wZXJ0aWVzIChgbmV4dGAsIGBlcnJvcmAsIGBjb21wbGV0ZWApLlxyXG4gICAgICogQHBhcmFtIGVycm9yIC0gQSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdpdGggYSBgU3RvcmFnZUVycm9yYFxyXG4gICAgICogICAgIGlmIHRoZSBldmVudCBzdHJlYW0gZW5kcyBkdWUgdG8gYW4gZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gY29tcGxldGVkIC0gQSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGlmIHRoZVxyXG4gICAgICogICAgIGV2ZW50IHN0cmVhbSBlbmRzIG5vcm1hbGx5LlxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqICAgICBJZiBvbmx5IHRoZSBldmVudCBhcmd1bWVudCBpcyBwYXNzZWQsIHJldHVybnMgYSBmdW5jdGlvbiB5b3UgY2FuIHVzZSB0b1xyXG4gICAgICogICAgIGFkZCBjYWxsYmFja3MgKHNlZSB0aGUgZXhhbXBsZXMgYWJvdmUpLiBJZiBtb3JlIHRoYW4ganVzdCB0aGUgZXZlbnRcclxuICAgICAqICAgICBhcmd1bWVudCBpcyBwYXNzZWQsIHJldHVybnMgYSBmdW5jdGlvbiB5b3UgY2FuIGNhbGwgdG8gdW5yZWdpc3RlciB0aGVcclxuICAgICAqICAgICBjYWxsYmFja3MuXHJcbiAgICAgKi9cclxuICAgIG9uKHR5cGUsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICAgICAgLy8gTm90ZTogYHR5cGVgIGlzbid0IGJlaW5nIHVzZWQuIEl0cyB0eXBlIGlzIGFsc28gaW5jb3JyZWN0LiBUYXNrRXZlbnQgc2hvdWxkIG5vdCBiZSBhIHN0cmluZy5cclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBPYnNlcnZlcihuZXh0T3JPYnNlcnZlciB8fCB1bmRlZmluZWQsIGVycm9yIHx8IHVuZGVmaW5lZCwgY29tcGxldGVkIHx8IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5fYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG9iamVjdCBiZWhhdmVzIGxpa2UgYSBQcm9taXNlLCBhbmQgcmVzb2x2ZXMgd2l0aCBpdHMgc25hcHNob3QgZGF0YVxyXG4gICAgICogd2hlbiB0aGUgdXBsb2FkIGNvbXBsZXRlcy5cclxuICAgICAqIEBwYXJhbSBvbkZ1bGZpbGxlZCAtIFRoZSBmdWxmaWxsbWVudCBjYWxsYmFjay4gUHJvbWlzZSBjaGFpbmluZyB3b3JrcyBhcyBub3JtYWwuXHJcbiAgICAgKiBAcGFyYW0gb25SZWplY3RlZCAtIFRoZSByZWplY3Rpb24gY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICAvLyBUaGVzZSBjYXN0cyBhcmUgbmVlZGVkIHNvIHRoYXQgVHlwZVNjcmlwdCBjYW4gaW5mZXIgdGhlIHR5cGVzIG9mIHRoZVxyXG4gICAgICAgIC8vIHJlc3VsdGluZyBQcm9taXNlLlxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYHRoZW4obnVsbCwgb25SZWplY3RlZClgLlxyXG4gICAgICovXHJcbiAgICBjYXRjaChvblJlamVjdGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gb2JzZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIF9hZGRPYnNlcnZlcihvYnNlcnZlcikge1xyXG4gICAgICAgIHRoaXMuX29ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcihvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIG9ic2VydmVyLlxyXG4gICAgICovXHJcbiAgICBfcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcclxuICAgICAgICBjb25zdCBpID0gdGhpcy5fb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9ub3RpZnlPYnNlcnZlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fZmluaXNoUHJvbWlzZSgpO1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5zbGljZSgpO1xyXG4gICAgICAgIG9ic2VydmVycy5mb3JFYWNoKG9ic2VydmVyID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2ZpbmlzaFByb21pc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZXQgdHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3dpdGNoICh0YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGUodGhpcy5fc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5TVUNDRVNTOlxyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKHRoaXMuX3Jlc29sdmUuYmluZChudWxsLCB0aGlzLnNuYXBzaG90KSkoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkNBTkNFTEVEOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuRVJST1I6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9DYWxsID0gdGhpcy5fcmVqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKHRvQ2FsbC5iaW5kKG51bGwsIHRoaXMuX2Vycm9yKSkoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyaWdnZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9ub3RpZnlPYnNlcnZlcihvYnNlcnZlcikge1xyXG4gICAgICAgIGNvbnN0IGV4dGVybmFsU3RhdGUgPSB0YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGUodGhpcy5fc3RhdGUpO1xyXG4gICAgICAgIHN3aXRjaCAoZXh0ZXJuYWxTdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5SVU5OSU5HOlxyXG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5QQVVTRUQ6XHJcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlciwgdGhpcy5zbmFwc2hvdCkpKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuU1VDQ0VTUzpcclxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLmNvbXBsZXRlLmJpbmQob2JzZXJ2ZXIpKSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkNBTkNFTEVEOlxyXG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5FUlJPUjpcclxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIsIHRoaXMuX2Vycm9yKSkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3luYyhvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyLCB0aGlzLl9lcnJvcikpKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN1bWVzIGEgcGF1c2VkIHRhc2suIEhhcyBubyBlZmZlY3Qgb24gYSBjdXJyZW50bHkgcnVubmluZyBvciBmYWlsZWQgdGFzay5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9wZXJhdGlvbiB0b29rIGVmZmVjdCwgZmFsc2UgaWYgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc3RhdGUgPT09IFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID09PSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovO1xyXG4gICAgICAgIGlmICh2YWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsaWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhdXNlcyBhIGN1cnJlbnRseSBydW5uaW5nIHRhc2suIEhhcyBubyBlZmZlY3Qgb24gYSBwYXVzZWQgb3IgZmFpbGVkIHRhc2suXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvcGVyYXRpb24gdG9vayBlZmZlY3QsIGZhbHNlIGlmIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc3RhdGUgPT09IFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi87XHJcbiAgICAgICAgaWYgKHZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWxpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyBhIGN1cnJlbnRseSBydW5uaW5nIG9yIHBhdXNlZCB0YXNrLiBIYXMgbm8gZWZmZWN0IG9uIGEgY29tcGxldGUgb3JcclxuICAgICAqIGZhaWxlZCB0YXNrLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxyXG4gICAgICovXHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLyB8fFxyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLztcclxuICAgICAgICBpZiAodmFsaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImNhbmNlbGluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWxpZDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdmlkZXMgbWV0aG9kcyB0byBpbnRlcmFjdCB3aXRoIGEgYnVja2V0IGluIHRoZSBGaXJlYmFzZSBTdG9yYWdlIHNlcnZpY2UuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0gX2xvY2F0aW9uIC0gQW4gZmJzLmxvY2F0aW9uLCBvciB0aGUgVVJMIGF0XHJcbiAqICAgICB3aGljaCB0byBiYXNlIHRoaXMgb2JqZWN0LCBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcclxuICogICAgICAgICBnczovLzxidWNrZXQ+LzxvYmplY3QtcGF0aD5cclxuICogICAgICAgICBodHRwW3NdOi8vZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tL1xyXG4gKiAgICAgICAgICAgICAgICAgICAgIDxhcGktdmVyc2lvbj4vYi88YnVja2V0Pi9vLzxvYmplY3QtcGF0aD5cclxuICogICAgIEFueSBxdWVyeSBvciBmcmFnbWVudCBzdHJpbmdzIHdpbGwgYmUgaWdub3JlZCBpbiB0aGUgaHR0cFtzXVxyXG4gKiAgICAgZm9ybWF0LiBJZiBubyB2YWx1ZSBpcyBwYXNzZWQsIHRoZSBzdG9yYWdlIG9iamVjdCB3aWxsIHVzZSBhIFVSTCBiYXNlZCBvblxyXG4gKiAgICAgdGhlIHByb2plY3QgSUQgb2YgdGhlIGJhc2UgZmlyZWJhc2UuQXBwIGluc3RhbmNlLlxyXG4gKi9cclxuY2xhc3MgUmVmZXJlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKF9zZXJ2aWNlLCBsb2NhdGlvbikge1xyXG4gICAgICAgIHRoaXMuX3NlcnZpY2UgPSBfc2VydmljZTtcclxuICAgICAgICBpZiAobG9jYXRpb24gaW5zdGFuY2VvZiBMb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBMb2NhdGlvbi5tYWtlRnJvbVVybChsb2NhdGlvbiwgX3NlcnZpY2UuaG9zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgZm9yIHRoZSBidWNrZXQgYW5kIHBhdGggdGhpcyBvYmplY3QgcmVmZXJlbmNlcyxcclxuICAgICAqICAgICBpbiB0aGUgZm9ybSBnczovLzxidWNrZXQ+LzxvYmplY3QtcGF0aD5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJ2dzOi8vJyArIHRoaXMuX2xvY2F0aW9uLmJ1Y2tldCArICcvJyArIHRoaXMuX2xvY2F0aW9uLnBhdGg7XHJcbiAgICB9XHJcbiAgICBfbmV3UmVmKHNlcnZpY2UsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2Uoc2VydmljZSwgbG9jYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBvZiB0aGlzIG9iamVjdCdzIGJ1Y2tldC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvb3QoKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24odGhpcy5fbG9jYXRpb24uYnVja2V0LCAnJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld1JlZih0aGlzLl9zZXJ2aWNlLCBsb2NhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBidWNrZXQgY29udGFpbmluZyB0aGlzIHJlZmVyZW5jZSdzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJ1Y2tldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24uYnVja2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVsbCBwYXRoIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBnZXQgZnVsbFBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnBhdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaG9ydCBuYW1lIG9mIHRoaXMgb2JqZWN0LCB3aGljaCBpcyB0aGUgbGFzdCBjb21wb25lbnQgb2YgdGhlIGZ1bGwgcGF0aC5cclxuICAgICAqIEZvciBleGFtcGxlLCBpZiBmdWxsUGF0aCBpcyAnZnVsbC9wYXRoL2ltYWdlLnBuZycsIG5hbWUgaXMgJ2ltYWdlLnBuZycuXHJcbiAgICAgKi9cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiBsYXN0Q29tcG9uZW50KHRoaXMuX2xvY2F0aW9uLnBhdGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYFN0b3JhZ2VTZXJ2aWNlYCBpbnN0YW5jZSB0aGlzIGBTdG9yYWdlUmVmZXJlbmNlYCBpcyBhc3NvY2lhdGVkIHdpdGguXHJcbiAgICAgKi9cclxuICAgIGdldCBzdG9yYWdlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBTdG9yYWdlUmVmZXJlbmNlYCBwb2ludGluZyB0byB0aGUgcGFyZW50IGxvY2F0aW9uIG9mIHRoaXMgYFN0b3JhZ2VSZWZlcmVuY2VgLCBvciBudWxsIGlmXHJcbiAgICAgKiB0aGlzIHJlZmVyZW5jZSBpcyB0aGUgcm9vdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICBjb25zdCBuZXdQYXRoID0gcGFyZW50KHRoaXMuX2xvY2F0aW9uLnBhdGgpO1xyXG4gICAgICAgIGlmIChuZXdQYXRoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzLl9sb2NhdGlvbi5idWNrZXQsIG5ld1BhdGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMuX3NlcnZpY2UsIGxvY2F0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0byB0aHJvdyBhbiBlcnJvciBpbiBtZXRob2RzIHRoYXQgZG8gbm90IGFjY2VwdCBhIHJvb3QgcmVmZXJlbmNlLlxyXG4gICAgICovXHJcbiAgICBfdGhyb3dJZlJvb3QobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2NhdGlvbi5wYXRoID09PSAnJykge1xyXG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUm9vdE9wZXJhdGlvbihuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERvd25sb2FkIHRoZSBieXRlcyBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIHRoZSBkb3dubG9hZGVkIGJ5dGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qnl0ZXNJbnRlcm5hbChyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XHJcbiAgICByZWYuX3Rocm93SWZSb290KCdnZXRCeXRlcycpO1xyXG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRCeXRlcyQxKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBtYXhEb3dubG9hZFNpemVCeXRlcyk7XHJcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2VcclxuICAgICAgICAubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdCeXRlc0Nvbm5lY3Rpb24pXHJcbiAgICAgICAgLnRoZW4oYnl0ZXMgPT4gbWF4RG93bmxvYWRTaXplQnl0ZXMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gLy8gR0NTIG1heSBub3QgaG9ub3IgdGhlIFJhbmdlIGhlYWRlciBmb3Igc21hbGwgZmlsZXNcclxuICAgICAgICAgICAgYnl0ZXMuc2xpY2UoMCwgbWF4RG93bmxvYWRTaXplQnl0ZXMpXHJcbiAgICAgICAgOiBieXRlcyk7XHJcbn1cclxuLyoqIFN0cmVhbSB0aGUgYnl0ZXMgYXQgdGhlIG9iamVjdCdzIGxvY2F0aW9uLiAqL1xyXG5mdW5jdGlvbiBnZXRTdHJlYW1JbnRlcm5hbChyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XHJcbiAgICByZWYuX3Rocm93SWZSb290KCdnZXRTdHJlYW0nKTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gZ2V0Qnl0ZXMkMShyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpO1xyXG4gICAgLyoqIEEgdHJhbnNmb3JtZXIgdGhhdCBwYXNzZXMgdGhyb3VnaCB0aGUgZmlyc3QgbiBieXRlcy4gKi9cclxuICAgIGNvbnN0IG5ld01heFNpemVUcmFuc2Zvcm0gPSBuID0+IHtcclxuICAgICAgICBsZXQgbWlzc2luZ0J5dGVzID0gbjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgLy8gR0NTIG1heSBub3QgaG9ub3IgdGhlIFJhbmdlIGhlYWRlciBmb3Igc21hbGwgZmlsZXNcclxuICAgICAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPCBtaXNzaW5nQnl0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdCeXRlcyAtPSBjaHVuay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goY2h1bmsuc2xpY2UoMCwgbWlzc2luZ0J5dGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG1heERvd25sb2FkU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcclxuICAgICAgICA/IG5ldyBUcmFuc2Zvcm0obmV3TWF4U2l6ZVRyYW5zZm9ybShtYXhEb3dubG9hZFNpemVCeXRlcykpXHJcbiAgICAgICAgOiBuZXcgUGFzc1Rocm91Z2goKTtcclxuICAgIHJlZi5zdG9yYWdlXHJcbiAgICAgICAgLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3U3RyZWFtQ29ubmVjdGlvbilcclxuICAgICAgICAudGhlbihzdHJlYW0gPT4gc3RyZWFtLnBpcGUocmVzdWx0KSlcclxuICAgICAgICAuY2F0Y2goZSA9PiByZXN1bHQuZGVzdHJveShlKSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBVcGxvYWRzIGRhdGEgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cclxuICogVGhlIHVwbG9hZCBpcyBub3QgcmVzdW1hYmxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSB1cGxvYWRlZC5cclxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1cGxvYWQuXHJcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgbmV3bHkgdXBsb2FkZWQgZGF0YS5cclxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gVXBsb2FkUmVzdWx0XHJcbiAqL1xyXG5mdW5jdGlvbiB1cGxvYWRCeXRlcyQxKHJlZiwgZGF0YSwgbWV0YWRhdGEpIHtcclxuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ3VwbG9hZEJ5dGVzJyk7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG11bHRpcGFydFVwbG9hZChyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgZ2V0TWFwcGluZ3MoKSwgbmV3IEZic0Jsb2IoZGF0YSwgdHJ1ZSksIG1ldGFkYXRhKTtcclxuICAgIHJldHVybiByZWYuc3RvcmFnZVxyXG4gICAgICAgIC5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKVxyXG4gICAgICAgIC50aGVuKGZpbmFsTWV0YWRhdGEgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiBmaW5hbE1ldGFkYXRhLFxyXG4gICAgICAgICAgICByZWZcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFVwbG9hZHMgZGF0YSB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxyXG4gKiBUaGUgdXBsb2FkIGNhbiBiZSBwYXVzZWQgYW5kIHJlc3VtZWQsIGFuZCBleHBvc2VzIHByb2dyZXNzIHVwZGF0ZXMuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2Ugd2hlcmUgZGF0YSBzaG91bGQgYmUgdXBsb2FkZWQuXHJcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXBsb2FkLlxyXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIG5ld2x5IHVwbG9hZGVkIGRhdGEuXHJcbiAqIEByZXR1cm5zIEFuIFVwbG9hZFRhc2tcclxuICovXHJcbmZ1bmN0aW9uIHVwbG9hZEJ5dGVzUmVzdW1hYmxlJDEocmVmLCBkYXRhLCBtZXRhZGF0YSkge1xyXG4gICAgcmVmLl90aHJvd0lmUm9vdCgndXBsb2FkQnl0ZXNSZXN1bWFibGUnKTtcclxuICAgIHJldHVybiBuZXcgVXBsb2FkVGFzayhyZWYsIG5ldyBGYnNCbG9iKGRhdGEpLCBtZXRhZGF0YSk7XHJcbn1cclxuLyoqXHJcbiAqIFVwbG9hZHMgYSBzdHJpbmcgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cclxuICogVGhlIHVwbG9hZCBpcyBub3QgcmVzdW1hYmxlLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIHN0cmluZyBzaG91bGQgYmUgdXBsb2FkZWQuXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gdXBsb2FkLlxyXG4gKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgc3RyaW5nIHRvIHVwbG9hZC5cclxuICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgZm9yIHRoZSBuZXdseSB1cGxvYWRlZCBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIGFuIFVwbG9hZFJlc3VsdFxyXG4gKi9cclxuZnVuY3Rpb24gdXBsb2FkU3RyaW5nJDEocmVmLCB2YWx1ZSwgZm9ybWF0ID0gU3RyaW5nRm9ybWF0LlJBVywgbWV0YWRhdGEpIHtcclxuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ3VwbG9hZFN0cmluZycpO1xyXG4gICAgY29uc3QgZGF0YSA9IGRhdGFGcm9tU3RyaW5nKGZvcm1hdCwgdmFsdWUpO1xyXG4gICAgY29uc3QgbWV0YWRhdGFDbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIG1ldGFkYXRhKTtcclxuICAgIGlmIChtZXRhZGF0YUNsb25lWydjb250ZW50VHlwZSddID09IG51bGwgJiYgZGF0YS5jb250ZW50VHlwZSAhPSBudWxsKSB7XHJcbiAgICAgICAgbWV0YWRhdGFDbG9uZVsnY29udGVudFR5cGUnXSA9IGRhdGEuY29udGVudFR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXBsb2FkQnl0ZXMkMShyZWYsIGRhdGEuZGF0YSwgbWV0YWRhdGFDbG9uZSk7XHJcbn1cclxuLyoqXHJcbiAqIExpc3QgYWxsIGl0ZW1zIChmaWxlcykgYW5kIHByZWZpeGVzIChmb2xkZXJzKSB1bmRlciB0aGlzIHN0b3JhZ2UgcmVmZXJlbmNlLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCBmb3IgY2FsbGluZyBsaXN0KCkgcmVwZWF0ZWRseSB1bnRpbCB0aGVyZSBhcmVcclxuICogbm8gbW9yZSByZXN1bHRzLiBUaGUgZGVmYXVsdCBwYWdpbmF0aW9uIHNpemUgaXMgMTAwMC5cclxuICpcclxuICogTm90ZTogVGhlIHJlc3VsdHMgbWF5IG5vdCBiZSBjb25zaXN0ZW50IGlmIG9iamVjdHMgYXJlIGNoYW5nZWQgd2hpbGUgdGhpc1xyXG4gKiBvcGVyYXRpb24gaXMgcnVubmluZy5cclxuICpcclxuICogV2FybmluZzogbGlzdEFsbCBtYXkgcG90ZW50aWFsbHkgY29uc3VtZSB0b28gbWFueSByZXNvdXJjZXMgaWYgdGhlcmUgYXJlXHJcbiAqIHRvbyBtYW55IHJlc3VsdHMuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gZ2V0IGxpc3QgZnJvbS5cclxuICpcclxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbGwgdGhlIGl0ZW1zIGFuZCBwcmVmaXhlcyB1bmRlclxyXG4gKiAgICAgIHRoZSBjdXJyZW50IHN0b3JhZ2UgcmVmZXJlbmNlLiBgcHJlZml4ZXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG9cclxuICogICAgICBzdWItZGlyZWN0b3JpZXMgYW5kIGBpdGVtc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoaXNcclxuICogICAgICBmb2xkZXIuIGBuZXh0UGFnZVRva2VuYCBpcyBuZXZlciByZXR1cm5lZC5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RBbGwkMShyZWYpIHtcclxuICAgIGNvbnN0IGFjY3VtdWxhdG9yID0ge1xyXG4gICAgICAgIHByZWZpeGVzOiBbXSxcclxuICAgICAgICBpdGVtczogW11cclxuICAgIH07XHJcbiAgICByZXR1cm4gbGlzdEFsbEhlbHBlcihyZWYsIGFjY3VtdWxhdG9yKS50aGVuKCgpID0+IGFjY3VtdWxhdG9yKTtcclxufVxyXG4vKipcclxuICogU2VwYXJhdGVkIGZyb20gbGlzdEFsbCBiZWNhdXNlIGFzeW5jIGZ1bmN0aW9ucyBjYW4ndCB1c2UgXCJhcmd1bWVudHNcIi5cclxuICogQHBhcmFtIHJlZlxyXG4gKiBAcGFyYW0gYWNjdW11bGF0b3JcclxuICogQHBhcmFtIHBhZ2VUb2tlblxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbGlzdEFsbEhlbHBlcihyZWYsIGFjY3VtdWxhdG9yLCBwYWdlVG9rZW4pIHtcclxuICAgIGNvbnN0IG9wdCA9IHtcclxuICAgICAgICAvLyBtYXhSZXN1bHRzIGlzIDEwMDAgYnkgZGVmYXVsdC5cclxuICAgICAgICBwYWdlVG9rZW5cclxuICAgIH07XHJcbiAgICBjb25zdCBuZXh0UGFnZSA9IGF3YWl0IGxpc3QkMShyZWYsIG9wdCk7XHJcbiAgICBhY2N1bXVsYXRvci5wcmVmaXhlcy5wdXNoKC4uLm5leHRQYWdlLnByZWZpeGVzKTtcclxuICAgIGFjY3VtdWxhdG9yLml0ZW1zLnB1c2goLi4ubmV4dFBhZ2UuaXRlbXMpO1xyXG4gICAgaWYgKG5leHRQYWdlLm5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xyXG4gICAgICAgIGF3YWl0IGxpc3RBbGxIZWxwZXIocmVmLCBhY2N1bXVsYXRvciwgbmV4dFBhZ2UubmV4dFBhZ2VUb2tlbik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIExpc3QgaXRlbXMgKGZpbGVzKSBhbmQgcHJlZml4ZXMgKGZvbGRlcnMpIHVuZGVyIHRoaXMgc3RvcmFnZSByZWZlcmVuY2UuXHJcbiAqXHJcbiAqIExpc3QgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBGaXJlYmFzZSBSdWxlcyBWZXJzaW9uIDIuXHJcbiAqXHJcbiAqIEdDUyBpcyBhIGtleS1ibG9iIHN0b3JlLiBGaXJlYmFzZSBTdG9yYWdlIGltcG9zZXMgdGhlIHNlbWFudGljIG9mICcvJ1xyXG4gKiBkZWxpbWl0ZWQgZm9sZGVyIHN0cnVjdHVyZS5cclxuICogUmVmZXIgdG8gR0NTJ3MgTGlzdCBBUEkgaWYgeW91IHdhbnQgdG8gbGVhcm4gbW9yZS5cclxuICpcclxuICogVG8gYWRoZXJlIHRvIEZpcmViYXNlIFJ1bGVzJ3MgU2VtYW50aWNzLCBGaXJlYmFzZSBTdG9yYWdlIGRvZXMgbm90XHJcbiAqIHN1cHBvcnQgb2JqZWN0cyB3aG9zZSBwYXRocyBlbmQgd2l0aCBcIi9cIiBvciBjb250YWluIHR3byBjb25zZWN1dGl2ZVxyXG4gKiBcIi9cInMuIEZpcmViYXNlIFN0b3JhZ2UgTGlzdCBBUEkgd2lsbCBmaWx0ZXIgdGhlc2UgdW5zdXBwb3J0ZWQgb2JqZWN0cy5cclxuICogbGlzdCgpIG1heSBmYWlsIGlmIHRoZXJlIGFyZSB0b28gbWFueSB1bnN1cHBvcnRlZCBvYmplY3RzIGluIHRoZSBidWNrZXQuXHJcbiAqIEBwdWJsaWNcclxuICpcclxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gZ2V0IGxpc3QgZnJvbS5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBTZWUgTGlzdE9wdGlvbnMgZm9yIGRldGFpbHMuXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGl0ZW1zIGFuZCBwcmVmaXhlcy5cclxuICogICAgICBgcHJlZml4ZXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gc3ViLWZvbGRlcnMgYW5kIGBpdGVtc2BcclxuICogICAgICBjb250YWlucyByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhpcyBmb2xkZXIuIGBuZXh0UGFnZVRva2VuYFxyXG4gKiAgICAgIGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgcmVzdCBvZiB0aGUgcmVzdWx0cy5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3QkMShyZWYsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4UmVzdWx0cyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVOdW1iZXIoJ29wdGlvbnMubWF4UmVzdWx0cycsIFxyXG4gICAgICAgICAgICAvKiBtaW5WYWx1ZT0gKi8gMSwgXHJcbiAgICAgICAgICAgIC8qIG1heFZhbHVlPSAqLyAxMDAwLCBvcHRpb25zLm1heFJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG9wID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbGlzdCQyKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBcclxuICAgIC8qZGVsaW1pdGVyPSAqLyAnLycsIG9wLnBhZ2VUb2tlbiwgb3AubWF4UmVzdWx0cyk7XHJcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2UubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LiBJZiB0aGlzXHJcbiAqIG9iamVjdCBkb2Vzbid0IGV4aXN0IG9yIG1ldGFkYXRhIGNhbm5vdCBiZSByZXRyZWl2ZWQsIHRoZSBwcm9taXNlIGlzXHJcbiAqIHJlamVjdGVkLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHRvIGdldCBtZXRhZGF0YSBmcm9tLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWV0YWRhdGEkMShyZWYpIHtcclxuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldE1ldGFkYXRhJyk7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldE1ldGFkYXRhJDIocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIGdldE1hcHBpbmdzKCkpO1xyXG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gdXBkYXRlIG1ldGFkYXRhIGZvci5cclxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIG5ldyBtZXRhZGF0YSBmb3IgdGhlIG9iamVjdC5cclxuICogICAgIE9ubHkgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgc2V0IHdpbGwgYmUgY2hhbmdlZC4gRXhwbGljaXRseVxyXG4gKiAgICAgc2V0dGluZyBhIHZhbHVlIHRvIG51bGwgd2lsbCByZW1vdmUgdGhlIG1ldGFkYXRhLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzXHJcbiAqICAgICB3aXRoIHRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxyXG4gKiAgICAgU2VlIGBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlLnByb3RvdHlwZS5nZXRNZXRhZGF0YWBcclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZU1ldGFkYXRhJDEocmVmLCBtZXRhZGF0YSkge1xyXG4gICAgcmVmLl90aHJvd0lmUm9vdCgndXBkYXRlTWV0YWRhdGEnKTtcclxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gdXBkYXRlTWV0YWRhdGEkMihyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgbWV0YWRhdGEsIGdldE1hcHBpbmdzKCkpO1xyXG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkb3dubG9hZCBVUkwgZm9yIHRoZSBnaXZlbiBSZWZlcmVuY2UuXHJcbiAqIEBwdWJsaWNcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBkb3dubG9hZFxyXG4gKiAgICAgVVJMIGZvciB0aGlzIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdldERvd25sb2FkVVJMJDEocmVmKSB7XHJcbiAgICByZWYuX3Rocm93SWZSb290KCdnZXREb3dubG9hZFVSTCcpO1xyXG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXREb3dubG9hZFVybChyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgZ2V0TWFwcGluZ3MoKSk7XHJcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2VcclxuICAgICAgICAubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbilcclxuICAgICAgICAudGhlbih1cmwgPT4ge1xyXG4gICAgICAgIGlmICh1cmwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbm9Eb3dubG9hZFVSTCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERlbGV0ZXMgdGhlIG9iamVjdCBhdCB0aGlzIGxvY2F0aW9uLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIGZvciBvYmplY3QgdG8gZGVsZXRlLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGlmIHRoZSBkZWxldGlvbiBzdWNjZWVkcy5cclxuICovXHJcbmZ1bmN0aW9uIGRlbGV0ZU9iamVjdCQxKHJlZikge1xyXG4gICAgcmVmLl90aHJvd0lmUm9vdCgnZGVsZXRlT2JqZWN0Jyk7XHJcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGRlbGV0ZU9iamVjdCQyKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uKTtcclxuICAgIHJldHVybiByZWYuc3RvcmFnZS5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyByZWZlcmVuY2UgZm9yIG9iamVjdCBvYnRhaW5lZCBieSBhcHBlbmRpbmcgYGNoaWxkUGF0aGAgdG8gYHJlZmAuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHRvIGdldCBjaGlsZCBvZi5cclxuICogQHBhcmFtIGNoaWxkUGF0aCAtIENoaWxkIHBhdGggZnJvbSBwcm92aWRlZCByZWYuXHJcbiAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3Qgb2J0YWluZWQgYnlcclxuICogYXBwZW5kaW5nIGNoaWxkUGF0aCwgcmVtb3ZpbmcgYW55IGR1cGxpY2F0ZSwgYmVnaW5uaW5nLCBvciB0cmFpbGluZ1xyXG4gKiBzbGFzaGVzLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gX2dldENoaWxkJDEocmVmLCBjaGlsZFBhdGgpIHtcclxuICAgIGNvbnN0IG5ld1BhdGggPSBjaGlsZChyZWYuX2xvY2F0aW9uLnBhdGgsIGNoaWxkUGF0aCk7XHJcbiAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbihyZWYuX2xvY2F0aW9uLmJ1Y2tldCwgbmV3UGF0aCk7XHJcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZShyZWYuc3RvcmFnZSwgbG9jYXRpb24pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzVXJsKHBhdGgpIHtcclxuICAgIHJldHVybiAvXltBLVphLXpdKzpcXC9cXC8vLnRlc3QocGF0aCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIGZvciB0aGUgZ2l2ZW4gdXJsLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVmRnJvbVVSTChzZXJ2aWNlLCB1cmwpIHtcclxuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHNlcnZpY2UsIHVybCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIGZvciB0aGUgZ2l2ZW4gcGF0aCBpbiB0aGUgZGVmYXVsdFxyXG4gKiBidWNrZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWZGcm9tUGF0aChyZWYsIHBhdGgpIHtcclxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBGaXJlYmFzZVN0b3JhZ2VJbXBsKSB7XHJcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IHJlZjtcclxuICAgICAgICBpZiAoc2VydmljZS5fYnVja2V0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbm9EZWZhdWx0QnVja2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IG5ldyBSZWZlcmVuY2Uoc2VydmljZSwgc2VydmljZS5fYnVja2V0KTtcclxuICAgICAgICBpZiAocGF0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWZGcm9tUGF0aChyZWZlcmVuY2UsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZWYgaXMgYSBSZWZlcmVuY2VcclxuICAgICAgICBpZiAocGF0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0Q2hpbGQkMShyZWYsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVmJDEoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpIHtcclxuICAgIGlmIChwYXRoT3JVcmwgJiYgaXNVcmwocGF0aE9yVXJsKSkge1xyXG4gICAgICAgIGlmIChzZXJ2aWNlT3JSZWYgaW5zdGFuY2VvZiBGaXJlYmFzZVN0b3JhZ2VJbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWZGcm9tVVJMKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGludmFsaWRBcmd1bWVudCgnVG8gdXNlIHJlZihzZXJ2aWNlLCB1cmwpLCB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFN0b3JhZ2UgaW5zdGFuY2UuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZkZyb21QYXRoKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBleHRyYWN0QnVja2V0KGhvc3QsIGNvbmZpZykge1xyXG4gICAgY29uc3QgYnVja2V0U3RyaW5nID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnW0NPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVldO1xyXG4gICAgaWYgKGJ1Y2tldFN0cmluZyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTG9jYXRpb24ubWFrZUZyb21CdWNrZXRTcGVjKGJ1Y2tldFN0cmluZywgaG9zdCk7XHJcbn1cclxuZnVuY3Rpb24gY29ubmVjdFN0b3JhZ2VFbXVsYXRvciQxKHN0b3JhZ2UsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3RvcmFnZS5ob3N0ID0gYCR7aG9zdH06JHtwb3J0fWA7XHJcbiAgICBzdG9yYWdlLl9wcm90b2NvbCA9ICdodHRwJztcclxuICAgIGNvbnN0IHsgbW9ja1VzZXJUb2tlbiB9ID0gb3B0aW9ucztcclxuICAgIGlmIChtb2NrVXNlclRva2VuKSB7XHJcbiAgICAgICAgc3RvcmFnZS5fb3ZlcnJpZGVBdXRoVG9rZW4gPVxyXG4gICAgICAgICAgICB0eXBlb2YgbW9ja1VzZXJUb2tlbiA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgID8gbW9ja1VzZXJUb2tlblxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVNb2NrVXNlclRva2VuKG1vY2tVc2VyVG9rZW4sIHN0b3JhZ2UuYXBwLm9wdGlvbnMucHJvamVjdElkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgRmlyZWJhc2UgU3RvcmFnZSBSZWZlcmVuY2UgaW5zdGFuY2VzLlxyXG4gKiBAcGFyYW0gb3B0X3VybCAtIGdzOi8vIHVybCB0byBhIGN1c3RvbSBTdG9yYWdlIEJ1Y2tldFxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEZpcmViYXNlU3RvcmFnZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIEZpcmViYXNlQXBwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFN0b3JhZ2VTZXJ2aWNlIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBhcHAsIF9hdXRoUHJvdmlkZXIsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2FwcENoZWNrUHJvdmlkZXIsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3VybCwgX2ZpcmViYXNlVmVyc2lvbikge1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMuX2F1dGhQcm92aWRlciA9IF9hdXRoUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5fYXBwQ2hlY2tQcm92aWRlciA9IF9hcHBDaGVja1Byb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX3VybCA9IF91cmw7XHJcbiAgICAgICAgdGhpcy5fZmlyZWJhc2VWZXJzaW9uID0gX2ZpcmViYXNlVmVyc2lvbjtcclxuICAgICAgICB0aGlzLl9idWNrZXQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgc3RyaW5nIGNhbiBiZSBpbiB0aGUgZm9ybWF0czpcclxuICAgICAgICAgKiAtIGhvc3RcclxuICAgICAgICAgKiAtIGhvc3Q6cG9ydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2hvc3QgPSBERUZBVUxUX0hPU1Q7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSAnaHR0cHMnO1xyXG4gICAgICAgIHRoaXMuX2FwcElkID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9kZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbWF4T3BlcmF0aW9uUmV0cnlUaW1lID0gREVGQVVMVF9NQVhfT1BFUkFUSU9OX1JFVFJZX1RJTUU7XHJcbiAgICAgICAgdGhpcy5fbWF4VXBsb2FkUmV0cnlUaW1lID0gREVGQVVMVF9NQVhfVVBMT0FEX1JFVFJZX1RJTUU7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgaWYgKF91cmwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9idWNrZXQgPSBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWMoX3VybCwgdGhpcy5faG9zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9idWNrZXQgPSBleHRyYWN0QnVja2V0KHRoaXMuX2hvc3QsIHRoaXMuYXBwLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhvc3Qgc3RyaW5nIGZvciB0aGlzIHNlcnZpY2UsIGluIHRoZSBmb3JtIG9mIGBob3N0YCBvclxyXG4gICAgICogYGhvc3Q6cG9ydGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBob3N0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ob3N0O1xyXG4gICAgfVxyXG4gICAgc2V0IGhvc3QoaG9zdCkge1xyXG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0O1xyXG4gICAgICAgIGlmICh0aGlzLl91cmwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9idWNrZXQgPSBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWModGhpcy5fdXJsLCBob3N0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IGV4dHJhY3RCdWNrZXQoaG9zdCwgdGhpcy5hcHAub3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSB0aW1lIHRvIHJldHJ5IHVwbG9hZHMgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4VXBsb2FkUmV0cnlUaW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhVcGxvYWRSZXRyeVRpbWU7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4VXBsb2FkUmV0cnlUaW1lKHRpbWUpIHtcclxuICAgICAgICB2YWxpZGF0ZU51bWJlcigndGltZScsIFxyXG4gICAgICAgIC8qIG1pblZhbHVlPSovIDAsIFxyXG4gICAgICAgIC8qIG1heFZhbHVlPSAqLyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHRpbWUpO1xyXG4gICAgICAgIHRoaXMuX21heFVwbG9hZFJldHJ5VGltZSA9IHRpbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIHRpbWUgdG8gcmV0cnkgb3BlcmF0aW9ucyBvdGhlciB0aGFuIHVwbG9hZHMgb3IgZG93bmxvYWRzIGluXHJcbiAgICAgKiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhPcGVyYXRpb25SZXRyeVRpbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heE9wZXJhdGlvblJldHJ5VGltZTtcclxuICAgIH1cclxuICAgIHNldCBtYXhPcGVyYXRpb25SZXRyeVRpbWUodGltZSkge1xyXG4gICAgICAgIHZhbGlkYXRlTnVtYmVyKCd0aW1lJywgXHJcbiAgICAgICAgLyogbWluVmFsdWU9Ki8gMCwgXHJcbiAgICAgICAgLyogbWF4VmFsdWU9ICovIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdGltZSk7XHJcbiAgICAgICAgdGhpcy5fbWF4T3BlcmF0aW9uUmV0cnlUaW1lID0gdGltZTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9nZXRBdXRoVG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX292ZXJyaWRlQXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdmVycmlkZUF1dGhUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXV0aCA9IHRoaXMuX2F1dGhQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoYXV0aCkge1xyXG4gICAgICAgICAgICBjb25zdCB0b2tlbkRhdGEgPSBhd2FpdCBhdXRoLmdldFRva2VuKCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbkRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkRhdGEuYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZ2V0QXBwQ2hlY2tUb2tlbigpIHtcclxuICAgICAgICBjb25zdCBhcHBDaGVjayA9IHRoaXMuX2FwcENoZWNrUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICAgICAgaWYgKGFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwcENoZWNrLmdldFRva2VuKCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IFdoYXQgZG8gd2Ugd2FudCB0byBkbyBpZiB0aGVyZSBpcyBhbiBlcnJvciBnZXR0aW5nIHRoZSB0b2tlbj9cclxuICAgICAgICAgICAgLy8gQ29udGV4dDogYXBwQ2hlY2suZ2V0VG9rZW4oKSB3aWxsIG5ldmVyIHRocm93IGV2ZW4gaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEluIHRoZSBlcnJvciBjYXNlLCBhIGR1bW15IHRva2VuIHdpbGwgYmVcclxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgYWxvbmcgd2l0aCBhbiBlcnJvciBmaWVsZCBkZXNjcmliaW5nIHRoZSBlcnJvci4gSW4gZ2VuZXJhbCwgd2Ugc2hvdWxkbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yIGNvbmRpdGlvbiBhbmQganVzdCB1c2VcclxuICAgICAgICAgICAgLy8gdGhlIHRva2VuIChhY3R1YWwgb3IgZHVtbXkpIHRvIHNlbmQgcmVxdWVzdHMuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHJ1bm5pbmcgcmVxdWVzdHMgYW5kIHByZXZlbnQgbW9yZSBmcm9tIGJlaW5nIGNyZWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIF9kZWxldGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5mb3JFYWNoKHJlcXVlc3QgPT4gcmVxdWVzdC5jYW5jZWwoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIG9iamVjdCByZWZlcmVuY2luZyB0aGlzIFN0b3JhZ2VTZXJ2aWNlXHJcbiAgICAgKiBhdCB0aGUgZ2l2ZW4gTG9jYXRpb24uXHJcbiAgICAgKi9cclxuICAgIF9tYWtlU3RvcmFnZVJlZmVyZW5jZShsb2MpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZSh0aGlzLCBsb2MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdEluZm8gLSBIVFRQIFJlcXVlc3RJbmZvIG9iamVjdFxyXG4gICAgICogQHBhcmFtIGF1dGhUb2tlbiAtIEZpcmViYXNlIGF1dGggdG9rZW5cclxuICAgICAqL1xyXG4gICAgX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCByZXF1ZXN0RmFjdG9yeSwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCByZXRyeSA9IHRydWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCB0aGlzLl9hcHBJZCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCByZXF1ZXN0RmFjdG9yeSwgdGhpcy5fZmlyZWJhc2VWZXJzaW9uLCByZXRyeSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmFkZChyZXF1ZXN0KTtcclxuICAgICAgICAgICAgLy8gUmVxdWVzdCByZW1vdmVzIGl0c2VsZiBmcm9tIHNldCB3aGVuIGNvbXBsZXRlLlxyXG4gICAgICAgICAgICByZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKCgpID0+IHRoaXMuX3JlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0KSwgKCkgPT4gdGhpcy5fcmVxdWVzdHMuZGVsZXRlKHJlcXVlc3QpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhaWxSZXF1ZXN0KGFwcERlbGV0ZWQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgbWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCByZXF1ZXN0RmFjdG9yeSkge1xyXG4gICAgICAgIGNvbnN0IFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRBdXRoVG9rZW4oKSxcclxuICAgICAgICAgICAgdGhpcy5fZ2V0QXBwQ2hlY2tUb2tlbigpXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCByZXF1ZXN0RmFjdG9yeSwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKS5nZXRQcm9taXNlKCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL3N0b3JhZ2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjAuMTIuNlwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVHlwZSBjb25zdGFudCBmb3IgRmlyZWJhc2UgU3RvcmFnZS5cclxuICovXHJcbmNvbnN0IFNUT1JBR0VfVFlQRSA9ICdzdG9yYWdlJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERvd25sb2FkcyB0aGUgZGF0YSBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG9iamVjdFxyXG4gKiBpcyBub3QgZm91bmQuXHJcbiAqXHJcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uYWxpdHksIHlvdSBoYXZlIHRvIHdoaXRlbGlzdCB5b3VyIGFwcCdzIG9yaWdpbiBpbiB5b3VyXHJcbiAqIENsb3VkIFN0b3JhZ2UgYnVja2V0LiBTZWUgYWxzb1xyXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vc3RvcmFnZS9kb2NzL2NvbmZpZ3VyaW5nLWNvcnNcclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSBkb3dubG9hZGVkLlxyXG4gKiBAcGFyYW0gbWF4RG93bmxvYWRTaXplQnl0ZXMgLSBJZiBzZXQsIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBpbiBieXRlcyB0b1xyXG4gKiByZXRyaWV2ZS5cclxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIG9iamVjdCdzIGJ5dGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCeXRlcyhyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHJldHVybiBnZXRCeXRlc0ludGVybmFsKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpO1xyXG59XHJcbi8qKlxyXG4gKiBVcGxvYWRzIGRhdGEgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cclxuICogVGhlIHVwbG9hZCBpcyBub3QgcmVzdW1hYmxlLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gd2hlcmUgZGF0YSBzaG91bGQgYmUgdXBsb2FkZWQuXHJcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXBsb2FkLlxyXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIGRhdGEgdG8gdXBsb2FkLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyBhbiBVcGxvYWRSZXN1bHRcclxuICovXHJcbmZ1bmN0aW9uIHVwbG9hZEJ5dGVzKHJlZiwgZGF0YSwgbWV0YWRhdGEpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIHVwbG9hZEJ5dGVzJDEocmVmLCBkYXRhLCBtZXRhZGF0YSk7XHJcbn1cclxuLyoqXHJcbiAqIFVwbG9hZHMgYSBzdHJpbmcgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cclxuICogVGhlIHVwbG9hZCBpcyBub3QgcmVzdW1hYmxlLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gd2hlcmUgc3RyaW5nIHNob3VsZCBiZSB1cGxvYWRlZC5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byB1cGxvYWQuXHJcbiAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBzdHJpbmcgdG8gdXBsb2FkLlxyXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIHN0cmluZyB0byB1cGxvYWQuXHJcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIGFuIFVwbG9hZFJlc3VsdFxyXG4gKi9cclxuZnVuY3Rpb24gdXBsb2FkU3RyaW5nKHJlZiwgdmFsdWUsIGZvcm1hdCwgbWV0YWRhdGEpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIHVwbG9hZFN0cmluZyQxKHJlZiwgdmFsdWUsIGZvcm1hdCwgbWV0YWRhdGEpO1xyXG59XHJcbi8qKlxyXG4gKiBVcGxvYWRzIGRhdGEgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cclxuICogVGhlIHVwbG9hZCBjYW4gYmUgcGF1c2VkIGFuZCByZXN1bWVkLCBhbmQgZXhwb3NlcyBwcm9ncmVzcyB1cGRhdGVzLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gd2hlcmUgZGF0YSBzaG91bGQgYmUgdXBsb2FkZWQuXHJcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXBsb2FkLlxyXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIGRhdGEgdG8gdXBsb2FkLlxyXG4gKiBAcmV0dXJucyBBbiBVcGxvYWRUYXNrXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGxvYWRCeXRlc1Jlc3VtYWJsZShyZWYsIGRhdGEsIG1ldGFkYXRhKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHJldHVybiB1cGxvYWRCeXRlc1Jlc3VtYWJsZSQxKHJlZiwgZGF0YSwgbWV0YWRhdGEpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC4gSWYgdGhpc1xyXG4gKiBvYmplY3QgZG9lc24ndCBleGlzdCBvciBtZXRhZGF0YSBjYW5ub3QgYmUgcmV0cmVpdmVkLCB0aGUgcHJvbWlzZSBpc1xyXG4gKiByZWplY3RlZC5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIGdldCBtZXRhZGF0YSBmcm9tLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWV0YWRhdGEocmVmKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHJldHVybiBnZXRNZXRhZGF0YSQxKHJlZik7XHJcbn1cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIHVwZGF0ZSBtZXRhZGF0YSBmb3IuXHJcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoZSBvYmplY3QuXHJcbiAqICAgICBPbmx5IHZhbHVlcyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IHNldCB3aWxsIGJlIGNoYW5nZWQuIEV4cGxpY2l0bHlcclxuICogICAgIHNldHRpbmcgYSB2YWx1ZSB0byBudWxsIHdpbGwgcmVtb3ZlIHRoZSBtZXRhZGF0YS5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlTWV0YWRhdGEocmVmLCBtZXRhZGF0YSkge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gdXBkYXRlTWV0YWRhdGEkMShyZWYsIG1ldGFkYXRhKTtcclxufVxyXG4vKipcclxuICogTGlzdCBpdGVtcyAoZmlsZXMpIGFuZCBwcmVmaXhlcyAoZm9sZGVycykgdW5kZXIgdGhpcyBzdG9yYWdlIHJlZmVyZW5jZS5cclxuICpcclxuICogTGlzdCBBUEkgaXMgb25seSBhdmFpbGFibGUgZm9yIEZpcmViYXNlIFJ1bGVzIFZlcnNpb24gMi5cclxuICpcclxuICogR0NTIGlzIGEga2V5LWJsb2Igc3RvcmUuIEZpcmViYXNlIFN0b3JhZ2UgaW1wb3NlcyB0aGUgc2VtYW50aWMgb2YgJy8nXHJcbiAqIGRlbGltaXRlZCBmb2xkZXIgc3RydWN0dXJlLlxyXG4gKiBSZWZlciB0byBHQ1MncyBMaXN0IEFQSSBpZiB5b3Ugd2FudCB0byBsZWFybiBtb3JlLlxyXG4gKlxyXG4gKiBUbyBhZGhlcmUgdG8gRmlyZWJhc2UgUnVsZXMncyBTZW1hbnRpY3MsIEZpcmViYXNlIFN0b3JhZ2UgZG9lcyBub3RcclxuICogc3VwcG9ydCBvYmplY3RzIHdob3NlIHBhdGhzIGVuZCB3aXRoIFwiL1wiIG9yIGNvbnRhaW4gdHdvIGNvbnNlY3V0aXZlXHJcbiAqIFwiL1wicy4gRmlyZWJhc2UgU3RvcmFnZSBMaXN0IEFQSSB3aWxsIGZpbHRlciB0aGVzZSB1bnN1cHBvcnRlZCBvYmplY3RzLlxyXG4gKiBsaXN0KCkgbWF5IGZhaWwgaWYgdGhlcmUgYXJlIHRvbyBtYW55IHVuc3VwcG9ydGVkIG9iamVjdHMgaW4gdGhlIGJ1Y2tldC5cclxuICogQHB1YmxpY1xyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIGdldCBsaXN0IGZyb20uXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gU2VlIHtAbGluayBMaXN0T3B0aW9uc30gZm9yIGRldGFpbHMuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgaXRlbXMgYW5kIHByZWZpeGVzLlxyXG4gKiAgICAgIGBwcmVmaXhlc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0byBzdWItZm9sZGVycyBhbmQgYGl0ZW1zYFxyXG4gKiAgICAgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGlzIGZvbGRlci4gYG5leHRQYWdlVG9rZW5gXHJcbiAqICAgICAgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSByZXN0IG9mIHRoZSByZXN1bHRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbGlzdChyZWYsIG9wdGlvbnMpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIGxpc3QkMShyZWYsIG9wdGlvbnMpO1xyXG59XHJcbi8qKlxyXG4gKiBMaXN0IGFsbCBpdGVtcyAoZmlsZXMpIGFuZCBwcmVmaXhlcyAoZm9sZGVycykgdW5kZXIgdGhpcyBzdG9yYWdlIHJlZmVyZW5jZS5cclxuICpcclxuICogVGhpcyBpcyBhIGhlbHBlciBtZXRob2QgZm9yIGNhbGxpbmcgbGlzdCgpIHJlcGVhdGVkbHkgdW50aWwgdGhlcmUgYXJlXHJcbiAqIG5vIG1vcmUgcmVzdWx0cy4gVGhlIGRlZmF1bHQgcGFnaW5hdGlvbiBzaXplIGlzIDEwMDAuXHJcbiAqXHJcbiAqIE5vdGU6IFRoZSByZXN1bHRzIG1heSBub3QgYmUgY29uc2lzdGVudCBpZiBvYmplY3RzIGFyZSBjaGFuZ2VkIHdoaWxlIHRoaXNcclxuICogb3BlcmF0aW9uIGlzIHJ1bm5pbmcuXHJcbiAqXHJcbiAqIFdhcm5pbmc6IGBsaXN0QWxsYCBtYXkgcG90ZW50aWFsbHkgY29uc3VtZSB0b28gbWFueSByZXNvdXJjZXMgaWYgdGhlcmUgYXJlXHJcbiAqIHRvbyBtYW55IHJlc3VsdHMuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB0byBnZXQgbGlzdCBmcm9tLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggYWxsIHRoZSBpdGVtcyBhbmQgcHJlZml4ZXMgdW5kZXJcclxuICogICAgICB0aGUgY3VycmVudCBzdG9yYWdlIHJlZmVyZW5jZS4gYHByZWZpeGVzYCBjb250YWlucyByZWZlcmVuY2VzIHRvXHJcbiAqICAgICAgc3ViLWRpcmVjdG9yaWVzIGFuZCBgaXRlbXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGlzXHJcbiAqICAgICAgZm9sZGVyLiBgbmV4dFBhZ2VUb2tlbmAgaXMgbmV2ZXIgcmV0dXJuZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0QWxsKHJlZikge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gbGlzdEFsbCQxKHJlZik7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRvd25sb2FkIFVSTCBmb3IgdGhlIGdpdmVuIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfS5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIGdldCB0aGUgZG93bmxvYWQgVVJMIGZvci5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBkb3dubG9hZFxyXG4gKiAgICAgVVJMIGZvciB0aGlzIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdldERvd25sb2FkVVJMKHJlZikge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gZ2V0RG93bmxvYWRVUkwkMShyZWYpO1xyXG59XHJcbi8qKlxyXG4gKiBEZWxldGVzIHRoZSBvYmplY3QgYXQgdGhpcyBsb2NhdGlvbi5cclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IGZvciBvYmplY3QgdG8gZGVsZXRlLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGlmIHRoZSBkZWxldGlvbiBzdWNjZWVkcy5cclxuICovXHJcbmZ1bmN0aW9uIGRlbGV0ZU9iamVjdChyZWYpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIGRlbGV0ZU9iamVjdCQxKHJlZik7XHJcbn1cclxuZnVuY3Rpb24gcmVmKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKSB7XHJcbiAgICBzZXJ2aWNlT3JSZWYgPSBnZXRNb2R1bGFySW5zdGFuY2Uoc2VydmljZU9yUmVmKTtcclxuICAgIHJldHVybiByZWYkMShzZXJ2aWNlT3JSZWYsIHBhdGhPclVybCk7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2dldENoaWxkKHJlZiwgY2hpbGRQYXRoKSB7XHJcbiAgICByZXR1cm4gX2dldENoaWxkJDEocmVmLCBjaGlsZFBhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIGEge0BsaW5rIEZpcmViYXNlU3RvcmFnZX0gaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBGaXJlYmFzZSBhcHAuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlIGFwcCB0byBnZXQge0BsaW5rIEZpcmViYXNlU3RvcmFnZX0gaW5zdGFuY2UgZm9yLlxyXG4gKiBAcGFyYW0gYnVja2V0VXJsIC0gVGhlIGdzOi8vIHVybCB0byB5b3VyIEZpcmViYXNlIFN0b3JhZ2UgQnVja2V0LlxyXG4gKiBJZiBub3QgcGFzc2VkLCB1c2VzIHRoZSBhcHAncyBkZWZhdWx0IFN0b3JhZ2UgQnVja2V0LlxyXG4gKiBAcmV0dXJucyBBIHtAbGluayBGaXJlYmFzZVN0b3JhZ2V9IGluc3RhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3RvcmFnZShhcHAgPSBnZXRBcHAoKSwgYnVja2V0VXJsKSB7XHJcbiAgICBhcHAgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXBwKTtcclxuICAgIGNvbnN0IHN0b3JhZ2VQcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsIFNUT1JBR0VfVFlQRSk7XHJcbiAgICBjb25zdCBzdG9yYWdlSW5zdGFuY2UgPSBzdG9yYWdlUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcclxuICAgICAgICBpZGVudGlmaWVyOiBidWNrZXRVcmxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZW11bGF0b3IgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQoJ3N0b3JhZ2UnKTtcclxuICAgIGlmIChlbXVsYXRvcikge1xyXG4gICAgICAgIGNvbm5lY3RTdG9yYWdlRW11bGF0b3Ioc3RvcmFnZUluc3RhbmNlLCAuLi5lbXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RvcmFnZUluc3RhbmNlO1xyXG59XHJcbi8qKlxyXG4gKiBNb2RpZnkgdGhpcyB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBDbG91ZCBTdG9yYWdlIGVtdWxhdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3RvcmFnZSAtIFRoZSB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gaG9zdCAtIFRoZSBlbXVsYXRvciBob3N0IChleDogbG9jYWxob3N0KVxyXG4gKiBAcGFyYW0gcG9ydCAtIFRoZSBlbXVsYXRvciBwb3J0IChleDogNTAwMSlcclxuICogQHBhcmFtIG9wdGlvbnMgLSBFbXVsYXRvciBvcHRpb25zLiBgb3B0aW9ucy5tb2NrVXNlclRva2VuYCBpcyB0aGUgbW9jayBhdXRoXHJcbiAqIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nIFNlY3VyaXR5IFJ1bGVzLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0U3RvcmFnZUVtdWxhdG9yKHN0b3JhZ2UsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29ubmVjdFN0b3JhZ2VFbXVsYXRvciQxKHN0b3JhZ2UsIGhvc3QsIHBvcnQsIG9wdGlvbnMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEb3dubG9hZHMgdGhlIGRhdGEgYXQgdGhlIG9iamVjdCdzIGxvY2F0aW9uLiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBvYmplY3RcclxuICogaXMgbm90IGZvdW5kLlxyXG4gKlxyXG4gKiBUbyB1c2UgdGhpcyBmdW5jdGlvbmFsaXR5LCB5b3UgaGF2ZSB0byB3aGl0ZWxpc3QgeW91ciBhcHAncyBvcmlnaW4gaW4geW91clxyXG4gKiBDbG91ZCBTdG9yYWdlIGJ1Y2tldC4gU2VlIGFsc29cclxuICogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3N0b3JhZ2UvZG9jcy9jb25maWd1cmluZy1jb3JzXHJcbiAqXHJcbiAqIFRoaXMgQVBJIGlzIG5vdCBhdmFpbGFibGUgaW4gTm9kZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSBkb3dubG9hZGVkLlxyXG4gKiBAcGFyYW0gbWF4RG93bmxvYWRTaXplQnl0ZXMgLSBJZiBzZXQsIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBpbiBieXRlcyB0b1xyXG4gKiByZXRyaWV2ZS5cclxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIEJsb2IgY29udGFpbmluZyB0aGUgb2JqZWN0J3MgYnl0ZXNcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuZnVuY3Rpb24gZ2V0QmxvYihyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldEJsb2IoKSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBCcm93c2VyLWxpa2UgZW52aXJvbm1lbnRzJyk7XHJcbn1cclxuLyoqXHJcbiAqIERvd25sb2FkcyB0aGUgZGF0YSBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uIFJhaXNlcyBhbiBlcnJvciBldmVudCBpZiB0aGVcclxuICogb2JqZWN0IGlzIG5vdCBmb3VuZC5cclxuICpcclxuICogVGhpcyBBUEkgaXMgb25seSBhdmFpbGFibGUgaW4gTm9kZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB3aGVyZSBkYXRhIHNob3VsZCBiZSBkb3dubG9hZGVkLlxyXG4gKiBAcGFyYW0gbWF4RG93bmxvYWRTaXplQnl0ZXMgLSBJZiBzZXQsIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBpbiBieXRlcyB0b1xyXG4gKiByZXRyaWV2ZS5cclxuICogQHJldHVybnMgQSBzdHJlYW0gd2l0aCB0aGUgb2JqZWN0J3MgZGF0YSBhcyBieXRlc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3RyZWFtKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIGdldFN0cmVhbUludGVybmFsKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpO1xyXG59XG5cbi8qKlxyXG4gKiBDbG91ZCBTdG9yYWdlIGZvciBGaXJlYmFzZVxyXG4gKlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGZhY3RvcnkoY29udGFpbmVyLCB7IGluc3RhbmNlSWRlbnRpZmllcjogdXJsIH0pIHtcclxuICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICBjb25zdCBhdXRoUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnKTtcclxuICAgIGNvbnN0IGFwcENoZWNrUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcC1jaGVjay1pbnRlcm5hbCcpO1xyXG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VJbXBsKGFwcCwgYXV0aFByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyLCB1cmwsIFNES19WRVJTSU9OKTtcclxufVxyXG5mdW5jdGlvbiByZWdpc3RlclN0b3JhZ2UoKSB7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChTVE9SQUdFX1RZUEUsIGZhY3RvcnksIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pLnNldE11bHRpcGxlSW5zdGFuY2VzKHRydWUpKTtcclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uKTtcclxufVxyXG5yZWdpc3RlclN0b3JhZ2UoKTtcblxuZXhwb3J0IHsgU3RvcmFnZUVycm9yLCBTdG9yYWdlRXJyb3JDb2RlLCBTdHJpbmdGb3JtYXQsIEZic0Jsb2IgYXMgX0Zic0Jsb2IsIExvY2F0aW9uIGFzIF9Mb2NhdGlvbiwgVGFza0V2ZW50IGFzIF9UYXNrRXZlbnQsIFRhc2tTdGF0ZSBhcyBfVGFza1N0YXRlLCBVcGxvYWRUYXNrIGFzIF9VcGxvYWRUYXNrLCBkYXRhRnJvbVN0cmluZyBhcyBfZGF0YUZyb21TdHJpbmcsIF9nZXRDaGlsZCwgaW52YWxpZEFyZ3VtZW50IGFzIF9pbnZhbGlkQXJndW1lbnQsIGludmFsaWRSb290T3BlcmF0aW9uIGFzIF9pbnZhbGlkUm9vdE9wZXJhdGlvbiwgY29ubmVjdFN0b3JhZ2VFbXVsYXRvciwgZGVsZXRlT2JqZWN0LCBnZXRCbG9iLCBnZXRCeXRlcywgZ2V0RG93bmxvYWRVUkwsIGdldE1ldGFkYXRhLCBnZXRTdG9yYWdlLCBnZXRTdHJlYW0sIGxpc3QsIGxpc3RBbGwsIHJlZiwgdXBkYXRlTWV0YWRhdGEsIHVwbG9hZEJ5dGVzLCB1cGxvYWRCeXRlc1Jlc3VtYWJsZSwgdXBsb2FkU3RyaW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZ2V0UHJvdmlkZXIiLCJnZXRBcHAiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJyZWdpc3RlclZlcnNpb24iLCJTREtfVkVSU0lPTiIsIkZpcmViYXNlRXJyb3IiLCJjcmVhdGVNb2NrVXNlclRva2VuIiwiZ2V0TW9kdWxhckluc3RhbmNlIiwiZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0IiwiVHJhbnNmb3JtIiwiUGFzc1Rocm91Z2giLCJmZXRjaCIsIkNvbXBvbmVudCIsIkRFRkFVTFRfSE9TVCIsIkNPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVkiLCJERUZBVUxUX01BWF9PUEVSQVRJT05fUkVUUllfVElNRSIsIkRFRkFVTFRfTUFYX1VQTE9BRF9SRVRSWV9USU1FIiwiREVGQVVMVF9NSU5fU0xFRVBfVElNRV9NSUxMSVMiLCJTdG9yYWdlRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJtZXNzYWdlIiwic3RhdHVzXyIsInByZXBlbmRDb2RlIiwiY3VzdG9tRGF0YSIsInNlcnZlclJlc3BvbnNlIiwiX2Jhc2VNZXNzYWdlIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJzdGF0dXMiLCJfY29kZUVxdWFscyIsIlN0b3JhZ2VFcnJvckNvZGUiLCJ1bmtub3duIiwiVU5LTk9XTiIsIm9iamVjdE5vdEZvdW5kIiwicGF0aCIsIk9CSkVDVF9OT1RfRk9VTkQiLCJxdW90YUV4Y2VlZGVkIiwiYnVja2V0IiwiUVVPVEFfRVhDRUVERUQiLCJ1bmF1dGhlbnRpY2F0ZWQiLCJVTkFVVEhFTlRJQ0FURUQiLCJ1bmF1dGhvcml6ZWRBcHAiLCJVTkFVVEhPUklaRURfQVBQIiwidW5hdXRob3JpemVkIiwiVU5BVVRIT1JJWkVEIiwicmV0cnlMaW1pdEV4Y2VlZGVkIiwiUkVUUllfTElNSVRfRVhDRUVERUQiLCJjYW5jZWxlZCIsIkNBTkNFTEVEIiwiaW52YWxpZFVybCIsInVybCIsIklOVkFMSURfVVJMIiwiaW52YWxpZERlZmF1bHRCdWNrZXQiLCJJTlZBTElEX0RFRkFVTFRfQlVDS0VUIiwibm9EZWZhdWx0QnVja2V0IiwiTk9fREVGQVVMVF9CVUNLRVQiLCJjYW5ub3RTbGljZUJsb2IiLCJDQU5OT1RfU0xJQ0VfQkxPQiIsInNlcnZlckZpbGVXcm9uZ1NpemUiLCJTRVJWRVJfRklMRV9XUk9OR19TSVpFIiwibm9Eb3dubG9hZFVSTCIsIk5PX0RPV05MT0FEX1VSTCIsImludmFsaWRBcmd1bWVudCIsIklOVkFMSURfQVJHVU1FTlQiLCJhcHBEZWxldGVkIiwiQVBQX0RFTEVURUQiLCJpbnZhbGlkUm9vdE9wZXJhdGlvbiIsIm5hbWUiLCJJTlZBTElEX1JPT1RfT1BFUkFUSU9OIiwiaW52YWxpZEZvcm1hdCIsImZvcm1hdCIsIklOVkFMSURfRk9STUFUIiwiaW50ZXJuYWxFcnJvciIsIklOVEVSTkFMX0VSUk9SIiwiTG9jYXRpb24iLCJwYXRoXyIsImlzUm9vdCIsImxlbmd0aCIsImZ1bGxTZXJ2ZXJVcmwiLCJlbmNvZGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJidWNrZXRPbmx5U2VydmVyVXJsIiwibWFrZUZyb21CdWNrZXRTcGVjIiwiYnVja2V0U3RyaW5nIiwiaG9zdCIsImJ1Y2tldExvY2F0aW9uIiwibWFrZUZyb21VcmwiLCJlIiwibG9jYXRpb24iLCJidWNrZXREb21haW4iLCJnc01vZGlmeSIsImxvYyIsImNoYXJBdCIsInNsaWNlIiwiZ3NQYXRoIiwiZ3NSZWdleCIsIlJlZ0V4cCIsImdzSW5kaWNlcyIsImh0dHBNb2RpZnkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ2ZXJzaW9uIiwiZmlyZWJhc2VTdG9yYWdlSG9zdCIsInJlcGxhY2UiLCJmaXJlYmFzZVN0b3JhZ2VQYXRoIiwiZmlyZWJhc2VTdG9yYWdlUmVnRXhwIiwiZmlyZWJhc2VTdG9yYWdlSW5kaWNlcyIsImNsb3VkU3RvcmFnZUhvc3QiLCJjbG91ZFN0b3JhZ2VQYXRoIiwiY2xvdWRTdG9yYWdlUmVnRXhwIiwiY2xvdWRTdG9yYWdlSW5kaWNlcyIsImdyb3VwcyIsInJlZ2V4IiwiaW5kaWNlcyIsInBvc3RNb2RpZnkiLCJpIiwiZ3JvdXAiLCJjYXB0dXJlcyIsImV4ZWMiLCJidWNrZXRWYWx1ZSIsInBhdGhWYWx1ZSIsIkZhaWxSZXF1ZXN0IiwiZXJyb3IiLCJwcm9taXNlXyIsIlByb21pc2UiLCJyZWplY3QiLCJnZXRQcm9taXNlIiwiY2FuY2VsIiwiX2FwcERlbGV0ZSIsInN0YXJ0IiwiZG9SZXF1ZXN0IiwiYmFja29mZkNvbXBsZXRlQ2IiLCJ0aW1lb3V0Iiwid2FpdFNlY29uZHMiLCJyZXRyeVRpbWVvdXRJZCIsImdsb2JhbFRpbWVvdXRJZCIsImhpdFRpbWVvdXQiLCJjYW5jZWxTdGF0ZSIsInRyaWdnZXJlZENhbGxiYWNrIiwidHJpZ2dlckNhbGxiYWNrIiwiYXJncyIsImFwcGx5IiwiY2FsbFdpdGhEZWxheSIsIm1pbGxpcyIsInNldFRpbWVvdXQiLCJyZXNwb25zZUhhbmRsZXIiLCJjbGVhckdsb2JhbFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzdWNjZXNzIiwiY2FsbCIsIm11c3RTdG9wIiwid2FpdE1pbGxpcyIsIk1hdGgiLCJyYW5kb20iLCJzdG9wcGVkIiwic3RvcCIsIndhc1RpbWVvdXQiLCJpZCIsImlzSnVzdERlZiIsInAiLCJpc0Z1bmN0aW9uIiwiaXNOb25BcnJheU9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImlzU3RyaW5nIiwiU3RyaW5nIiwiaXNOYXRpdmVCbG9iIiwiaXNOYXRpdmVCbG9iRGVmaW5lZCIsIkJsb2IiLCJ2YWxpZGF0ZU51bWJlciIsImFyZ3VtZW50IiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsInZhbHVlIiwibWFrZVVybCIsInVybFBhcnQiLCJwcm90b2NvbCIsIm9yaWdpbiIsIm1ha2VRdWVyeVN0cmluZyIsInBhcmFtcyIsInF1ZXJ5UGFydCIsImtleSIsImhhc093blByb3BlcnR5IiwibmV4dFBhcnQiLCJFcnJvckNvZGUiLCJpc1JldHJ5U3RhdHVzQ29kZSIsImFkZGl0aW9uYWxSZXRyeUNvZGVzIiwiaXNGaXZlSHVuZHJlZENvZGUiLCJleHRyYVJldHJ5Q29kZXMiLCJpc0V4dHJhUmV0cnlDb2RlIiwiaW5kZXhPZiIsImlzQWRkaXRpb25hbFJldHJ5Q29kZSIsIk5ldHdvcmtSZXF1ZXN0IiwidXJsXyIsIm1ldGhvZF8iLCJoZWFkZXJzXyIsImJvZHlfIiwic3VjY2Vzc0NvZGVzXyIsImFkZGl0aW9uYWxSZXRyeUNvZGVzXyIsImNhbGxiYWNrXyIsImVycm9yQ2FsbGJhY2tfIiwidGltZW91dF8iLCJwcm9ncmVzc0NhbGxiYWNrXyIsImNvbm5lY3Rpb25GYWN0b3J5XyIsInJldHJ5IiwicGVuZGluZ0Nvbm5lY3Rpb25fIiwiYmFja29mZklkXyIsImNhbmNlbGVkXyIsImFwcERlbGV0ZV8iLCJyZXNvbHZlIiwicmVzb2x2ZV8iLCJyZWplY3RfIiwic3RhcnRfIiwiZG9UaGVSZXF1ZXN0IiwiYmFja29mZkNhbGxiYWNrIiwiUmVxdWVzdEVuZFN0YXR1cyIsImNvbm5lY3Rpb24iLCJwcm9ncmVzc0xpc3RlbmVyIiwicHJvZ3Jlc3NFdmVudCIsImxvYWRlZCIsInRvdGFsIiwibGVuZ3RoQ29tcHV0YWJsZSIsImFkZFVwbG9hZFByb2dyZXNzTGlzdGVuZXIiLCJzZW5kIiwidGhlbiIsInJlbW92ZVVwbG9hZFByb2dyZXNzTGlzdGVuZXIiLCJoaXRTZXJ2ZXIiLCJnZXRFcnJvckNvZGUiLCJOT19FUlJPUiIsImdldFN0YXR1cyIsIndhc0NhbmNlbGVkIiwiQUJPUlQiLCJzdWNjZXNzQ29kZSIsImJhY2tvZmZEb25lIiwicmVxdWVzdFdlbnRUaHJvdWdoIiwid2FzU3VjY2Vzc0NvZGUiLCJyZXN1bHQiLCJnZXRSZXNwb25zZSIsImVyciIsImdldEVycm9yVGV4dCIsImFwcERlbGV0ZSIsImFib3J0IiwiYWRkQXV0aEhlYWRlcl8iLCJoZWFkZXJzIiwiYXV0aFRva2VuIiwiYWRkVmVyc2lvbkhlYWRlcl8iLCJmaXJlYmFzZVZlcnNpb24iLCJhZGRHbXBpZEhlYWRlcl8iLCJhcHBJZCIsImFkZEFwcENoZWNrSGVhZGVyXyIsImFwcENoZWNrVG9rZW4iLCJtYWtlUmVxdWVzdCIsInJlcXVlc3RJbmZvIiwicmVxdWVzdEZhY3RvcnkiLCJ1cmxQYXJhbXMiLCJhc3NpZ24iLCJtZXRob2QiLCJib2R5Iiwic3VjY2Vzc0NvZGVzIiwiaGFuZGxlciIsImVycm9ySGFuZGxlciIsInByb2dyZXNzQ2FsbGJhY2siLCJnZXRCbG9iQnVpbGRlciIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJ1bmRlZmluZWQiLCJnZXRCbG9iJDEiLCJiYiIsImFwcGVuZCIsImdldEJsb2IiLCJVTlNVUFBPUlRFRF9FTlZJUk9OTUVOVCIsInNsaWNlQmxvYiIsImJsb2IiLCJlbmQiLCJ3ZWJraXRTbGljZSIsIm1velNsaWNlIiwiZGVjb2RlQmFzZTY0IiwiZW5jb2RlZCIsInRlc3QiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJTdHJpbmdGb3JtYXQiLCJSQVciLCJCQVNFNjQiLCJCQVNFNjRVUkwiLCJEQVRBX1VSTCIsIlN0cmluZ0RhdGEiLCJkYXRhIiwiY29udGVudFR5cGUiLCJkYXRhRnJvbVN0cmluZyIsInN0cmluZ0RhdGEiLCJ1dGY4Qnl0ZXNfIiwiYmFzZTY0Qnl0ZXNfIiwiZGF0YVVSTEJ5dGVzXyIsImRhdGFVUkxDb250ZW50VHlwZV8iLCJiIiwiYyIsImNoYXJDb2RlQXQiLCJwdXNoIiwidmFsaWQiLCJoaSIsImxvIiwiVWludDhBcnJheSIsInBlcmNlbnRFbmNvZGVkQnl0ZXNfIiwiZGVjb2RlZCIsImhhc01pbnVzIiwiaGFzVW5kZXIiLCJpbnZhbGlkQ2hhciIsImhhc1BsdXMiLCJoYXNTbGFzaCIsImJ5dGVzIiwiaW5jbHVkZXMiLCJhcnJheSIsIkRhdGFVUkxQYXJ0cyIsImRhdGFVUkwiLCJiYXNlNjQiLCJtYXRjaGVzIiwibWF0Y2giLCJtaWRkbGUiLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsInJlc3QiLCJkYXRhVXJsIiwicGFydHMiLCJzIiwibG9uZ0Vub3VnaCIsIkZic0Jsb2IiLCJlbGlkZUNvcHkiLCJzaXplIiwiYmxvYlR5cGUiLCJkYXRhXyIsInR5cGUiLCJBcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJzZXQiLCJzaXplXyIsInR5cGVfIiwic3RhcnRCeXRlIiwiZW5kQnl0ZSIsInJlYWxCbG9iIiwic2xpY2VkIiwiYnVmZmVyIiwiYmxvYmJ5IiwibWFwIiwidmFsIiwidWludDhBcnJheXMiLCJmaW5hbExlbmd0aCIsImZvckVhY2giLCJtZXJnZWQiLCJpbmRleCIsInVwbG9hZERhdGEiLCJqc29uT2JqZWN0T3JOdWxsIiwib2JqIiwiSlNPTiIsInBhcnNlIiwicGFyZW50IiwibGFzdEluZGV4T2YiLCJuZXdQYXRoIiwiY2hpbGQiLCJjaGlsZFBhdGgiLCJjYW5vbmljYWxDaGlsZFBhdGgiLCJzcGxpdCIsImZpbHRlciIsImNvbXBvbmVudCIsImpvaW4iLCJsYXN0Q29tcG9uZW50Iiwibm9YZm9ybV8iLCJtZXRhZGF0YSIsIk1hcHBpbmciLCJzZXJ2ZXIiLCJsb2NhbCIsIndyaXRhYmxlIiwieGZvcm0iLCJtYXBwaW5nc18iLCJ4Zm9ybVBhdGgiLCJmdWxsUGF0aCIsImdldE1hcHBpbmdzIiwibWFwcGluZ3MiLCJtYXBwaW5nc1hmb3JtUGF0aCIsIl9tZXRhZGF0YSIsIm5hbWVNYXBwaW5nIiwieGZvcm1TaXplIiwiTnVtYmVyIiwic2l6ZU1hcHBpbmciLCJhZGRSZWYiLCJzZXJ2aWNlIiwiZ2VuZXJhdGVSZWYiLCJfbWFrZVN0b3JhZ2VSZWZlcmVuY2UiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImZyb21SZXNvdXJjZSIsInJlc291cmNlIiwibGVuIiwibWFwcGluZyIsImZyb21SZXNvdXJjZVN0cmluZyIsInJlc291cmNlU3RyaW5nIiwiZG93bmxvYWRVcmxGcm9tUmVzb3VyY2VTdHJpbmciLCJ0b2tlbnMiLCJ0b2tlbnNMaXN0IiwidXJscyIsInRva2VuIiwiYmFzZSIsInF1ZXJ5U3RyaW5nIiwiYWx0IiwidG9SZXNvdXJjZVN0cmluZyIsInN0cmluZ2lmeSIsIlBSRUZJWEVTX0tFWSIsIklURU1TX0tFWSIsImZyb21CYWNrZW5kUmVzcG9uc2UiLCJsaXN0UmVzdWx0IiwicHJlZml4ZXMiLCJpdGVtcyIsIm5leHRQYWdlVG9rZW4iLCJwYXRoV2l0aG91dFRyYWlsaW5nU2xhc2giLCJyZWZlcmVuY2UiLCJpdGVtIiwiZnJvbVJlc3BvbnNlU3RyaW5nIiwiUmVxdWVzdEluZm8iLCJoYW5kbGVyQ2hlY2siLCJjbmRuIiwibWV0YWRhdGFIYW5kbGVyIiwieGhyIiwidGV4dCIsImxpc3RIYW5kbGVyIiwiZG93bmxvYWRVcmxIYW5kbGVyIiwiX3Byb3RvY29sIiwic2hhcmVkRXJyb3JIYW5kbGVyIiwibmV3RXJyIiwib2JqZWN0RXJyb3JIYW5kbGVyIiwic2hhcmVkIiwiZ2V0TWV0YWRhdGEkMiIsIm1heE9wZXJhdGlvblJldHJ5VGltZSIsImxpc3QkMiIsImRlbGltaXRlciIsInBhZ2VUb2tlbiIsIm1heFJlc3VsdHMiLCJnZXRCeXRlcyQxIiwibWF4RG93bmxvYWRTaXplQnl0ZXMiLCJfIiwiZ2V0RG93bmxvYWRVcmwiLCJ1cGRhdGVNZXRhZGF0YSQyIiwiZGVsZXRlT2JqZWN0JDIiLCJfeGhyIiwiX3RleHQiLCJkZXRlcm1pbmVDb250ZW50VHlwZV8iLCJtZXRhZGF0YUZvclVwbG9hZF8iLCJtZXRhZGF0YUNsb25lIiwibXVsdGlwYXJ0VXBsb2FkIiwiZ2VuQm91bmRhcnkiLCJzdHIiLCJib3VuZGFyeSIsIm1ldGFkYXRhXyIsIm1ldGFkYXRhU3RyaW5nIiwicHJlQmxvYlBhcnQiLCJwb3N0QmxvYlBhcnQiLCJtYXhVcGxvYWRSZXRyeVRpbWUiLCJSZXN1bWFibGVVcGxvYWRTdGF0dXMiLCJjdXJyZW50IiwiZmluYWxpemVkIiwiY2hlY2tSZXN1bWVIZWFkZXJfIiwiYWxsb3dlZCIsImdldFJlc3BvbnNlSGVhZGVyIiwiYWxsb3dlZFN0YXR1cyIsImNyZWF0ZVJlc3VtYWJsZVVwbG9hZCIsIm1ldGFkYXRhRm9yVXBsb2FkIiwiZ2V0UmVzdW1hYmxlVXBsb2FkU3RhdHVzIiwic2l6ZVN0cmluZyIsImlzTmFOIiwiUkVTVU1BQkxFX1VQTE9BRF9DSFVOS19TSVpFIiwiY29udGludWVSZXN1bWFibGVVcGxvYWQiLCJjaHVua1NpemUiLCJieXRlc0xlZnQiLCJieXRlc1RvVXBsb2FkIiwibWluIiwidXBsb2FkQ29tbWFuZCIsInVwbG9hZFN0YXR1cyIsIm5ld0N1cnJlbnQiLCJUYXNrRXZlbnQiLCJTVEFURV9DSEFOR0VEIiwiVGFza1N0YXRlIiwiUlVOTklORyIsIlBBVVNFRCIsIlNVQ0NFU1MiLCJFUlJPUiIsInRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSIsInN0YXRlIiwiT2JzZXJ2ZXIiLCJuZXh0T3JPYnNlcnZlciIsImNvbXBsZXRlIiwiYXNGdW5jdGlvbnMiLCJuZXh0Iiwib2JzZXJ2ZXIiLCJhc3luYyIsImYiLCJhcmdzVG9Gb3J3YXJkIiwidGV4dEZhY3RvcnlPdmVycmlkZSIsIkZldGNoQ29ubmVjdGlvbiIsImVycm9yVGV4dF8iLCJzZW50XyIsImZldGNoXyIsImVycm9yQ29kZV8iLCJyZXNwb25zZSIsInN0YXR1c0NvZGVfIiwiYXJyYXlCdWZmZXIiLCJORVRXT1JLX0VSUk9SIiwiaGVhZGVyIiwibGlzdGVuZXIiLCJGZXRjaFRleHRDb25uZWN0aW9uIiwibmV3VGV4dENvbm5lY3Rpb24iLCJGZXRjaEJ5dGVzQ29ubmVjdGlvbiIsIm5ld0J5dGVzQ29ubmVjdGlvbiIsIkZldGNoU3RyZWFtQ29ubmVjdGlvbiIsImFyZ3VtZW50cyIsInN0cmVhbV8iLCJuZXdTdHJlYW1Db25uZWN0aW9uIiwiVXBsb2FkVGFzayIsInJlZiIsIl90cmFuc2ZlcnJlZCIsIl9uZWVkVG9GZXRjaFN0YXR1cyIsIl9uZWVkVG9GZXRjaE1ldGFkYXRhIiwiX29ic2VydmVycyIsIl9lcnJvciIsIl91cGxvYWRVcmwiLCJfcmVxdWVzdCIsIl9jaHVua011bHRpcGxpZXIiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJfcmVmIiwiX2Jsb2IiLCJfbWFwcGluZ3MiLCJfcmVzdW1hYmxlIiwiX3Nob3VsZERvUmVzdW1hYmxlIiwiX3N0YXRlIiwiX2Vycm9ySGFuZGxlciIsImNvbXBsZXRlVHJhbnNpdGlvbnNfIiwiYmFja29mZkV4cGlyZWQiLCJpc0V4cG9uZW50aWFsQmFja29mZkV4cGlyZWQiLCJzbGVlcFRpbWUiLCJtYXgiLCJfdHJhbnNpdGlvbiIsIl9tZXRhZGF0YUVycm9ySGFuZGxlciIsIm1heFNsZWVwVGltZSIsInN0b3JhZ2UiLCJfcHJvbWlzZSIsIl9zdGFydCIsIl9tYWtlUHJvZ3Jlc3NDYWxsYmFjayIsInNpemVCZWZvcmUiLCJfdXBkYXRlUHJvZ3Jlc3MiLCJfY3JlYXRlUmVzdW1hYmxlIiwiX2ZldGNoU3RhdHVzIiwiX2ZldGNoTWV0YWRhdGEiLCJwZW5kaW5nVGltZW91dCIsIl9jb250aW51ZVVwbG9hZCIsIl9vbmVTaG90VXBsb2FkIiwiX3Jlc29sdmVUb2tlbiIsImNhbGxiYWNrIiwiYWxsIiwiX2dldEF1dGhUb2tlbiIsIl9nZXRBcHBDaGVja1Rva2VuIiwiX2xvY2F0aW9uIiwiY3JlYXRlUmVxdWVzdCIsIl9tYWtlUmVxdWVzdCIsInN0YXR1c1JlcXVlc3QiLCJ1cGxvYWRSZXF1ZXN0IiwibmV3U3RhdHVzIiwiX2luY3JlYXNlTXVsdGlwbGllciIsImN1cnJlbnRTaXplIiwibWV0YWRhdGFSZXF1ZXN0IiwibXVsdGlwYXJ0UmVxdWVzdCIsInRyYW5zZmVycmVkIiwib2xkIiwiX25vdGlmeU9ic2VydmVycyIsIndhc1BhdXNlZCIsInNuYXBzaG90IiwiZXh0ZXJuYWxTdGF0ZSIsImJ5dGVzVHJhbnNmZXJyZWQiLCJ0b3RhbEJ5dGVzIiwidGFzayIsIm9uIiwiY29tcGxldGVkIiwiX2FkZE9ic2VydmVyIiwiX3JlbW92ZU9ic2VydmVyIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiY2F0Y2giLCJfbm90aWZ5T2JzZXJ2ZXIiLCJzcGxpY2UiLCJfZmluaXNoUHJvbWlzZSIsIm9ic2VydmVycyIsInRyaWdnZXJlZCIsImJpbmQiLCJ0b0NhbGwiLCJyZXN1bWUiLCJwYXVzZSIsIlJlZmVyZW5jZSIsIl9zZXJ2aWNlIiwiX25ld1JlZiIsInJvb3QiLCJfdGhyb3dJZlJvb3QiLCJnZXRCeXRlc0ludGVybmFsIiwibWFrZVJlcXVlc3RXaXRoVG9rZW5zIiwiZ2V0U3RyZWFtSW50ZXJuYWwiLCJuZXdNYXhTaXplVHJhbnNmb3JtIiwibiIsIm1pc3NpbmdCeXRlcyIsInRyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJlbWl0Iiwic3RyZWFtIiwicGlwZSIsImRlc3Ryb3kiLCJ1cGxvYWRCeXRlcyQxIiwiZmluYWxNZXRhZGF0YSIsInVwbG9hZEJ5dGVzUmVzdW1hYmxlJDEiLCJ1cGxvYWRTdHJpbmckMSIsImxpc3RBbGwkMSIsImFjY3VtdWxhdG9yIiwibGlzdEFsbEhlbHBlciIsIm9wdCIsIm5leHRQYWdlIiwibGlzdCQxIiwib3B0aW9ucyIsIm9wIiwiZ2V0TWV0YWRhdGEkMSIsInVwZGF0ZU1ldGFkYXRhJDEiLCJnZXREb3dubG9hZFVSTCQxIiwiZGVsZXRlT2JqZWN0JDEiLCJfZ2V0Q2hpbGQkMSIsImlzVXJsIiwicmVmRnJvbVVSTCIsInJlZkZyb21QYXRoIiwiRmlyZWJhc2VTdG9yYWdlSW1wbCIsIl9idWNrZXQiLCJyZWYkMSIsInNlcnZpY2VPclJlZiIsInBhdGhPclVybCIsImV4dHJhY3RCdWNrZXQiLCJjb25maWciLCJjb25uZWN0U3RvcmFnZUVtdWxhdG9yJDEiLCJwb3J0IiwibW9ja1VzZXJUb2tlbiIsIl9vdmVycmlkZUF1dGhUb2tlbiIsImFwcCIsInByb2plY3RJZCIsIl9hdXRoUHJvdmlkZXIiLCJfYXBwQ2hlY2tQcm92aWRlciIsIl91cmwiLCJfZmlyZWJhc2VWZXJzaW9uIiwiX2hvc3QiLCJfYXBwSWQiLCJfZGVsZXRlZCIsIl9tYXhPcGVyYXRpb25SZXRyeVRpbWUiLCJfbWF4VXBsb2FkUmV0cnlUaW1lIiwiX3JlcXVlc3RzIiwiU2V0IiwidGltZSIsIlBPU0lUSVZFX0lORklOSVRZIiwiYXV0aCIsImdldEltbWVkaWF0ZSIsIm9wdGlvbmFsIiwidG9rZW5EYXRhIiwiZ2V0VG9rZW4iLCJhY2Nlc3NUb2tlbiIsImFwcENoZWNrIiwiX2RlbGV0ZSIsInJlcXVlc3QiLCJjbGVhciIsImFkZCIsImRlbGV0ZSIsIlNUT1JBR0VfVFlQRSIsImdldEJ5dGVzIiwidXBsb2FkQnl0ZXMiLCJ1cGxvYWRTdHJpbmciLCJ1cGxvYWRCeXRlc1Jlc3VtYWJsZSIsImdldE1ldGFkYXRhIiwidXBkYXRlTWV0YWRhdGEiLCJsaXN0IiwibGlzdEFsbCIsImdldERvd25sb2FkVVJMIiwiZGVsZXRlT2JqZWN0IiwiX2dldENoaWxkIiwiZ2V0U3RvcmFnZSIsImJ1Y2tldFVybCIsInN0b3JhZ2VQcm92aWRlciIsInN0b3JhZ2VJbnN0YW5jZSIsImlkZW50aWZpZXIiLCJlbXVsYXRvciIsImNvbm5lY3RTdG9yYWdlRW11bGF0b3IiLCJFcnJvciIsImdldFN0cmVhbSIsImZhY3RvcnkiLCJjb250YWluZXIiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJnZXRQcm92aWRlciIsImF1dGhQcm92aWRlciIsImFwcENoZWNrUHJvdmlkZXIiLCJyZWdpc3RlclN0b3JhZ2UiLCJzZXRNdWx0aXBsZUluc3RhbmNlcyIsIl9GYnNCbG9iIiwiX0xvY2F0aW9uIiwiX1Rhc2tFdmVudCIsIl9UYXNrU3RhdGUiLCJfVXBsb2FkVGFzayIsIl9kYXRhRnJvbVN0cmluZyIsIl9pbnZhbGlkQXJndW1lbnQiLCJfaW52YWxpZFJvb3RPcGVyYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@firebase/storage/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */ const CONSTANTS = {\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */ NODE_CLIENT: false,\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */ NODE_ADMIN: false,\n    /**\r\n     * Firebase SDK Version\r\n     */ SDK_VERSION: \"${JSCORE_VERSION}\"\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Throws an error if the provided assertion is falsy\r\n */ const assert = function(assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\r\n * Returns an Error object suitable for throwing.\r\n */ const assertionError = function(message) {\n    return new Error(\"Firebase Database (\" + CONSTANTS.SDK_VERSION + \") INTERNAL ASSERT FAILED: \" + message);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const stringToByteArray$1 = function(str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */ const byteArrayToString = function(bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while(pos < bytes.length){\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        } else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n        } else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        } else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n        }\n    }\n    return out.join(\"\");\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\nconst base64 = {\n    /**\r\n     * Maps bytes to characters.\r\n     */ byteToCharMap_: null,\n    /**\r\n     * Maps characters to bytes.\r\n     */ charToByteMap_: null,\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */ byteToCharMapWebSafe_: null,\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */ charToByteMapWebSafe_: null,\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */ ENCODED_VALS_BASE: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz\" + \"0123456789\",\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */ get ENCODED_VALS () {\n        return this.ENCODED_VALS_BASE + \"+/=\";\n    },\n    /**\r\n     * Our websafe alphabet.\r\n     */ get ENCODED_VALS_WEBSAFE () {\n        return this.ENCODED_VALS_BASE + \"-_.\";\n    },\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */ HAS_NATIVE_SUPPORT: typeof atob === \"function\",\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeByteArray (input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error(\"encodeByteArray takes an array as a parameter\");\n        }\n        this.init_();\n        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n        const output = [];\n        for(let i = 0; i < input.length; i += 3){\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n            let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join(\"\");\n    },\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */ decodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */ decodeStringToByteArray (input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n        const output = [];\n        for(let i = 0; i < input.length;){\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = byte1 << 2 | byte2 >> 4;\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = byte3 << 6 & 0xc0 | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */ init_ () {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for(let i = 0; i < this.ENCODED_VALS.length; i++){\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\r\n * An error encountered while decoding base64 string.\r\n */ class DecodeBase64StringError extends Error {\n    constructor(){\n        super(...arguments);\n        this.name = \"DecodeBase64StringError\";\n    }\n}\n/**\r\n * URL-safe base64 encoding\r\n */ const base64Encode = function(str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */ const base64urlEncodeWithoutPadding = function(str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, \"\");\n};\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */ const base64Decode = function(str) {\n    try {\n        return base64.decodeString(str, true);\n    } catch (e) {\n        console.error(\"base64Decode failed: \", e);\n    }\n    return null;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */ function deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */ function deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch(source.constructor){\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for(const prop in source){\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== \"__proto__\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */ function getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    throw new Error(\"Unable to locate global object.\");\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const getDefaultsFromGlobal = ()=>getGlobal().__FIREBASE_DEFAULTS__;\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */ const getDefaultsFromEnvVariable = ()=>{\n    if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = ()=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    } catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */ const getDefaults = ()=>{\n    try {\n        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();\n    } catch (e) {\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */ console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */ const getDefaultEmulatorHost = (productName)=>{\n    var _a, _b;\n    return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];\n};\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */ const getDefaultEmulatorHostnameAndPort = (productName)=>{\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(\":\"); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === \"[\") {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [\n            host.substring(1, separatorIndex - 1),\n            port\n        ];\n    } else {\n        return [\n            host.substring(0, separatorIndex),\n            port\n        ];\n    }\n};\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */ const getDefaultAppConfig = ()=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;\n};\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */ const getExperimentalSetting = (name)=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`];\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Deferred {\n    constructor(){\n        this.reject = ()=>{};\n        this.resolve = ()=>{};\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */ wrapCallback(callback) {\n        return (error, value)=>{\n            if (error) {\n                this.reject(error);\n            } else {\n                this.resolve(value);\n            }\n            if (typeof callback === \"function\") {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(()=>{});\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                } else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: \"none\",\n        type: \"JWT\"\n    };\n    const project = projectId || \"demo-project\";\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({\n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`,\n        aud: project,\n        iat,\n        exp: iat + 3600,\n        auth_time: iat,\n        sub,\n        user_id: sub,\n        firebase: {\n            sign_in_provider: \"custom\",\n            identities: {}\n        }\n    }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = \"\";\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join(\".\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */ function getUA() {\n    if (typeof navigator !== \"undefined\" && typeof navigator[\"userAgent\"] === \"string\") {\n        return navigator[\"userAgent\"];\n    } else {\n        return \"\";\n    }\n}\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */ function isMobileCordova() {\n    return  false && 0;\n}\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */ // Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === \"node\") {\n        return true;\n    } else if (forceEnvironment === \"browser\") {\n        return false;\n    }\n    try {\n        return Object.prototype.toString.call(global.process) === \"[object process]\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * Detect Browser Environment\r\n */ function isBrowser() {\n    return  false || isWebWorker();\n}\n/**\r\n * Detect Web Worker context\r\n */ function isWebWorker() {\n    return typeof WorkerGlobalScope !== \"undefined\" && typeof self !== \"undefined\" && self instanceof WorkerGlobalScope;\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === \"object\" ? chrome.runtime : typeof browser === \"object\" ? browser.runtime : undefined;\n    return typeof runtime === \"object\" && runtime.id !== undefined;\n}\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */ function isReactNative() {\n    return typeof navigator === \"object\" && navigator[\"product\"] === \"ReactNative\";\n}\n/** Detects Electron apps. */ function isElectron() {\n    return getUA().indexOf(\"Electron/\") >= 0;\n}\n/** Detects Internet Explorer. */ function isIE() {\n    const ua = getUA();\n    return ua.indexOf(\"MSIE \") >= 0 || ua.indexOf(\"Trident/\") >= 0;\n}\n/** Detects Universal Windows Platform apps. */ function isUWP() {\n    return getUA().indexOf(\"MSAppHost/\") >= 0;\n}\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */ function isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */ function isSafari() {\n    return !isNode() && !!navigator.userAgent && navigator.userAgent.includes(\"Safari\") && !navigator.userAgent.includes(\"Chrome\");\n}\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */ function isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === \"object\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */ function validateIndexedDBOpenable() {\n    return new Promise((resolve, reject)=>{\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = \"validate-browser-context-for-indexeddb-analytics-module\";\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = ()=>{\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = ()=>{\n                preExist = false;\n            };\n            request.onerror = ()=>{\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || \"\");\n            };\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */ function areCookiesEnabled() {\n    if (typeof navigator === \"undefined\" || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */ const ERROR_NAME = \"FirebaseError\";\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(/** The error code for this error. */ code, message, /** Custom data for this error. */ customData){\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */ this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors){\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : \"Error\";\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key)=>{\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */ function jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */ function stringify(data) {\n    return JSON.stringify(data);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const decode = function(token) {\n    let header = {}, claims = {}, data = {}, signature = \"\";\n    try {\n        const parts = token.split(\".\");\n        header = jsonEval(base64Decode(parts[0]) || \"\");\n        claims = jsonEval(base64Decode(parts[1]) || \"\");\n        signature = parts[2];\n        data = claims[\"d\"] || {};\n        delete claims[\"d\"];\n    } catch (e) {}\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidTimestamp = function(token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === \"object\") {\n        if (claims.hasOwnProperty(\"nbf\")) {\n            validSince = claims[\"nbf\"];\n        } else if (claims.hasOwnProperty(\"iat\")) {\n            validSince = claims[\"iat\"];\n        }\n        if (claims.hasOwnProperty(\"exp\")) {\n            validUntil = claims[\"exp\"];\n        } else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;\n};\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const issuedAtTime = function(token) {\n    const claims = decode(token).claims;\n    if (typeof claims === \"object\" && claims.hasOwnProperty(\"iat\")) {\n        return claims[\"iat\"];\n    }\n    return null;\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidFormat = function(token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === \"object\" && claims.hasOwnProperty(\"iat\");\n};\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isAdmin = function(token) {\n    const claims = decode(token).claims;\n    return typeof claims === \"object\" && claims[\"admin\"] === true;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    } else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */ function deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys){\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        } else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys){\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === \"object\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */ function promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(()=>deferredPromise.reject(\"timeout!\"), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */ function querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)){\n        if (Array.isArray(value)) {\n            value.forEach((arrayVal)=>{\n                params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(arrayVal));\n            });\n        } else {\n            params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n        }\n    }\n    return params.length ? \"&\" + params.join(\"&\") : \"\";\n}\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */ function querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, \"\").split(\"&\");\n    tokens.forEach((token)=>{\n        if (token) {\n            const [key, value] = token.split(\"=\");\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */ function extractQuerystring(url) {\n    const queryStart = url.indexOf(\"?\");\n    if (!queryStart) {\n        return \"\";\n    }\n    const fragmentStart = url.indexOf(\"#\", queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */ /**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */ class Sha1 {\n    constructor(){\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */ this.chain_ = [];\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */ this.buf_ = [];\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */ this.W_ = [];\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */ this.pad_ = [];\n        /**\r\n         * @private {number}\r\n         */ this.inbuf_ = 0;\n        /**\r\n         * @private {number}\r\n         */ this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for(let i = 1; i < this.blockSize; ++i){\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */ compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === \"string\") {\n            for(let i = 0; i < 16; i++){\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        } else {\n            for(let i = 0; i < 16; i++){\n                W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for(let i = 16; i < 80; i++){\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = (t << 1 | t >>> 31) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for(let i = 0; i < 80; i++){\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ b & (c ^ d);\n                    k = 0x5a827999;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            } else {\n                if (i < 60) {\n                    f = b & c | d & (b | c);\n                    k = 0x8f1bbcdc;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;\n            e = d;\n            d = c;\n            c = (b << 30 | b >>> 2) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = this.chain_[0] + a & 0xffffffff;\n        this.chain_[1] = this.chain_[1] + b & 0xffffffff;\n        this.chain_[2] = this.chain_[2] + c & 0xffffffff;\n        this.chain_[3] = this.chain_[3] + d & 0xffffffff;\n        this.chain_[4] = this.chain_[4] + e & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while(n < length){\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while(n <= lengthMinusBlock){\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === \"string\") {\n                while(n < length){\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            } else {\n                while(n < length){\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */ digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        } else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for(let i = this.blockSize - 1; i >= 56; i--){\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for(let i = 0; i < 5; i++){\n            for(let j = 24; j >= 0; j -= 8){\n                digest[n] = this.chain_[i] >> j & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */ function createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */ class ObserverProxy {\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */ constructor(executor, onNoObservers){\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task.then(()=>{\n            executor(this);\n        }).catch((e)=>{\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer)=>{\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer)=>{\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer)=>{\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */ subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n            throw new Error(\"Missing Observer.\");\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            \"next\",\n            \"error\",\n            \"complete\"\n        ])) {\n            observer = nextOrObserver;\n        } else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(()=>{\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    } else {\n                        observer.complete();\n                    }\n                } catch (e) {\n                // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for(let i = 0; i < this.observers.length; i++){\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                } catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== \"undefined\" && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */ // eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args)=>{\n        Promise.resolve(true).then(()=>{\n            fn(...args);\n        }).catch((error)=>{\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */ function implementsAnyMethods(obj, methods) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return false;\n    }\n    for (const method of methods){\n        if (method in obj && typeof obj[method] === \"function\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n// do nothing\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */ const validateArgCount = function(fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = \"at least \" + minCount;\n    } else if (argCount > maxCount) {\n        argError = maxCount === 0 ? \"none\" : \"no more than \" + maxCount;\n    }\n    if (argError) {\n        const error = fnName + \" failed: Was called with \" + argCount + (argCount === 1 ? \" argument.\" : \" arguments.\") + \" Expects \" + argError + \".\";\n        throw new Error(error);\n    }\n};\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */ function errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */ function validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== \"string\") {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, \"namespace\") + \"must be a valid firebase namespace.\");\n    }\n}\nfunction validateCallback(fnName, argumentName, // eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== \"function\") {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid function.\");\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== \"object\" || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid context object.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */ const stringToByteArray = function(str) {\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, \"Surrogate pair missing trail surrogate.\");\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if (c < 65536) {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */ const stringLength = function(str) {\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        } else if (c < 2048) {\n            p += 2;\n        } else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        } else {\n            p += 3;\n        }\n    }\n    return p;\n};\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */ const uuidv4 = function() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0, v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The amount of milliseconds to exponentially increase.\r\n */ const DEFAULT_INTERVAL_MILLIS = 1000;\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */ const DEFAULT_BACKOFF_FACTOR = 2;\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */ const MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */ const RANDOM_FACTOR = 0.5;\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */ function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(// A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n    // if we add or subtract.\n    (Math.random() - 0.5) * 2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provide English ordinal letters after a number\r\n */ function ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return \"th\";\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return \"st\";\n    }\n    if (dec === 2) {\n        return \"nd\";\n    }\n    if (dec === 3) {\n        return \"rd\";\n    }\n    return \"th\";\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    } else {\n        return service;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L25vZGUtZXNtL2luZGV4Lm5vZGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVk7SUFDZDs7S0FFQyxHQUNEQyxhQUFhO0lBQ2I7O0tBRUMsR0FDREMsWUFBWTtJQUNaOztLQUVDLEdBQ0RDLGFBQWE7QUFDakI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1DLFNBQVMsU0FBVUMsU0FBUyxFQUFFQyxPQUFPO0lBQ3ZDLElBQUksQ0FBQ0QsV0FBVztRQUNaLE1BQU1FLGVBQWVEO0lBQ3pCO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQixTQUFVRCxPQUFPO0lBQ3BDLE9BQU8sSUFBSUUsTUFBTSx3QkFDYlIsVUFBVUcsV0FBVyxHQUNyQiwrQkFDQUc7QUFDUjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1HLHNCQUFzQixTQUFVQyxHQUFHO0lBQ3JDLDJEQUEyRDtJQUMzRCxNQUFNQyxNQUFNLEVBQUU7SUFDZCxJQUFJQyxJQUFJO0lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILElBQUlJLE1BQU0sRUFBRUQsSUFBSztRQUNqQyxJQUFJRSxJQUFJTCxJQUFJTSxVQUFVLENBQUNIO1FBQ3ZCLElBQUlFLElBQUksS0FBSztZQUNUSixHQUFHLENBQUNDLElBQUksR0FBR0c7UUFDZixPQUNLLElBQUlBLElBQUksTUFBTTtZQUNmSixHQUFHLENBQUNDLElBQUksR0FBRyxLQUFNLElBQUs7WUFDdEJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLElBQUssS0FBTTtRQUMxQixPQUNLLElBQUksQ0FBQ0csSUFBSSxN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QVNDLG1CQUFtQjdKLE9BQU87SUFDL0IsSUFBSUEsV0FBV0EsUUFBUThKLFNBQVMsRUFBRTtRQUM5QixPQUFPOUosUUFBUThKLFNBQVM7SUFDNUIsT0FDSztRQUNELE9BQU85SjtJQUNYO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxrRUFBa0U7QUFDbEU1TSxVQUFVQyxXQUFXLEdBQUc7QUFFaTlCLENBQ3orQiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaGVraGFyLWVudGVycHJpc2VzLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanM/OWU3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxyXG4gKi9cclxuY29uc3QgQ09OU1RBTlRTID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cclxuICAgICAqL1xyXG4gICAgTk9ERV9DTElFTlQ6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIEFkbWluIE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWJhc2UgU0RLIFZlcnNpb25cclxuICAgICAqL1xyXG4gICAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XHJcbiAqL1xyXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxyXG4gKi9cclxuY29uc3QgYXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xyXG4gICAgICAgIENPTlNUQU5UUy5TREtfVkVSU0lPTiArXHJcbiAgICAgICAgJykgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogJyArXHJcbiAgICAgICAgbWVzc2FnZSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5JDEgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxyXG4gICAgICAgICAgICBpICsgMSA8IHN0ci5sZW5ndGggJiZcclxuICAgICAgICAgICAgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xyXG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDAzZmYpO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogVHVybnMgYW4gYXJyYXkgb2YgbnVtYmVycyBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXHJcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cclxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXHJcbiAqIEByZXR1cm4gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XHJcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XHJcbiAgICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYzEgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMxID4gMjM5ICYmIGMxIDwgMzY1KSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzQgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxyXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCArICh1ID4+IDEwKSk7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxufTtcclxuLy8gV2UgZGVmaW5lIGl0IGFzIGFuIG9iamVjdCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjbGFzcyBiZWNhdXNlIGEgY2xhc3MgY29tcGlsZWQgZG93biB0byBlczUgY2FuJ3RcclxuLy8gYmUgdHJlZXNoYWtlZC4gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE2OTFcclxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcclxuY29uc3QgYmFzZTY0ID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB3ZWJzYWZlIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LCBzaGFyZWQgYmV0d2VlblxyXG4gICAgICogRU5DT0RFRF9WQUxTIGFuZCBFTkNPREVEX1ZBTFNfV0VCU0FGRVxyXG4gICAgICovXHJcbiAgICBFTkNPREVEX1ZBTFNfQkFTRTogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicgKyAnMDEyMzQ1Njc4OScsXHJcbiAgICAvKipcclxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxyXG4gICAgICovXHJcbiAgICBnZXQgRU5DT0RFRF9WQUxTX1dFQlNBRkUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cclxuICAgICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcclxuICAgICAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxyXG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGFuIGFycmF5IG9mIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXHJcbiAgICAgKiAgICAgdmFsdWUgaW4gWzAsIDI1NV0pIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFtpXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSBieXRlMSA+PiAyO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTQgPSBieXRlMyAmIDB4M2Y7XHJcbiAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRCeXRlMyA9IDY0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZUJ5dGVBcnJheShzdHJpbmdUb0J5dGVBcnJheSQxKGlucHV0KSwgd2ViU2FmZSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxyXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXRvYihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXHJcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XHJcbiAgICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXHJcbiAgICAgKlxyXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxyXG4gICAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcclxuICAgICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdF8oKTtcclxuICAgICAgICBjb25zdCBjaGFyVG9CeXRlTWFwID0gd2ViU2FmZVxyXG4gICAgICAgICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfXHJcbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGU0ID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTQgPSBoYXZlQnl0ZTQgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kZUJhc2U2NFN0cmluZ0Vycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSAoYnl0ZTEgPDwgMikgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUxKTtcclxuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUyIDw8IDQpICYgMHhmMCkgfCAoYnl0ZTMgPj4gMik7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTMgPSAoKGJ5dGUzIDw8IDYpICYgMHhjMCkgfCBieXRlNDtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXHJcbiAgICAgKiBhY2Nlc3NpbmcgYW55IG9mIHRoZSBzdGF0aWMgbWFwIHZhcmlhYmxlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGluaXRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ieXRlVG9DaGFyTWFwXykge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcclxuICAgICAgICAgICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cclxuICAgICAgICAgICAgICAgIGlmIChpID49IHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cclxuICovXHJcbmNsYXNzIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3InO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmdcclxuICovXHJcbmNvbnN0IGJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5JDEoc3RyKTtcclxuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cclxuICogZS5nLiBVc2VkIGluIEpTT04gV2ViIFRva2VuIChKV1QpIHBhcnRzLlxyXG4gKi9cclxuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAvLyBVc2UgYmFzZTY0dXJsIGVuY29kaW5nIGFuZCByZW1vdmUgcGFkZGluZyBpbiB0aGUgZW5kIChkb3QgY2hhcmFjdGVycykuXHJcbiAgICByZXR1cm4gYmFzZTY0RW5jb2RlKHN0cikucmVwbGFjZSgvXFwuL2csICcnKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xyXG4gKlxyXG4gKiBOT1RFOiBETyBOT1QgdXNlIHRoZSBnbG9iYWwgYXRvYigpIGZ1bmN0aW9uIC0gaXQgZG9lcyBOT1Qgc3VwcG9ydCB0aGVcclxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdHIgVG8gYmUgZGVjb2RlZFxyXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxyXG4gKi9cclxuY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxyXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXHJcbiAqIElmIHRhcmdldCBpcyB1bmRlZmluZWQsIGFuIG9iamVjdCBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZSB3aWxsIGJlIGNyZWF0ZWRcclxuICogKGFuZCByZXR1cm5lZCkuXHJcbiAqXHJcbiAqIFdlIHJlY3Vyc2l2ZWx5IGNvcHkgYWxsIGNoaWxkIHByb3BlcnRpZXMgb2YgcGxhaW4gT2JqZWN0cyBpbiB0aGUgc291cmNlLSBzb1xyXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSB0YXJnZXQgY2FuIGJlIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHByb3BlcnRpZXMgaW5cclxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cclxuICpcclxuICogTm90ZTogd2UgZG9uJ3QgbWVyZ2UgX19wcm90b19fIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHNvdXJjZS5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIGNhc2UgRGF0ZTpcclxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcclxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxyXG4gICAgICAgICAgICBjb25zdCBkYXRlVmFsdWUgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcclxuICAgICAgICBjYXNlIE9iamVjdDpcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEFycmF5OlxyXG4gICAgICAgICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgdGFyZ2V0ID0gW107XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xyXG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxyXG4gICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc1ZhbGlkS2V5KHByb3ApKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcclxuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cclxuICogQHJldHVybnMgdGhlIGBnbG9iYWxUaGlzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdC4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21HbG9iYWwgPSAoKSA9PiBnZXRHbG9iYWwoKS5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XHJcbi8qKlxyXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXHJcbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb3IgYSBKU09OIGZpbGUgd2hvc2UgcGF0aCBpcyBpblxyXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19QQVRIX19cclxuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XHJcbiAqIGhhbmRsZSBzZWVpbmcgdGhhdCB2YXJpYWJsZSBpbiBjb21tZW50cy5cclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzY4MzhcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlID0gKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmYXVsdHNKc29uU3RyaW5nID0gcHJvY2Vzcy5lbnYuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xyXG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlZmF1bHRzSnNvblN0cmluZyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUNvb2tpZSA9ICgpID0+IHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IG1hdGNoO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvX19GSVJFQkFTRV9ERUZBVUxUU19fPShbXjtdKykvKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBBbmd1bGFyIFVuaXZlcnNhbCBTU1IgaGF2ZSBhXHJcbiAgICAgICAgLy8gYGRvY3VtZW50YCBvYmplY3QgYnV0IGVycm9yIG9uIGFjY2Vzc2luZyBgZG9jdW1lbnQuY29va2llYC5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWNvZGVkID0gbWF0Y2ggJiYgYmFzZTY0RGVjb2RlKG1hdGNoWzFdKTtcclxuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcclxuICogKDEpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBhcyBhIHByb3BlcnR5IG9mIGBnbG9iYWxUaGlzYFxyXG4gKiAoMikgaWYgc3VjaCBhbiBvYmplY3Qgd2FzIHByb3ZpZGVkIG9uIGEgc2hlbGwgZW52aXJvbm1lbnQgdmFyaWFibGVcclxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChnZXREZWZhdWx0c0Zyb21HbG9iYWwoKSB8fFxyXG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XHJcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUNvb2tpZSgpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2F0Y2gtYWxsIGZvciBiZWluZyB1bmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWVcclxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cclxuICAgICAgICAgKiBpbmZvIGluc3RlYWQgb2Ygc3dhbGxvd2luZyBzbyB3ZSBjYW4gZmluZCB0aGVzZSB1bmtub3duIGNhc2VzXHJcbiAgICAgICAgICogYW5kIGFkZCBwYXRocyBmb3IgdGhlbSBpZiBuZWVkZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc29sZS5pbmZvKGBVbmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWUgdG86ICR7ZX1gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XHJcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cclxuICogQHJldHVybnMgYSBVUkwgaG9zdCBmb3JtYXR0ZWQgbGlrZSBgMTI3LjAuMC4xOjk5OTlgIG9yIGBbOjoxXTo0MDAwYCBpZiBhdmFpbGFibGVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCA9IChwcm9kdWN0TmFtZSkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtdWxhdG9ySG9zdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltwcm9kdWN0TmFtZV07IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3RuYW1lIGFuZCBwb3J0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxyXG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXHJcbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcclxuICAgIGNvbnN0IGhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KHByb2R1Y3ROYW1lKTtcclxuICAgIGlmICghaG9zdCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IGhvc3QubGFzdEluZGV4T2YoJzonKTsgLy8gRmluZGluZyB0aGUgbGFzdCBzaW5jZSBJUHY2IGFkZHIgYWxzbyBoYXMgY29sb25zLlxyXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3N0ICR7aG9zdH0gd2l0aCBubyBzZXBhcmF0ZSBob3N0bmFtZSBhbmQgcG9ydCFgKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLCAxMCk7XHJcbiAgICBpZiAoaG9zdFswXSA9PT0gJ1snKSB7XHJcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXHJcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygxLCBzZXBhcmF0b3JJbmRleCAtIDEpLCBwb3J0XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpLCBwb3J0XTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgRmlyZWJhc2UgYXBwIGNvbmZpZyBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRBcHBDb25maWcgPSAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWc7IH07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nIG9uIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0IChwcm9wZXJ0aWVzXHJcbiAqIHByZWZpeGVkIGJ5IFwiX1wiKVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXRFeHBlcmltZW50YWxTZXR0aW5nID0gKG5hbWUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2BfJHtuYW1lfWBdOyB9O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBEZWZlcnJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlamVjdCA9ICgpID0+IHsgfTtcclxuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3VyIEFQSSBpbnRlcm5hbHMgYXJlIG5vdCBwcm9taXNlaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcclxuICAgICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXHJcbiAgICAgKiBhbmQgcmV0dXJucyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgd2hpY2ggd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgRGVmZXJyZWQncyBwcm9taXNlLlxyXG4gICAgICovXHJcbiAgICB3cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gKGVycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0YWNoaW5nIG5vb3AgaGFuZGxlciBqdXN0IGluIGNhc2UgZGV2ZWxvcGVyIHdhc24ndCBleHBlY3RpbmdcclxuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIHBhcmFtZXRlciBsZW5ndGggaXMgMVxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU1vY2tVc2VyVG9rZW4odG9rZW4sIHByb2plY3RJZCkge1xyXG4gICAgaWYgKHRva2VuLnVpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIFwibm9uZVwiIGFzIHRoZSBhbGdvcml0aG0uXHJcbiAgICBjb25zdCBoZWFkZXIgPSB7XHJcbiAgICAgICAgYWxnOiAnbm9uZScsXHJcbiAgICAgICAgdHlwZTogJ0pXVCdcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdElkIHx8ICdkZW1vLXByb2plY3QnO1xyXG4gICAgY29uc3QgaWF0ID0gdG9rZW4uaWF0IHx8IDA7XHJcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcclxuICAgIGlmICghc3ViKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9ja1VzZXJUb2tlbiBtdXN0IGNvbnRhaW4gJ3N1Yicgb3IgJ3VzZXJfaWQnIGZpZWxkIVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZXF1aXJlZCBmaWVsZHMgdG8gZGVjZW50IGRlZmF1bHRzXHJcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XHJcbiAgICAgICAgICAgIHNpZ25faW5fcHJvdmlkZXI6ICdjdXN0b20nLFxyXG4gICAgICAgICAgICBpZGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0gfSwgdG9rZW4pO1xyXG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIHRoZSBlbXB0eSBzdHJpbmcgYXMgYSBzaWduYXR1cmUuXHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSAnJztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksXHJcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLFxyXG4gICAgICAgIHNpZ25hdHVyZVxyXG4gICAgXS5qb2luKCcuJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgb3IgJycgaWYgaXQncyBub3QgZGVmaW5lZC5cclxuICogQHJldHVybiB1c2VyIGFnZW50IHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VUEoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZWN0IENvcmRvdmEgLyBQaG9uZUdhcCAvIElvbmljIGZyYW1ld29ya3Mgb24gYSBtb2JpbGUgZGV2aWNlLlxyXG4gKlxyXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcFxyXG4gKiBpbiB0aGUgUmlwcGxlIGVtdWxhdG9yKSBub3IgQ29yZG92YSBgb25EZXZpY2VSZWFkeWAsIHdoaWNoIHdvdWxkIG5vcm1hbGx5XHJcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXHJcbiAqL1xyXG5mdW5jdGlvbiBpc01vYmlsZUNvcmRvdmEoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBTZXR0aW5nIHVwIGFuIGJyb2FkbHkgYXBwbGljYWJsZSBpbmRleCBzaWduYXR1cmUgZm9yIFdpbmRvd1xyXG4gICAgICAgIC8vIGp1c3QgdG8gZGVhbCB3aXRoIHRoaXMgY2FzZSB3b3VsZCBwcm9iYWJseSBiZSBhIGJhZCBpZGVhLlxyXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXHJcbiAgICAgICAgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QoZ2V0VUEoKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgTm9kZS5qcy5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxyXG4gKi9cclxuLy8gTm9kZSBkZXRlY3Rpb24gbG9naWMgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2lsaWFrYW4vZGV0ZWN0LW5vZGUvXHJcbmZ1bmN0aW9uIGlzTm9kZSgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGZvcmNlRW52aXJvbm1lbnQgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2VFbnZpcm9ubWVudDtcclxuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgfHwgaXNXZWJXb3JrZXIoKTtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IFdlYiBXb3JrZXIgY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaXNXZWJXb3JrZXIoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQnJvd3NlckV4dGVuc2lvbigpIHtcclxuICAgIGNvbnN0IHJ1bnRpbWUgPSB0eXBlb2YgY2hyb21lID09PSAnb2JqZWN0J1xyXG4gICAgICAgID8gY2hyb21lLnJ1bnRpbWVcclxuICAgICAgICA6IHR5cGVvZiBicm93c2VyID09PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICA/IGJyb3dzZXIucnVudGltZVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiB0eXBlb2YgcnVudGltZSA9PT0gJ29iamVjdCcgJiYgcnVudGltZS5pZCAhPT0gdW5kZWZpbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgUmVhY3QgTmF0aXZlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3JbJ3Byb2R1Y3QnXSA9PT0gJ1JlYWN0TmF0aXZlJyk7XHJcbn1cclxuLyoqIERldGVjdHMgRWxlY3Ryb24gYXBwcy4gKi9cclxuZnVuY3Rpb24gaXNFbGVjdHJvbigpIHtcclxuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ0VsZWN0cm9uLycpID49IDA7XHJcbn1cclxuLyoqIERldGVjdHMgSW50ZXJuZXQgRXhwbG9yZXIuICovXHJcbmZ1bmN0aW9uIGlzSUUoKSB7XHJcbiAgICBjb25zdCB1YSA9IGdldFVBKCk7XHJcbiAgICByZXR1cm4gdWEuaW5kZXhPZignTVNJRSAnKSA+PSAwIHx8IHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgPj0gMDtcclxufVxyXG4vKiogRGV0ZWN0cyBVbml2ZXJzYWwgV2luZG93cyBQbGF0Zm9ybSBhcHBzLiAqL1xyXG5mdW5jdGlvbiBpc1VXUCgpIHtcclxuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ01TQXBwSG9zdC8nKSA+PSAwO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBTREsgYnVpbGQgaXMgdGhlIE5vZGUgdmVyc2lvbi5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIGl0J3MgdGhlIE5vZGUgU0RLIGJ1aWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNOb2RlU2RrKCkge1xyXG4gICAgcmV0dXJuIENPTlNUQU5UUy5OT0RFX0NMSUVOVCA9PT0gdHJ1ZSB8fCBDT05TVEFOVFMuTk9ERV9BRE1JTiA9PT0gdHJ1ZTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHdlIGFyZSBydW5uaW5nIGluIFNhZmFyaS4gKi9cclxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XHJcbiAgICByZXR1cm4gKCFpc05vZGUoKSAmJlxyXG4gICAgICAgICEhbmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxyXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ1NhZmFyaScpICYmXHJcbiAgICAgICAgIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ0Nocm9tZScpKTtcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcclxuICogQHJldHVybiB0cnVlIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcclxuICovXHJcbmZ1bmN0aW9uIGlzSW5kZXhlZERCQXZhaWxhYmxlKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGluZGV4ZWREQiA9PT0gJ29iamVjdCc7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgdmFsaWRhdGVzIGJyb3dzZXIvc3cgY29udGV4dCBmb3IgaW5kZXhlZERCIGJ5IG9wZW5pbmcgYSBkdW1teSBpbmRleGVkREIgZGF0YWJhc2UgYW5kIHJlamVjdFxyXG4gKiBpZiBlcnJvcnMgb2NjdXIgZHVyaW5nIHRoZSBkYXRhYmFzZSBvcGVuIG9wZXJhdGlvbi5cclxuICpcclxuICogQHRocm93cyBleGNlcHRpb24gaWYgY3VycmVudCBicm93c2VyL3N3IGNvbnRleHQgY2FuJ3QgcnVuIGlkYi5vcGVuIChleDogU2FmYXJpIGlmcmFtZSwgRmlyZWZveFxyXG4gKiBwcml2YXRlIGJyb3dzaW5nKVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHByZUV4aXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgREJfQ0hFQ0tfTkFNRSA9ICd2YWxpZGF0ZS1icm93c2VyLWNvbnRleHQtZm9yLWluZGV4ZWRkYi1hbmFseXRpY3MtbW9kdWxlJztcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYuaW5kZXhlZERCLm9wZW4oREJfQ0hFQ0tfTkFNRSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXN1bHQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBkYXRhYmFzZSBvbmx5IHdoZW4gaXQgZG9lc24ndCBwcmUtZXhpc3RcclxuICAgICAgICAgICAgICAgIGlmICghcHJlRXhpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShEQl9DSEVDS19OQU1FKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJlRXhpc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KCgoX2EgPSByZXF1ZXN0LmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJycpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICpcclxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxyXG4gKiBAcmV0dXJuIHRydWUgaWYgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxyXG4gKi9cclxuZnVuY3Rpb24gYXJlQ29va2llc0VuYWJsZWQoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhbmRhcmRpemVkIEZpcmViYXNlIEVycm9yLlxyXG4gKlxyXG4gKiBVc2FnZTpcclxuICpcclxuICogICAvLyBUeXBlc2NyaXB0IHN0cmluZyBsaXRlcmFscyBmb3IgdHlwZS1zYWZlIGNvZGVzXHJcbiAqICAgdHlwZSBFcnIgPVxyXG4gKiAgICAgJ3Vua25vd24nIHxcclxuICogICAgICdvYmplY3Qtbm90LWZvdW5kJ1xyXG4gKiAgICAgO1xyXG4gKlxyXG4gKiAgIC8vIENsb3N1cmUgZW51bSBmb3IgdHlwZS1zYWZlIGVycm9yIGNvZGVzXHJcbiAqICAgLy8gYXQtZW51bSB7c3RyaW5nfVxyXG4gKiAgIHZhciBFcnIgPSB7XHJcbiAqICAgICBVTktOT1dOOiAndW5rbm93bicsXHJcbiAqICAgICBPQkpFQ1RfTk9UX0ZPVU5EOiAnb2JqZWN0LW5vdC1mb3VuZCcsXHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIGxldCBlcnJvcnM6IE1hcDxFcnIsIHN0cmluZz4gPSB7XHJcbiAqICAgICAnZ2VuZXJpYy1lcnJvcic6IFwiVW5rbm93biBlcnJvclwiLFxyXG4gKiAgICAgJ2ZpbGUtbm90LWZvdW5kJzogXCJDb3VsZCBub3QgZmluZCBmaWxlOiB7JGZpbGV9XCIsXHJcbiAqICAgfTtcclxuICpcclxuICogICAvLyBUeXBlLXNhZmUgZnVuY3Rpb24gLSBtdXN0IHBhc3MgYSB2YWxpZCBlcnJvciBjb2RlIGFzIHBhcmFtLlxyXG4gKiAgIGxldCBlcnJvciA9IG5ldyBFcnJvckZhY3Rvcnk8RXJyPignc2VydmljZScsICdTZXJ2aWNlJywgZXJyb3JzKTtcclxuICpcclxuICogICAuLi5cclxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkdFTkVSSUMpO1xyXG4gKiAgIC4uLlxyXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuRklMRV9OT1RfRk9VTkQsIHsnZmlsZSc6IGZpbGVOYW1lfSk7XHJcbiAqICAgLi4uXHJcbiAqICAgLy8gU2VydmljZTogQ291bGQgbm90IGZpbGUgZmlsZTogZm9vLnR4dCAoc2VydmljZS9maWxlLW5vdC1mb3VuZCkuXHJcbiAqXHJcbiAqICAgY2F0Y2ggKGUpIHtcclxuICogICAgIGFzc2VydChlLm1lc3NhZ2UgPT09IFwiQ291bGQgbm90IGZpbmQgZmlsZTogZm9vLnR4dC5cIik7XHJcbiAqICAgICBpZiAoKGUgYXMgRmlyZWJhc2VFcnJvcik/LmNvZGUgPT09ICdzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kJykge1xyXG4gKiAgICAgICBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCByZWFkIGZpbGU6IFwiICsgZVsnZmlsZSddKTtcclxuICogICAgIH1cclxuICogICB9XHJcbiAqL1xyXG5jb25zdCBFUlJPUl9OQU1FID0gJ0ZpcmViYXNlRXJyb3InO1xyXG4vLyBCYXNlZCBvbiBjb2RlIGZyb206XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0N1c3RvbV9FcnJvcl9UeXBlc1xyXG5jbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIGVycm9yIGNvZGUgZm9yIHRoaXMgZXJyb3IuICovXHJcbiAgICBjb2RlLCBtZXNzYWdlLCBcclxuICAgIC8qKiBDdXN0b20gZGF0YSBmb3IgdGhpcyBlcnJvci4gKi9cclxuICAgIGN1c3RvbURhdGEpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YSA9IGN1c3RvbURhdGE7XHJcbiAgICAgICAgLyoqIFRoZSBjdXN0b20gbmFtZSBmb3IgYWxsIEZpcmViYXNlRXJyb3JzLiAqL1xyXG4gICAgICAgIHRoaXMubmFtZSA9IEVSUk9SX05BTUU7XHJcbiAgICAgICAgLy8gRml4IEZvciBFUzVcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBGaXJlYmFzZUVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXHJcbiAgICAgICAgLy8gT25seSBhdmFpbGFibGUgb24gVjguXHJcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXJyb3JGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UsIHNlcnZpY2VOYW1lLCBlcnJvcnMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcclxuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICAgIH1cclxuICAgIGNyZWF0ZShjb2RlLCAuLi5kYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3VzdG9tRGF0YSA9IGRhdGFbMF0gfHwge307XHJcbiAgICAgICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xyXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5lcnJvcnNbY29kZV07XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRlbXBsYXRlID8gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBjdXN0b21EYXRhKSA6ICdFcnJvcic7XHJcbiAgICAgICAgLy8gU2VydmljZSBOYW1lOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxyXG4gICAgICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gYCR7dGhpcy5zZXJ2aWNlTmFtZX06ICR7bWVzc2FnZX0gKCR7ZnVsbENvZGV9KS5gO1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEZpcmViYXNlRXJyb3IoZnVsbENvZGUsIGZ1bGxNZXNzYWdlLCBjdXN0b21EYXRhKTtcclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKSB7XHJcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShQQVRURVJOLCAoXywga2V5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogYDwke2tleX0/PmA7XHJcbiAgICB9KTtcclxufVxyXG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFdmFsdWF0ZXMgYSBKU09OIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgY29udGFpbmluZyBKU09OLlxyXG4gKiBAcmV0dXJuIHsqfSBUaGUgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgSlNPTi5cclxuICovXHJcbmZ1bmN0aW9uIGpzb25FdmFsKHN0cikge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBKU09OIHJlcHJlc2VudGluZyBhIGphdmFzY3JpcHQgb2JqZWN0LlxyXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YXNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEpTT04gY29udGVudHMgb2YgdGhlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBpbnRvIGNvbnN0aXR1ZW50IHBhcnRzLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIHdpdGggaW52YWxpZCAvIGluY29tcGxldGUgY2xhaW1zIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBsZXQgaGVhZGVyID0ge30sIGNsYWltcyA9IHt9LCBkYXRhID0ge30sIHNpZ25hdHVyZSA9ICcnO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgaGVhZGVyID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzBdKSB8fCAnJyk7XHJcbiAgICAgICAgY2xhaW1zID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJyk7XHJcbiAgICAgICAgc2lnbmF0dXJlID0gcGFydHNbMl07XHJcbiAgICAgICAgZGF0YSA9IGNsYWltc1snZCddIHx8IHt9O1xyXG4gICAgICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGVhZGVyLFxyXG4gICAgICAgIGNsYWltcyxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIHNpZ25hdHVyZVxyXG4gICAgfTtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgdGltZS1iYXNlZCBjbGFpbXMuIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlXHJcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xyXG4gICAgbGV0IHZhbGlkU2luY2UgPSAwLCB2YWxpZFVudGlsID0gMDtcclxuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ25iZicpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdleHAnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSB2YWxpZFNpbmNlICsgODY0MDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICghIW5vdyAmJlxyXG4gICAgICAgICEhdmFsaWRTaW5jZSAmJlxyXG4gICAgICAgICEhdmFsaWRVbnRpbCAmJlxyXG4gICAgICAgIG5vdyA+PSB2YWxpZFNpbmNlICYmXHJcbiAgICAgICAgbm93IDw9IHZhbGlkVW50aWwpO1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCByZXR1cm5zIGl0cyBpc3N1ZWQgYXQgdGltZSBpZiB2YWxpZCwgbnVsbCBvdGhlcndpc2UuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gbnVsbCBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzc3VlZEF0VGltZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xyXG4gICAgICAgIHJldHVybiBjbGFpbXNbJ2lhdCddO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIGZvcm1hdC4gRXhwZWN0cyBhIHZhbGlkIGlzc3VlZC1hdCB0aW1lLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc1ZhbGlkRm9ybWF0ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlKHRva2VuKSwgY2xhaW1zID0gZGVjb2RlZC5jbGFpbXM7XHJcbiAgICByZXR1cm4gISFjbGFpbXMgJiYgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKTtcclxufTtcclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIHJldHVybiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXNbJ2FkbWluJ10gPT09IHRydWU7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwga2V5KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcclxufVxyXG5mdW5jdGlvbiBzYWZlR2V0KG9iaiwga2V5KSB7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBtYXAob2JqLCBmbiwgY29udGV4dE9iaikge1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dE9iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qKlxyXG4gKiBEZWVwIGVxdWFsIHR3byBvYmplY3RzLiBTdXBwb3J0IEFycmF5cyBhbmQgT2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICBmb3IgKGNvbnN0IGsgb2YgYUtleXMpIHtcclxuICAgICAgICBpZiAoIWJLZXlzLmluY2x1ZGVzKGspKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYVByb3AgPSBhW2tdO1xyXG4gICAgICAgIGNvbnN0IGJQcm9wID0gYltrXTtcclxuICAgICAgICBpZiAoaXNPYmplY3QoYVByb3ApICYmIGlzT2JqZWN0KGJQcm9wKSkge1xyXG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhUHJvcCwgYlByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYVByb3AgIT09IGJQcm9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGsgb2YgYktleXMpIHtcclxuICAgICAgICBpZiAoIWFLZXlzLmluY2x1ZGVzKGspKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xyXG4gICAgcmV0dXJuIHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlamVjdHMgaWYgdGhlIGdpdmVuIHByb21pc2UgZG9lc24ndCByZXNvbHZlIGluIHRpbWVJbk1TIG1pbGxpc2Vjb25kcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9taXNlV2l0aFRpbWVvdXQocHJvbWlzZSwgdGltZUluTVMgPSAyMDAwKSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZFByb21pc2UgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4gZGVmZXJyZWRQcm9taXNlLnJlamVjdCgndGltZW91dCEnKSwgdGltZUluTVMpO1xyXG4gICAgcHJvbWlzZS50aGVuKGRlZmVycmVkUHJvbWlzZS5yZXNvbHZlLCBkZWZlcnJlZFByb21pc2UucmVqZWN0KTtcclxuICAgIHJldHVybiBkZWZlcnJlZFByb21pc2UucHJvbWlzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHF1ZXJ5c3RyaW5nLWZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJmFyZz12YWwmYXJnMj12YWwyKSBmcm9tIGFcclxuICogcGFyYW1zIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcclxuICogTm90ZTogWW91IG11c3QgcHJlcGVuZCBpdCB3aXRoID8gd2hlbiBhZGRpbmcgaXQgdG8gYSBVUkwuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeXN0cmluZ1BhcmFtcykge1xyXG4gICAgY29uc3QgcGFyYW1zID0gW107XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeXN0cmluZ1BhcmFtcykpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChhcnJheVZhbCA9PiB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChhcnJheVZhbCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtcy5sZW5ndGggPyAnJicgKyBwYXJhbXMuam9pbignJicpIDogJyc7XHJcbn1cclxuLyoqXHJcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0XHJcbiAqIChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlzdHJpbmdEZWNvZGUocXVlcnlzdHJpbmcpIHtcclxuICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgY29uc3QgdG9rZW5zID0gcXVlcnlzdHJpbmcucmVwbGFjZSgvXlxcPy8sICcnKS5zcGxpdCgnJicpO1xyXG4gICAgdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xyXG4gICAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSB0b2tlbi5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KGtleSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3QgdGhlIHF1ZXJ5IHN0cmluZyBwYXJ0IG9mIGEgVVJMLCBpbmNsdWRpbmcgdGhlIGxlYWRpbmcgcXVlc3Rpb24gbWFyayAoaWYgcHJlc2VudCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0UXVlcnlzdHJpbmcodXJsKSB7XHJcbiAgICBjb25zdCBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcclxuICAgIGlmICghcXVlcnlTdGFydCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGNvbnN0IGZyYWdtZW50U3RhcnQgPSB1cmwuaW5kZXhPZignIycsIHF1ZXJ5U3RhcnQpO1xyXG4gICAgcmV0dXJuIHVybC5zdWJzdHJpbmcocXVlcnlTdGFydCwgZnJhZ21lbnRTdGFydCA+IDAgPyBmcmFnbWVudFN0YXJ0IDogdW5kZWZpbmVkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2guXHJcbiAqIFZhcmlhYmxlIG5hbWVzIGZvbGxvdyB0aGUgbm90YXRpb24gaW4gRklQUyBQVUIgMTgwLTM6XHJcbiAqIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtMy9maXBzMTgwLTNfZmluYWwucGRmLlxyXG4gKlxyXG4gKiBVc2FnZTpcclxuICogICB2YXIgc2hhMSA9IG5ldyBzaGExKCk7XHJcbiAqICAgc2hhMS51cGRhdGUoYnl0ZXMpO1xyXG4gKiAgIHZhciBoYXNoID0gc2hhMS5kaWdlc3QoKTtcclxuICpcclxuICogUGVyZm9ybWFuY2U6XHJcbiAqICAgQ2hyb21lIDIzOiAgIH40MDAgTWJpdC9zXHJcbiAqICAgRmlyZWZveCAxNjogIH4yNTAgTWJpdC9zXHJcbiAqXHJcbiAqL1xyXG4vKipcclxuICogU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBUaGUgcHJvcGVydGllcyBkZWNsYXJlZCBoZXJlIGFyZSBkaXNjdXNzZWQgaW4gdGhlIGFib3ZlIGFsZ29yaXRobSBkb2N1bWVudC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBmaW5hbFxyXG4gKiBAc3RydWN0XHJcbiAqL1xyXG5jbGFzcyBTaGExIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXHJcbiAgICAgICAgICogZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNoYWluXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnVmXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFycmF5IG9mIDgwIGJ5dGVzLCBlYWNoIGEgcGFydCBvZiB0aGUgbWVzc2FnZSB0byBiZSBoYXNoZWQuICBSZWZlcnJlZCB0b1xyXG4gICAgICAgICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5XXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnRhaW5zIGRhdGEgbmVlZGVkIHRvIHBhZCBtZXNzYWdlcyBsZXNzIHRoYW4gNjQgYnl0ZXMuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhZF8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG90YWxfID0gMDtcclxuICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IDUxMiAvIDg7XHJcbiAgICAgICAgdGhpcy5wYWRfWzBdID0gMTI4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5ibG9ja1NpemU7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhZF9baV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmNoYWluX1swXSA9IDB4Njc0NTIzMDE7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMV0gPSAweGVmY2RhYjg5O1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcclxuICAgICAgICB0aGlzLmNoYWluX1szXSA9IDB4MTAzMjU0NzY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bNF0gPSAweGMzZDJlMWYwO1xyXG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcclxuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGNvbXByZXNzIGhlbHBlciBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSBidWYgQmxvY2sgdG8gY29tcHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbXByZXNzXyhidWYsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IFcgPSB0aGlzLldfO1xyXG4gICAgICAgIC8vIGdldCAxNiBiaWcgZW5kaWFuIHdvcmRzXHJcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyh1c2VyKTogW2J1ZyA4MTQwMTIyXSBSZWNlbnQgdmVyc2lvbnMgb2YgU2FmYXJpIGZvciBNYWMgT1MgYW5kIGlPU1xyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGJ1ZyB0aGF0IHR1cm5zIHRoZSBwb3N0LWluY3JlbWVudCArKyBvcGVyYXRvciBpbnRvIHByZS1pbmNyZW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBKSVQgY29tcGlsYXRpb24uICBXZSBoYXZlIGNvZGUgdGhhdCBkZXBlbmRzIGhlYXZpbHkgb24gU0hBLTEgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bmVzcyBhbmQgd2hpY2ggaXMgYWZmZWN0ZWQgYnkgdGhpcyBidWcsIHNvIEkndmUgcmVtb3ZlZCBhbGwgdXNlc1xyXG4gICAgICAgICAgICAgICAgLy8gb2YgcG9zdC1pbmNyZW1lbnQgKysgaW4gd2hpY2ggdGhlIHJlc3VsdCB2YWx1ZSBpcyB1c2VkLiAgV2UgY2FuIHJldmVydFxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaGFuZ2Ugb25jZSB0aGUgU2FmYXJpIGJ1Z1xyXG4gICAgICAgICAgICAgICAgLy8gKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDkwMzYpIGhhcyBiZWVuIGZpeGVkIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBjbGllbnRzIGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgICAgICAgICAgV1tpXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDMpO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgV1tpXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXRdIDw8IDI0KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXQgKyAyXSA8PCA4KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvZmZzZXQgKyAzXTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4cGFuZCB0byA4MCB3b3Jkc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XHJcbiAgICAgICAgICAgIFdbaV0gPSAoKHQgPDwgMSkgfCAodCA+Pj4gMzEpKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhID0gdGhpcy5jaGFpbl9bMF07XHJcbiAgICAgICAgbGV0IGIgPSB0aGlzLmNoYWluX1sxXTtcclxuICAgICAgICBsZXQgYyA9IHRoaXMuY2hhaW5fWzJdO1xyXG4gICAgICAgIGxldCBkID0gdGhpcy5jaGFpbl9bM107XHJcbiAgICAgICAgbGV0IGUgPSB0aGlzLmNoYWluX1s0XTtcclxuICAgICAgICBsZXQgZiwgaztcclxuICAgICAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgNDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NWE4Mjc5OTk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDZlZDllYmExO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCA2MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKGQgJiAoYiB8IGMpKTtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4Y2E2MmMxZDY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdCA9ICgoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgayArIFdbaV0pICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgZSA9IGQ7XHJcbiAgICAgICAgICAgIGQgPSBjO1xyXG4gICAgICAgICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgICAgICBiID0gYTtcclxuICAgICAgICAgICAgYSA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gKHRoaXMuY2hhaW5fWzBdICsgYSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gKHRoaXMuY2hhaW5fWzFdICsgYikgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gKHRoaXMuY2hhaW5fWzJdICsgYykgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gKHRoaXMuY2hhaW5fWzNdICsgZCkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gKHRoaXMuY2hhaW5fWzRdICsgZSkgJiAweGZmZmZmZmZmO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGJ5dGVzLCBsZW5ndGgpIHtcclxuICAgICAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xyXG4gICAgICAgIGlmIChieXRlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoTWludXNCbG9jayA9IGxlbmd0aCAtIHRoaXMuYmxvY2tTaXplO1xyXG4gICAgICAgIGxldCBuID0gMDtcclxuICAgICAgICAvLyBVc2luZyBsb2NhbCBpbnN0ZWFkIG9mIG1lbWJlciB2YXJpYWJsZXMgZ2l2ZXMgfjUlIHNwZWVkdXAgb24gRmlyZWZveCAxNi5cclxuICAgICAgICBjb25zdCBidWYgPSB0aGlzLmJ1Zl87XHJcbiAgICAgICAgbGV0IGluYnVmID0gdGhpcy5pbmJ1Zl87XHJcbiAgICAgICAgLy8gVGhlIG91dGVyIHdoaWxlIGxvb3Agc2hvdWxkIGV4ZWN1dGUgYXQgbW9zdCB0d2ljZS5cclxuICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGhhdmUgbm8gZGF0YSBpbiB0aGUgYmxvY2sgdG8gdG9wIHVwLCB3ZSBjYW4gZGlyZWN0bHkgcHJvY2VzcyB0aGVcclxuICAgICAgICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcclxuICAgICAgICAgICAgLy8gc3BlZWR1cCBvbiBDaHJvbWUgMjMgYW5kIH4xNSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LCBidXQgcmVxdWlyZXMgdGhhdFxyXG4gICAgICAgICAgICAvLyB0aGUgZGF0YSBpcyBwcm92aWRlZCBpbiBsYXJnZSBjaHVua3MgKG9yIGluIG11bHRpcGxlcyBvZiA2NCBieXRlcykuXHJcbiAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPD0gbGVuZ3RoTWludXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ5dGVzLCBuKTtcclxuICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuYmxvY2tTaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlcy5jaGFyQ29kZUF0KG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XHJcbiAgICAgICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xyXG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XHJcbiAgICAgICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluYnVmXyA9IGluYnVmO1xyXG4gICAgICAgIHRoaXMudG90YWxfICs9IGxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cclxuICAgIGRpZ2VzdCgpIHtcclxuICAgICAgICBjb25zdCBkaWdlc3QgPSBbXTtcclxuICAgICAgICBsZXQgdG90YWxCaXRzID0gdGhpcy50b3RhbF8gKiA4O1xyXG4gICAgICAgIC8vIEFkZCBwYWQgMHg4MCAweDAwKi5cclxuICAgICAgICBpZiAodGhpcy5pbmJ1Zl8gPCA1Nikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIDU2IC0gdGhpcy5pbmJ1Zl8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCB0aGlzLmJsb2NrU2l6ZSAtICh0aGlzLmluYnVmXyAtIDU2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCAjIGJpdHMuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYmxvY2tTaXplIC0gMTsgaSA+PSA1NjsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmX1tpXSA9IHRvdGFsQml0cyAmIDI1NTtcclxuICAgICAgICAgICAgdG90YWxCaXRzIC89IDI1NjsgLy8gRG9uJ3QgdXNlIGJpdC1zaGlmdGluZyBoZXJlIVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXByZXNzXyh0aGlzLmJ1Zl8pO1xyXG4gICAgICAgIGxldCBuID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XHJcbiAgICAgICAgICAgICAgICBkaWdlc3Rbbl0gPSAodGhpcy5jaGFpbl9baV0gPj4gaikgJiAyNTU7XHJcbiAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpZ2VzdDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogSGVscGVyIHRvIG1ha2UgYSBTdWJzY3JpYmUgZnVuY3Rpb24gKGp1c3QgbGlrZSBQcm9taXNlIGhlbHBzIG1ha2UgYVxyXG4gKiBUaGVuYWJsZSkuXHJcbiAqXHJcbiAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxyXG4gKiAgICAgYXMgYSBwcm94eS5cclxuICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XHJcbiAgICBjb25zdCBwcm94eSA9IG5ldyBPYnNlcnZlclByb3h5KGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKTtcclxuICAgIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudCBmYW4tb3V0IGZvciBhbnkgbnVtYmVyIG9mIE9ic2VydmVycyBhdHRhY2hlZCB2aWEgYSBzdWJzY3JpYmVcclxuICogZnVuY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBPYnNlcnZlclByb3h5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXHJcbiAgICAgKiAgICAgYXMgYSBwcm94eS5cclxuICAgICAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVzID0gW107XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50ID0gMDtcclxuICAgICAgICAvLyBNaWNyby10YXNrIHNjaGVkdWxpbmcgYnkgY2FsbGluZyB0YXNrLnRoZW4oKS5cclxuICAgICAgICB0aGlzLnRhc2sgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IG9uTm9PYnNlcnZlcnM7XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgZXhlY3V0b3IgYXN5bmNocm9ub3VzbHkgc28gc3Vic2NyaWJlcnMgdGhhdCBhcmUgY2FsbGVkXHJcbiAgICAgICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxyXG4gICAgICAgIC8vIGNhbiBzdGlsbCByZWNlaXZlIHRoZSB2ZXJ5IGZpcnN0IHZhbHVlIGdlbmVyYXRlZCBpbiB0aGUgZXhlY3V0b3IuXHJcbiAgICAgICAgdGhpcy50YXNrXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgZXhlY3V0b3IodGhpcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbmV4dCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsb3NlKGVycm9yKTtcclxuICAgIH1cclxuICAgIGNvbXBsZXRlKCkge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIGFuIE9ic2VydmVyIHRvIHRoZSBmYW4tb3V0IGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogLSBXZSByZXF1aXJlIHRoYXQgbm8gZXZlbnQgaXMgc2VudCB0byBhIHN1YnNjcmliZXIgc3ljaHJvbm91c2x5IHRvIHRoZWlyXHJcbiAgICAgKiAgIGNhbGwgdG8gc3Vic2NyaWJlKCkuXHJcbiAgICAgKi9cclxuICAgIHN1YnNjcmliZShuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XHJcbiAgICAgICAgbGV0IG9ic2VydmVyO1xyXG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGVycm9yID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFzc2VtYmxlIGFuIE9ic2VydmVyIG9iamVjdCB3aGVuIHBhc3NlZCBhcyBjYWxsYmFjayBmdW5jdGlvbnMuXHJcbiAgICAgICAgaWYgKGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyLCBbXHJcbiAgICAgICAgICAgICduZXh0JyxcclxuICAgICAgICAgICAgJ2Vycm9yJyxcclxuICAgICAgICAgICAgJ2NvbXBsZXRlJ1xyXG4gICAgICAgIF0pKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IHtcclxuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRPck9ic2VydmVyLFxyXG4gICAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdW5zdWIgPSB0aGlzLnVuc3Vic2NyaWJlT25lLmJpbmQodGhpcywgdGhpcy5vYnNlcnZlcnMubGVuZ3RoKTtcclxuICAgICAgICAvLyBBdHRlbXB0IHRvIHN1YnNjcmliZSB0byBhIHRlcm1pbmF0ZWQgT2JzZXJ2YWJsZSAtIHdlXHJcbiAgICAgICAgLy8ganVzdCByZXNwb25kIHRvIHRoZSBPYnNlcnZlciB3aXRoIHRoZSBmaW5hbCBlcnJvciBvciBjb21wbGV0ZVxyXG4gICAgICAgIC8vIGV2ZW50LlxyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcih0aGlzLmZpbmFsRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIHJldHVybiB1bnN1YjtcclxuICAgIH1cclxuICAgIC8vIFVuc3Vic2NyaWJlIGlzIHN5bmNocm9ub3VzIC0gd2UgZ3VhcmFudGVlIHRoYXQgbm8gZXZlbnRzIGFyZSBzZW50IHRvXHJcbiAgICAvLyBhbnkgdW5zdWJzY3JpYmVkIE9ic2VydmVyLlxyXG4gICAgdW5zdWJzY3JpYmVPbmUoaSkge1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVycyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub2JzZXJ2ZXJzW2ldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbaV07XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50IC09IDE7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJDb3VudCA9PT0gMCAmJiB0aGlzLm9uTm9PYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnModGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yRWFjaE9ic2VydmVyKGZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgIC8vIEFscmVhZHkgY2xvc2VkIGJ5IHByZXZpb3VzIGV2ZW50Li4uLmp1c3QgZWF0IHRoZSBhZGRpdGlvbmFsIHZhbHVlcy5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaW5jZSBzZW5kT25lIGNhbGxzIGFzeW5jaHJvbm91c2x5IC0gdGhlcmUgaXMgbm8gY2hhbmNlIHRoYXRcclxuICAgICAgICAvLyB0aGlzLm9ic2VydmVycyB3aWxsIGJlY29tZSB1bmRlZmluZWQuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbmUoaSwgZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENhbGwgdGhlIE9ic2VydmVyIHZpYSBvbmUgb2YgaXQncyBjYWxsYmFjayBmdW5jdGlvbi4gV2UgYXJlIGNhcmVmdWwgdG9cclxuICAgIC8vIGNvbmZpcm0gdGhhdCB0aGUgb2JzZXJ2ZSBoYXMgbm90IGJlZW4gdW5zdWJzY3JpYmVkIHNpbmNlIHRoaXMgYXN5bmNocm9ub3VzXHJcbiAgICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXHJcbiAgICBzZW5kT25lKGksIGZuKSB7XHJcbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9ic2VydmVyc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKHRoaXMub2JzZXJ2ZXJzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGV4Y2VwdGlvbnMgcmFpc2VkIGluIE9ic2VydmVycyBvciBtaXNzaW5nIG1ldGhvZHMgb2YgYW5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPYnNlcnZlci5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgdG8gY29uc29sZS4gYi8zMTQwNDgwNlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2xvc2UoZXJyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmFsRXJyb3IgPSBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb3h5IGlzIG5vIGxvbmdlciBuZWVkZWQgLSBnYXJiYWdlIGNvbGxlY3QgcmVmZXJlbmNlc1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIFR1cm4gc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBvbmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5mdW5jdGlvbiBhc3luYyhmbiwgb25FcnJvcikge1xyXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRydWUpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgZm4oLi4uYXJncyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgcGFzc2VkIGluIGltcGxlbWVudHMgYW55IG9mIHRoZSBuYW1lZCBtZXRob2RzLlxyXG4gKi9cclxuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xyXG4gICAgICAgIGlmIChtZXRob2QgaW4gb2JqICYmIHR5cGVvZiBvYmpbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gbm9vcCgpIHtcclxuICAgIC8vIGRvIG5vdGhpbmdcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXJndW1lbnRzIGFyZSBwcm92aWRlZCBmb3IgYSBwdWJsaWMgZnVuY3Rpb24uXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiBpdCBmYWlscy5cclxuICpcclxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxyXG4gKiBAcGFyYW0gbWluQ291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcclxuICogQHBhcmFtIG1heENvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudCB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcclxuICogQHBhcmFtIGFyZ0NvdW50IFRoZSBhY3R1YWwgbnVtYmVyIG9mIGFyZ3VtZW50cyBwcm92aWRlZC5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlQXJnQ291bnQgPSBmdW5jdGlvbiAoZm5OYW1lLCBtaW5Db3VudCwgbWF4Q291bnQsIGFyZ0NvdW50KSB7XHJcbiAgICBsZXQgYXJnRXJyb3I7XHJcbiAgICBpZiAoYXJnQ291bnQgPCBtaW5Db3VudCkge1xyXG4gICAgICAgIGFyZ0Vycm9yID0gJ2F0IGxlYXN0ICcgKyBtaW5Db3VudDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFyZ0NvdW50ID4gbWF4Q291bnQpIHtcclxuICAgICAgICBhcmdFcnJvciA9IG1heENvdW50ID09PSAwID8gJ25vbmUnIDogJ25vIG1vcmUgdGhhbiAnICsgbWF4Q291bnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJnRXJyb3IpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGZuTmFtZSArXHJcbiAgICAgICAgICAgICcgZmFpbGVkOiBXYXMgY2FsbGVkIHdpdGggJyArXHJcbiAgICAgICAgICAgIGFyZ0NvdW50ICtcclxuICAgICAgICAgICAgKGFyZ0NvdW50ID09PSAxID8gJyBhcmd1bWVudC4nIDogJyBhcmd1bWVudHMuJykgK1xyXG4gICAgICAgICAgICAnIEV4cGVjdHMgJyArXHJcbiAgICAgICAgICAgIGFyZ0Vycm9yICtcclxuICAgICAgICAgICAgJy4nO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBzdHJpbmcgdG8gcHJlZml4IGFuIGVycm9yIG1lc3NhZ2UgYWJvdXQgZmFpbGVkIGFyZ3VtZW50IHZhbGlkYXRpb25cclxuICpcclxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxyXG4gKiBAcGFyYW0gYXJnTmFtZSBUaGUgbmFtZSBvZiB0aGUgYXJndW1lbnRcclxuICogQHJldHVybiBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgdGhyb3duIGZvciB2YWxpZGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmdOYW1lKSB7XHJcbiAgICByZXR1cm4gYCR7Zm5OYW1lfSBmYWlsZWQ6ICR7YXJnTmFtZX0gYXJndW1lbnQgYDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIGZuTmFtZVxyXG4gKiBAcGFyYW0gYXJndW1lbnROdW1iZXJcclxuICogQHBhcmFtIG5hbWVzcGFjZVxyXG4gKiBAcGFyYW0gb3B0aW9uYWxcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZXNwYWNlKGZuTmFtZSwgbmFtZXNwYWNlLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFuYW1lc3BhY2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAnbmFtZXNwYWNlJykgKyAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIG5hbWVzcGFjZS4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKGZuTmFtZSwgYXJndW1lbnROYW1lLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuY2FsbGJhY2ssIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgKyAnbXVzdCBiZSBhIHZhbGlkIGZ1bmN0aW9uLicpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dE9iamVjdChmbk5hbWUsIGFyZ3VtZW50TmFtZSwgY29udGV4dCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgKyAnbXVzdCBiZSBhIHZhbGlkIGNvbnRleHQgb2JqZWN0LicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIENvZGUgb3JpZ2luYWxseSBjYW1lIGZyb20gZ29vZy5jcnlwdC5zdHJpbmdUb1V0ZjhCeXRlQXJyYXksIGJ1dCBmb3Igc29tZSByZWFzb24gdGhleVxyXG4vLyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkICdcXHJcXG4nIHdpdGggJ1xcbicsIGFuZCB0aGV5IGRpZG4ndCBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLFxyXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXHJcbi8vIE5vdGUgdGhhdCBub3QgYWxsIFVuaWNvZGUgY2hhcmFjdGVycyBhcHBlYXIgYXMgc2luZ2xlIGNoYXJhY3RlcnMgaW4gSmF2YVNjcmlwdCBzdHJpbmdzLlxyXG4vLyBmcm9tQ2hhckNvZGUgcmV0dXJucyB0aGUgVVRGLTE2IGVuY29kaW5nIG9mIGEgY2hhcmFjdGVyIC0gc28gc29tZSBVbmljb2RlIGNoYXJhY3RlcnNcclxuLy8gdXNlIDIgY2hhcmFjdGVycyBpbiBKYXZhc2NyaXB0LiAgQWxsIDQtYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzIGJlZ2luIHdpdGggYSBmaXJzdFxyXG4vLyBjaGFyYWN0ZXIgaW4gdGhlIHJhbmdlIDB4RDgwMCAtIDB4REJGRiAodGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHNvLWNhbGxlZCBzdXJyb2dhdGVcclxuLy8gcGFpcikuXHJcbi8vIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMS4zXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAvLyBJcyB0aGlzIHRoZSBsZWFkIHN1cnJvZ2F0ZSBpbiBhIHN1cnJvZ2F0ZSBwYWlyP1xyXG4gICAgICAgIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xyXG4gICAgICAgICAgICBjb25zdCBoaWdoID0gYyAtIDB4ZDgwMDsgLy8gdGhlIGhpZ2ggMTAgYml0cy5cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBhc3NlcnQoaSA8IHN0ci5sZW5ndGgsICdTdXJyb2dhdGUgcGFpciBtaXNzaW5nIHRyYWlsIHN1cnJvZ2F0ZS4nKTtcclxuICAgICAgICAgICAgY29uc3QgbG93ID0gc3RyLmNoYXJDb2RlQXQoaSkgLSAweGRjMDA7IC8vIHRoZSBsb3cgMTAgYml0cy5cclxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoaGlnaCA8PCAxMCkgKyBsb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDY1NTM2KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgbGVuZ3RoIHdpdGhvdXQgYWN0dWFsbHkgY29udmVydGluZzsgdXNlZnVsIGZvciBkb2luZyBjaGVhcGVyIHZhbGlkYXRpb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3Qgc3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgbGV0IHAgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgcCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBwICs9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XHJcbiAgICAgICAgICAgIC8vIExlYWQgc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuICBUaGUgcGFpciB0b2dldGhlciB3aWxsIHRha2UgNCBieXRlcyB0byByZXByZXNlbnQuXHJcbiAgICAgICAgICAgIHAgKz0gNDtcclxuICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHAgKz0gMztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcDtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTE3NTIzXHJcbiAqIEdlbmVyYXRlcyBhIG5ldyB1dWlkLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCB1dWlkdjQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcclxuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcclxuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XHJcbiAgICB9KTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGV4cG9uZW50aWFsbHkgaW5jcmVhc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0lOVEVSVkFMX01JTExJUyA9IDEwMDA7XHJcbi8qKlxyXG4gKiBUaGUgZmFjdG9yIHRvIGJhY2tvZmYgYnkuXHJcbiAqIFNob3VsZCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAyO1xyXG4vKipcclxuICogVGhlIG1heGltdW0gbWlsbGlzZWNvbmRzIHRvIGluY3JlYXNlIHRvLlxyXG4gKlxyXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAqL1xyXG5jb25zdCBNQVhfVkFMVUVfTUlMTElTID0gNCAqIDYwICogNjAgKiAxMDAwOyAvLyBGb3VyIGhvdXJzLCBsaWtlIGlPUyBhbmQgQW5kcm9pZC5cclxuLyoqXHJcbiAqIFRoZSBwZXJjZW50YWdlIG9mIGJhY2tvZmYgdGltZSB0byByYW5kb21pemUgYnkuXHJcbiAqIFNlZVxyXG4gKiBodHRwOi8vZ28vc2FmZS1jbGllbnQtYmVoYXZpb3Ijc3RlcC0xLWRldGVybWluZS10aGUtYXBwcm9wcmlhdGUtcmV0cnktaW50ZXJ2YWwtdG8taGFuZGxlLXNwaWtlLXRyYWZmaWNcclxuICogZm9yIGNvbnRleHQuXHJcbiAqXHJcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcclxuICovXHJcbmNvbnN0IFJBTkRPTV9GQUNUT1IgPSAwLjU7XHJcbi8qKlxyXG4gKiBCYXNlZCBvbiB0aGUgYmFja29mZiBtZXRob2QgZnJvbVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9leHBvbmVudGlhbGJhY2tvZmYuanMuXHJcbiAqIEV4dHJhY3RlZCBoZXJlIHNvIHdlIGRvbid0IG5lZWQgdG8gcGFzcyBtZXRhZGF0YSBhbmQgYSBzdGF0ZWZ1bCBFeHBvbmVudGlhbEJhY2tvZmYgb2JqZWN0IGFyb3VuZC5cclxuICovXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoYmFja29mZkNvdW50LCBpbnRlcnZhbE1pbGxpcyA9IERFRkFVTFRfSU5URVJWQUxfTUlMTElTLCBiYWNrb2ZmRmFjdG9yID0gREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUikge1xyXG4gICAgLy8gQ2FsY3VsYXRlcyBhbiBleHBvbmVudGlhbGx5IGluY3JlYXNpbmcgdmFsdWUuXHJcbiAgICAvLyBEZXZpYXRpb246IGNhbGN1bGF0ZXMgdmFsdWUgZnJvbSBjb3VudCBhbmQgYSBjb25zdGFudCBpbnRlcnZhbCwgc28gd2Ugb25seSBuZWVkIHRvIHNhdmUgdmFsdWVcclxuICAgIC8vIGFuZCBjb3VudCB0byByZXN0b3JlIHN0YXRlLlxyXG4gICAgY29uc3QgY3VyckJhc2VWYWx1ZSA9IGludGVydmFsTWlsbGlzICogTWF0aC5wb3coYmFja29mZkZhY3RvciwgYmFja29mZkNvdW50KTtcclxuICAgIC8vIEEgcmFuZG9tIFwiZnV6elwiIHRvIGF2b2lkIHdhdmVzIG9mIHJldHJpZXMuXHJcbiAgICAvLyBEZXZpYXRpb246IHJhbmRvbUZhY3RvciBpcyByZXF1aXJlZC5cclxuICAgIGNvbnN0IHJhbmRvbVdhaXQgPSBNYXRoLnJvdW5kKFxyXG4gICAgLy8gQSBmcmFjdGlvbiBvZiB0aGUgYmFja29mZiB2YWx1ZSB0byBhZGQvc3VidHJhY3QuXHJcbiAgICAvLyBEZXZpYXRpb246IGNoYW5nZXMgbXVsdGlwbGljYXRpb24gb3JkZXIgdG8gaW1wcm92ZSByZWFkYWJpbGl0eS5cclxuICAgIFJBTkRPTV9GQUNUT1IgKlxyXG4gICAgICAgIGN1cnJCYXNlVmFsdWUgKlxyXG4gICAgICAgIC8vIEEgcmFuZG9tIGZsb2F0IChyb3VuZGVkIHRvIGludCBieSBNYXRoLnJvdW5kIGFib3ZlKSBpbiB0aGUgcmFuZ2UgWy0xLCAxXS4gRGV0ZXJtaW5lc1xyXG4gICAgICAgIC8vIGlmIHdlIGFkZCBvciBzdWJ0cmFjdC5cclxuICAgICAgICAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKlxyXG4gICAgICAgIDIpO1xyXG4gICAgLy8gTGltaXRzIGJhY2tvZmYgdG8gbWF4IHRvIGF2b2lkIGVmZmVjdGl2ZWx5IHBlcm1hbmVudCBiYWNrb2ZmLlxyXG4gICAgcmV0dXJuIE1hdGgubWluKE1BWF9WQUxVRV9NSUxMSVMsIGN1cnJCYXNlVmFsdWUgKyByYW5kb21XYWl0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdmlkZSBFbmdsaXNoIG9yZGluYWwgbGV0dGVycyBhZnRlciBhIG51bWJlclxyXG4gKi9cclxuZnVuY3Rpb24gb3JkaW5hbChpKSB7XHJcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpKSkge1xyXG4gICAgICAgIHJldHVybiBgJHtpfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaSArIGluZGljYXRvcihpKTtcclxufVxyXG5mdW5jdGlvbiBpbmRpY2F0b3IoaSkge1xyXG4gICAgaSA9IE1hdGguYWJzKGkpO1xyXG4gICAgY29uc3QgY2VudCA9IGkgJSAxMDA7XHJcbiAgICBpZiAoY2VudCA+PSAxMCAmJiBjZW50IDw9IDIwKSB7XHJcbiAgICAgICAgcmV0dXJuICd0aCc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWMgPSBpICUgMTA7XHJcbiAgICBpZiAoZGVjID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuICdzdCc7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVjID09PSAyKSB7XHJcbiAgICAgICAgcmV0dXJuICduZCc7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVjID09PSAzKSB7XHJcbiAgICAgICAgcmV0dXJuICdyZCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ3RoJztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNb2R1bGFySW5zdGFuY2Uoc2VydmljZSkge1xyXG4gICAgaWYgKHNlcnZpY2UgJiYgc2VydmljZS5fZGVsZWdhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2VydmljZS5fZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VydmljZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBPdmVycmlkaW5nIHRoZSBjb25zdGFudCAod2Ugc2hvdWxkIGJlIHRoZSBvbmx5IG9uZXMgZG9pbmcgdGhpcylcclxuQ09OU1RBTlRTLk5PREVfQ0xJRU5UID0gdHJ1ZTtcblxuZXhwb3J0IHsgQ09OU1RBTlRTLCBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciwgRGVmZXJyZWQsIEVycm9yRmFjdG9yeSwgRmlyZWJhc2VFcnJvciwgTUFYX1ZBTFVFX01JTExJUywgUkFORE9NX0ZBQ1RPUiwgU2hhMSwgYXJlQ29va2llc0VuYWJsZWQsIGFzc2VydCwgYXNzZXJ0aW9uRXJyb3IsIGFzeW5jLCBiYXNlNjQsIGJhc2U2NERlY29kZSwgYmFzZTY0RW5jb2RlLCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZywgY2FsY3VsYXRlQmFja29mZk1pbGxpcywgY29udGFpbnMsIGNyZWF0ZU1vY2tVc2VyVG9rZW4sIGNyZWF0ZVN1YnNjcmliZSwgZGVjb2RlLCBkZWVwQ29weSwgZGVlcEVxdWFsLCBkZWVwRXh0ZW5kLCBlcnJvclByZWZpeCwgZXh0cmFjdFF1ZXJ5c3RyaW5nLCBnZXREZWZhdWx0QXBwQ29uZmlnLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0LCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQsIGdldERlZmF1bHRzLCBnZXRFeHBlcmltZW50YWxTZXR0aW5nLCBnZXRHbG9iYWwsIGdldE1vZHVsYXJJbnN0YW5jZSwgZ2V0VUEsIGlzQWRtaW4sIGlzQnJvd3NlciwgaXNCcm93c2VyRXh0ZW5zaW9uLCBpc0VsZWN0cm9uLCBpc0VtcHR5LCBpc0lFLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgaXNNb2JpbGVDb3Jkb3ZhLCBpc05vZGUsIGlzTm9kZVNkaywgaXNSZWFjdE5hdGl2ZSwgaXNTYWZhcmksIGlzVVdQLCBpc1ZhbGlkRm9ybWF0LCBpc1ZhbGlkVGltZXN0YW1wLCBpc1dlYldvcmtlciwgaXNzdWVkQXRUaW1lLCBqc29uRXZhbCwgbWFwLCBvcmRpbmFsLCBwcm9taXNlV2l0aFRpbWVvdXQsIHF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSwgc2FmZUdldCwgc3RyaW5nTGVuZ3RoLCBzdHJpbmdUb0J5dGVBcnJheSwgc3RyaW5naWZ5LCB1dWlkdjQsIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNPTlNUQU5UUyIsIk5PREVfQ0xJRU5UIiwiTk9ERV9BRE1JTiIsIlNES19WRVJTSU9OIiwiYXNzZXJ0IiwiYXNzZXJ0aW9uIiwibWVzc2FnZSIsImFzc2VydGlvbkVycm9yIiwiRXJyb3IiLCJzdHJpbmdUb0J5dGVBcnJheSQxIiwic3RyIiwib3V0IiwicCIsImkiLCJsZW5ndGgiLCJjIiwiY2hhckNvZGVBdCIsImJ5dGVBcnJheVRvU3RyaW5nIiwiYnl0ZXMiLCJwb3MiLCJjMSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImMyIiwiYzMiLCJjNCIsInUiLCJqb2luIiwiYmFzZTY0IiwiYnl0ZVRvQ2hhck1hcF8iLCJjaGFyVG9CeXRlTWFwXyIsImJ5dGVUb0NoYXJNYXBXZWJTYWZlXyIsImNoYXJUb0J5dGVNYXBXZWJTYWZlXyIsIkVOQ09ERURfVkFMU19CQVNFIiwiRU5DT0RFRF9WQUxTIiwiRU5DT0RFRF9WQUxTX1dFQlNBRkUiLCJIQVNfTkFUSVZFX1NVUFBPUlQiLCJhdG9iIiwiZW5jb2RlQnl0ZUFycmF5IiwiaW5wdXQiLCJ3ZWJTYWZlIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5pdF8iLCJieXRlVG9DaGFyTWFwIiwib3V0cHV0IiwiYnl0ZTEiLCJoYXZlQnl0ZTIiLCJieXRlMiIsImhhdmVCeXRlMyIsImJ5dGUzIiwib3V0Qnl0ZTEiLCJvdXRCeXRlMiIsIm91dEJ5dGUzIiwib3V0Qnl0ZTQiLCJwdXNoIiwiZW5jb2RlU3RyaW5nIiwiYnRvYSIsImRlY29kZVN0cmluZyIsImRlY29kZVN0cmluZ1RvQnl0ZUFycmF5IiwiY2hhclRvQnl0ZU1hcCIsImNoYXJBdCIsImhhdmVCeXRlNCIsImJ5dGU0IiwiRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsIm5hbWUiLCJiYXNlNjRFbmNvZGUiLCJ1dGY4Qnl0ZXMiLCJiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyIsInJlcGxhY2UiLCJiYXNlNjREZWNvZGUiLCJlIiwiY29uc29sZSIsImVycm9yIiwiZGVlcENvcHkiLCJ2YWx1ZSIsImRlZXBFeHRlbmQiLCJ1bmRlZmluZWQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJPYmplY3QiLCJEYXRlIiwiZGF0ZVZhbHVlIiwiZ2V0VGltZSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImlzVmFsaWRLZXkiLCJrZXkiLCJnZXRHbG9iYWwiLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwiZ2V0RGVmYXVsdHNGcm9tR2xvYmFsIiwiX19GSVJFQkFTRV9ERUZBVUxUU19fIiwiZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUiLCJwcm9jZXNzIiwiZW52IiwiZGVmYXVsdHNKc29uU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiZ2V0RGVmYXVsdHNGcm9tQ29va2llIiwiZG9jdW1lbnQiLCJtYXRjaCIsImNvb2tpZSIsImRlY29kZWQiLCJnZXREZWZhdWx0cyIsImluZm8iLCJnZXREZWZhdWx0RW11bGF0b3JIb3N0IiwicHJvZHVjdE5hbWUiLCJfYSIsIl9iIiwiZW11bGF0b3JIb3N0cyIsImdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCIsImhvc3QiLCJzZXBhcmF0b3JJbmRleCIsImxhc3RJbmRleE9mIiwicG9ydCIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiZ2V0RGVmYXVsdEFwcENvbmZpZyIsImNvbmZpZyIsImdldEV4cGVyaW1lbnRhbFNldHRpbmciLCJEZWZlcnJlZCIsInJlamVjdCIsInJlc29sdmUiLCJwcm9taXNlIiwiUHJvbWlzZSIsIndyYXBDYWxsYmFjayIsImNhbGxiYWNrIiwiY2F0Y2giLCJjcmVhdGVNb2NrVXNlclRva2VuIiwidG9rZW4iLCJwcm9qZWN0SWQiLCJ1aWQiLCJoZWFkZXIiLCJhbGciLCJ0eXBlIiwicHJvamVjdCIsImlhdCIsInN1YiIsInVzZXJfaWQiLCJwYXlsb2FkIiwiYXNzaWduIiwiaXNzIiwiYXVkIiwiZXhwIiwiYXV0aF90aW1lIiwiZmlyZWJhc2UiLCJzaWduX2luX3Byb3ZpZGVyIiwiaWRlbnRpdGllcyIsInNpZ25hdHVyZSIsInN0cmluZ2lmeSIsImdldFVBIiwibmF2aWdhdG9yIiwiaXNNb2JpbGVDb3Jkb3ZhIiwidGVzdCIsImlzTm9kZSIsImZvcmNlRW52aXJvbm1lbnQiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc0Jyb3dzZXIiLCJpc1dlYldvcmtlciIsIldvcmtlckdsb2JhbFNjb3BlIiwiaXNCcm93c2VyRXh0ZW5zaW9uIiwicnVudGltZSIsImNocm9tZSIsImJyb3dzZXIiLCJpZCIsImlzUmVhY3ROYXRpdmUiLCJpc0VsZWN0cm9uIiwiaW5kZXhPZiIsImlzSUUiLCJ1YSIsImlzVVdQIiwiaXNOb2RlU2RrIiwiaXNTYWZhcmkiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsImlzSW5kZXhlZERCQXZhaWxhYmxlIiwiaW5kZXhlZERCIiwidmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSIsInByZUV4aXN0IiwiREJfQ0hFQ0tfTkFNRSIsInJlcXVlc3QiLCJvcGVuIiwib25zdWNjZXNzIiwicmVzdWx0IiwiY2xvc2UiLCJkZWxldGVEYXRhYmFzZSIsIm9udXBncmFkZW5lZWRlZCIsIm9uZXJyb3IiLCJhcmVDb29raWVzRW5hYmxlZCIsImNvb2tpZUVuYWJsZWQiLCJFUlJPUl9OQU1FIiwiRmlyZWJhc2VFcnJvciIsImNvZGUiLCJjdXN0b21EYXRhIiwic2V0UHJvdG90eXBlT2YiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIkVycm9yRmFjdG9yeSIsImNyZWF0ZSIsInNlcnZpY2UiLCJzZXJ2aWNlTmFtZSIsImVycm9ycyIsImRhdGEiLCJmdWxsQ29kZSIsInRlbXBsYXRlIiwicmVwbGFjZVRlbXBsYXRlIiwiZnVsbE1lc3NhZ2UiLCJQQVRURVJOIiwiXyIsImpzb25FdmFsIiwiZGVjb2RlIiwiY2xhaW1zIiwicGFydHMiLCJzcGxpdCIsImlzVmFsaWRUaW1lc3RhbXAiLCJub3ciLCJNYXRoIiwiZmxvb3IiLCJ2YWxpZFNpbmNlIiwidmFsaWRVbnRpbCIsImlzc3VlZEF0VGltZSIsImlzVmFsaWRGb3JtYXQiLCJpc0FkbWluIiwiY29udGFpbnMiLCJvYmoiLCJzYWZlR2V0IiwiaXNFbXB0eSIsIm1hcCIsImZuIiwiY29udGV4dE9iaiIsInJlcyIsImRlZXBFcXVhbCIsImEiLCJiIiwiYUtleXMiLCJrZXlzIiwiYktleXMiLCJrIiwiYVByb3AiLCJiUHJvcCIsImlzT2JqZWN0IiwidGhpbmciLCJwcm9taXNlV2l0aFRpbWVvdXQiLCJ0aW1lSW5NUyIsImRlZmVycmVkUHJvbWlzZSIsInNldFRpbWVvdXQiLCJ0aGVuIiwicXVlcnlzdHJpbmciLCJxdWVyeXN0cmluZ1BhcmFtcyIsInBhcmFtcyIsImVudHJpZXMiLCJmb3JFYWNoIiwiYXJyYXlWYWwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxdWVyeXN0cmluZ0RlY29kZSIsInRva2VucyIsImRlY29kZVVSSUNvbXBvbmVudCIsImV4dHJhY3RRdWVyeXN0cmluZyIsInVybCIsInF1ZXJ5U3RhcnQiLCJmcmFnbWVudFN0YXJ0IiwiU2hhMSIsImNoYWluXyIsImJ1Zl8iLCJXXyIsInBhZF8iLCJpbmJ1Zl8iLCJ0b3RhbF8iLCJibG9ja1NpemUiLCJyZXNldCIsImNvbXByZXNzXyIsImJ1ZiIsIm9mZnNldCIsIlciLCJ0IiwiZCIsImYiLCJ1cGRhdGUiLCJsZW5ndGhNaW51c0Jsb2NrIiwibiIsImluYnVmIiwiZGlnZXN0IiwidG90YWxCaXRzIiwiaiIsImNyZWF0ZVN1YnNjcmliZSIsImV4ZWN1dG9yIiwib25Ob09ic2VydmVycyIsInByb3h5IiwiT2JzZXJ2ZXJQcm94eSIsInN1YnNjcmliZSIsImJpbmQiLCJvYnNlcnZlcnMiLCJ1bnN1YnNjcmliZXMiLCJvYnNlcnZlckNvdW50IiwidGFzayIsImZpbmFsaXplZCIsIm5leHQiLCJmb3JFYWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImNvbXBsZXRlIiwibmV4dE9yT2JzZXJ2ZXIiLCJpbXBsZW1lbnRzQW55TWV0aG9kcyIsIm5vb3AiLCJ1bnN1YiIsInVuc3Vic2NyaWJlT25lIiwiZmluYWxFcnJvciIsInNlbmRPbmUiLCJlcnIiLCJhc3luYyIsIm9uRXJyb3IiLCJhcmdzIiwibWV0aG9kcyIsIm1ldGhvZCIsInZhbGlkYXRlQXJnQ291bnQiLCJmbk5hbWUiLCJtaW5Db3VudCIsIm1heENvdW50IiwiYXJnQ291bnQiLCJhcmdFcnJvciIsImVycm9yUHJlZml4IiwiYXJnTmFtZSIsInZhbGlkYXRlTmFtZXNwYWNlIiwibmFtZXNwYWNlIiwib3B0aW9uYWwiLCJ2YWxpZGF0ZUNhbGxiYWNrIiwiYXJndW1lbnROYW1lIiwidmFsaWRhdGVDb250ZXh0T2JqZWN0IiwiY29udGV4dCIsInN0cmluZ1RvQnl0ZUFycmF5IiwiaGlnaCIsImxvdyIsInN0cmluZ0xlbmd0aCIsInV1aWR2NCIsInIiLCJyYW5kb20iLCJ2IiwiREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMiLCJERUZBVUxUX0JBQ0tPRkZfRkFDVE9SIiwiTUFYX1ZBTFVFX01JTExJUyIsIlJBTkRPTV9GQUNUT1IiLCJjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzIiwiYmFja29mZkNvdW50IiwiaW50ZXJ2YWxNaWxsaXMiLCJiYWNrb2ZmRmFjdG9yIiwiY3VyckJhc2VWYWx1ZSIsInBvdyIsInJhbmRvbVdhaXQiLCJyb3VuZCIsIm1pbiIsIm9yZGluYWwiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImluZGljYXRvciIsImFicyIsImNlbnQiLCJkZWMiLCJnZXRNb2R1bGFySW5zdGFuY2UiLCJfZGVsZWdhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ })

};
;